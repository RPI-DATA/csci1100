%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{fourier}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}



\title{CSCI-1100 Course Notes}
\date{Aug 07, 2018}
\release{}
\author{Chuck Stewart, Sibel Adali and Wes Turner}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{lecture_notes::doc}}



\chapter{Lecture 1 — Introduction}
\label{\detokenize{lecture_notes/lec01_intro:lecture-1-introduction}}\label{\detokenize{lecture_notes/lec01_intro::doc}}

\section{People}
\label{\detokenize{lecture_notes/lec01_intro:people}}\begin{itemize}
\item {} 
Professors: Wes Turner, Konstatin Kuzmin

\item {} 
Instructional Support Coordinator: Erica Eberwein

\item {} 
TAs and programming mentors:  see course website

\end{itemize}


\section{Learning Outcomes}
\label{\detokenize{lecture_notes/lec01_intro:learning-outcomes}}\begin{enumerate}
\item {} 
Demonstrate proficiency in the purpose and behavior of basic
programming constructs.

\item {} 
Design algorithms and programs to solve small-scale computational
programs.

\item {} 
Write, test and debug small-scale programs

\item {} 
Demonstrate an understanding of the widespread application of
computational thinking to real-world problems.

\end{enumerate}


\section{Textbook}
\label{\detokenize{lecture_notes/lec01_intro:textbook}}\begin{itemize}
\item {} 
\sphinxstyleemphasis{Practical Programming: An Introduction to Computer Science Using
Python} by Campbell, Gries, and Montojo
\begin{itemize}
\item {} 
Available in e-book form

\end{itemize}

\item {} 
Very important to get the \sphinxstylestrong{second edition}.

\end{itemize}


\section{Website and On-Line Resources}
\label{\detokenize{lecture_notes/lec01_intro:website-and-on-line-resources}}\begin{itemize}
\item {} 
Course notes will be posted at
\begin{quote}

\sphinxurl{http://www.cs.rpi.edu/academics/courses/spring18/csci1100}
\end{quote}

\item {} 
Piazza will be used for posting homework assignments and labs, and as a
public discussion site:
\begin{quote}

\sphinxurl{https://piazza.com/rpi/spring18/csci1100/home}
\end{quote}

You need to sign up with your \sphinxstyleemphasis{rpi.edu} account.

\end{itemize}


\section{Other items from the syllabus}
\label{\detokenize{lecture_notes/lec01_intro:other-items-from-the-syllabus}}\begin{itemize}
\item {} 
Prof. Turner’s office hours are:
\begin{itemize}
\item {} 
Tues/Thurs 2:00-3:30 in AE207

\end{itemize}

\item {} 
Prof. Kuzmin’s office hours are:
\begin{itemize}
\item {} 
Tues 4:00-5:30, AE127. Check the webpage.

\end{itemize}

\item {} 
Other office hours are posted on-line

\item {} 
Lab sections are held Tuesdays and Wednesdays. Full credit will be given for
finishing the lab within your lab period. Checkpoints completed before your
next lab will receive half credit.

\item {} 
Requirements and grading: lecture exercises, labs, homeworks, tests; letter grades

\item {} 
Appealing grades

\item {} 
Class attendance and participation; lecture notes

\item {} 
Homework late policy:
\begin{itemize}
\item {} 
3 LATE DAYS FOR THE WHOLE SEMESTER

\item {} 
2 LATE DAYS ON ANY ONE ASSIGNMENT

\end{itemize}

\item {} 
Academic integrity

\item {} 
Other exceptions: report to me right now or as soon as you know

\item {} 
Notes on schedule:
\begin{itemize}
\item {} 
Labs started Tuesday. As of now you should
have all the pieces you need to successfully complete
the remaining labs and homeworks for the semester.  If you had problems
completing Lab 0, please get help. You have to get it done to proceed.

\item {} 
No labs during the weeks of February 19 (President’s Day), March 12 (Spring Break) and
April 2 (GM Week).

\item {} 
Test dates are February 12, March 26, and April 16 all from 6 pm - 7:30 (90 minutes). You must be here or have an excused absence from Student Experience. If you do not have an excused absence for a test, you will get a 0. \sphinxstylestrong{No exceptions}!

\item {} 
Final exam will be held during finals week.  \sphinxstylestrong{No exceptions}!  So,
don’t make departure plans until the final exam schedule is posted.

\end{itemize}

\end{itemize}


\section{The Magic of Programming}
\label{\detokenize{lecture_notes/lec01_intro:the-magic-of-programming}}\begin{itemize}
\item {} 
Cold, harsh logic, and

\item {} 
Seemingly primitive syntax…

\item {} 
Leading to soaring creativity!

\end{itemize}


\section{Types of Problems We Will Study}
\label{\detokenize{lecture_notes/lec01_intro:types-of-problems-we-will-study}}\begin{itemize}
\item {} 
Tools used to help you win at \sphinxstyleemphasis{Words with Friends}

\item {} 
Image processing and manipulation

\item {} 
Web searching and crawling

\item {} 
Programs that work with data from Twitter and Flicker

\item {} 
Numerical examples, including games and physical simulations

\item {} 
Perhaps even a simple version of (part of) Pokemon Go.

\end{itemize}


\section{Jumping In Quickly with Our First Program — Hello World}
\label{\detokenize{lecture_notes/lec01_intro:jumping-in-quickly-with-our-first-program-hello-world}}\begin{itemize}
\item {} 
We create a text file called \sphinxcode{\sphinxupquote{hello.py}} containing just the two lines of Python code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello, World!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{This is Python}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
This is done by launching the Wing IDE, which is specific to creating
and running Python programs
\begin{itemize}
\item {} 
IDE stands for ’Integrated Development Environment’
\begin{itemize}
\item {} 
Two windows will appear — the top being the editor and the bottom
being the Python interpreter

\end{itemize}

\end{itemize}

\item {} 
Load the \sphinxcode{\sphinxupquote{hello.py}} program

\item {} 
Run it using the interpreter

\item {} 
We can also type Python code directly into the interpreter.

\end{itemize}


\section{Something a Bit More Interesting}
\label{\detokenize{lecture_notes/lec01_intro:something-a-bit-more-interesting}}\begin{itemize}
\item {} 
We are going to emphasize computational thinking throughout the
semester, so let’s look at a fun little problem and get started.

\item {} 
This problem is posed in \sphinxstyleemphasis{Think Python} and taken from the NPR show
\sphinxstyleemphasis{Car Talk}. If you know the answer, do NOT say it!
\begin{quote}

“Find the one word in the English language that contains three
consecutive double letters.”
\end{quote}

\item {} 
We will talk through the steps needed to develop and test a Python
program to solve this problem.
\begin{itemize}
\item {} 
The file containing this program will be posted on the course
website after class.

\end{itemize}

\item {} 
We do \sphinxstylestrong{not} intend that you will understand the details of the
program at this time. Rather, this is just an exercise that
illustrates the steps of solving a fun problem computationally.

\item {} 
On the other hand, it does introduce some elements that will be
seeing repeatedly throughout the semester:
\begin{itemize}
\item {} 
Files

\item {} 
Functions

\item {} 
Loops

\item {} 
Logic

\item {} 
Counting

\item {} 
Output

\item {} 
Libraries

\end{itemize}

\item {} 
In about six weeks, you will understand all parts of this program!

\item {} 
You can see the code in \sphinxcode{\sphinxupquote{three\_doubles}} from \DUrole{xref,std,std-doc}{../class\_code}

\end{itemize}


\section{Looking Back: What Steps Did We Follow?}
\label{\detokenize{lecture_notes/lec01_intro:looking-back-what-steps-did-we-follow}}\begin{enumerate}
\item {} 
Developing an understanding of what the problem is really asking.
This usually involves playing around with small examples.

\item {} 
Developing and describing a recipe (an “algorithm”) for solving the
problem
\begin{itemize}
\item {} 
Most recipes will involve multiple parts — multiple functional
steps

\end{itemize}

\item {} 
Turning this recipe into a program in the formal language of Python,
one of many different programming languages.
\begin{itemize}
\item {} 
English is too imprecise for specification of programs.

\end{itemize}

\item {} 
Running this program using the Python interpreter.

\end{enumerate}


\section{Programs, Compilers, Interpreters, Abstractions}
\label{\detokenize{lecture_notes/lec01_intro:programs-compilers-interpreters-abstractions}}\begin{itemize}
\item {} 
Python is an interpreted language — run immediately and interactively
by the Python interpreter, which is itself another (very complex)
program

\item {} 
Programs in some other (non-interpreted) languages like C, C++ and
Java must be compiled (by a “compiler” — another program) into a new
program in machine assembly language and then executed.

\item {} 
In both cases, we write programs that require other programs to run.
\begin{itemize}
\item {} 
And, we don’t just need just the compiler or interpreter — we need
the file system, the operating system, and the command-line
interpreter, each of them complicated, multi-part programs
themselves.

\end{itemize}

\item {} 
We don’t really think about the details of these programs; we just
think of what they do for us.
\begin{itemize}
\item {} 
This is called an “abstraction”.

\item {} 
It allows us to think about a problem we are trying to solve
without thinking about all the details of all the other systems we
are depending on.

\item {} 
Thinking in terms of abstractions is fundamental to computer
science.

\end{itemize}

\end{itemize}


\section{Why Python?}
\label{\detokenize{lecture_notes/lec01_intro:why-python}}\begin{itemize}
\item {} 
Python has a very simple syntax
\begin{itemize}
\item {} 
The roles of indentation and blank lines cause the most confusion.

\end{itemize}

\item {} 
Intepreted languages provide immediate, useful feedback

\item {} 
Python has a powerful set of tools — abstractions

\item {} 
Python is widely used in science, engineering and industry.

\item {} 
Python is good for rapid prototyping
\begin{itemize}
\item {} 
Sometimes, after a Python program is written and working, the
most time-consuming steps are rewritten in either C or C++ and
then integrated with the Python code.

\end{itemize}

\end{itemize}


\section{Two Types of Errors in Our Python Programs}
\label{\detokenize{lecture_notes/lec01_intro:two-types-of-errors-in-our-python-programs}}\begin{itemize}
\item {} 
A \sphinxstyleemphasis{syntax error} is a mistake in the form of the Python code that
will not allow it to run.

\item {} 
A \sphinxstyleemphasis{semantic error} is a mistake in the “meaning” of the program,
causing it to produce incorrect output, even if it runs.

\item {} 
We will demonstrate both types of errors by deliberately introducing
errors in our triple double example program.

\end{itemize}


\section{Python Versions}
\label{\detokenize{lecture_notes/lec01_intro:python-versions}}\begin{itemize}
\item {} 
Python, like all programming languages, is continually under
development.

\item {} 
We will be using the latest version, which is 3.6

\end{itemize}


\section{Lab 0 — Tuesday and Wednesday!}
\label{\detokenize{lecture_notes/lec01_intro:lab-0-tuesday-and-wednesday}}
By the end of Lab 0, you should have:
\begin{enumerate}
\item {} 
Signed up at the course Piazza web site
\begin{quote}

\sphinxurl{https://piazza.com/rpi/spring2018/csci1100/home}
\end{quote}

\item {} 
Gone to the course page
\begin{quote}

\sphinxurl{http://www.cs.rpi.edu/academics/courses/spring18/csci1100/python\_environment.html}
\end{quote}

and followed the instructions to install the Python environment on
your computer.
\begin{itemize}
\item {} 
There are installers for “native” versions of the environment for
Windows, Mac OS X and Linux machines.

\end{itemize}

\item {} 
Created a Dropbox account to store back-up copies “in the cloud” of
homework and lab solutions and lab for the course.
\begin{itemize}
\item {} 
Other cloud-based back-up copies are acceptable.

\end{itemize}

\end{enumerate}


\chapter{Lecture 2 — Python as a Calculator}
\label{\detokenize{lecture_notes/lec02_calculator:lecture-2-python-as-a-calculator}}\label{\detokenize{lecture_notes/lec02_calculator::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec02_calculator:overview}}
Most of this is covered in Chapter 2 of \sphinxstyleemphasis{Practical Programming}
\begin{itemize}
\item {} 
Part 1:
\begin{itemize}
\item {} 
Expressions and values

\item {} 
Types

\item {} 
Precedence

\end{itemize}

\item {} 
Part 2:
\begin{itemize}
\item {} 
Variables and memory

\item {} 
Errors

\item {} 
Typing directly in the interpreter vs. running programs; use of \sphinxstyleemphasis{print}

\item {} 
Documentation and variable names

\end{itemize}

\end{itemize}

Throughout we will pay attention to problems and mistakes, both real and
potential.


\section{Aside: Lectures, Note Taking and Exercises}
\label{\detokenize{lecture_notes/lec02_calculator:aside-lectures-note-taking-and-exercises}}\begin{itemize}
\item {} 
Lecture notes are outlines.
\begin{itemize}
\item {} 
Therefore, you should hand-write details as we cover them in
class.

\end{itemize}

\item {} 
We will create and run examples in class.
\begin{itemize}
\item {} 
You should write down the shorter ones

\item {} 
We will post the longer ones on-line, but you should write down as
much as you can, especially the results of running the
examples. If you don’t know what to expect, you can’t debug errors.

\end{itemize}

\end{itemize}


\section{Python As a Calculator}
\label{\detokenize{lecture_notes/lec02_calculator:python-as-a-calculator}}
We will start class by using Python as an interactive calculator,
working through a number of examples.
\begin{itemize}
\item {} 
The area of a circle.

\item {} 
The number of minutes in a year.

\item {} 
The volume of a box.

\item {} 
The volume of the earth in cubic kilometers.

\item {} 
In doing so, we will look at the basic operations of \sphinxcode{\sphinxupquote{+}}, \sphinxcode{\sphinxupquote{-}}, \sphinxcode{\sphinxupquote{*}}, \sphinxcode{\sphinxupquote{/}},
and \sphinxcode{\sphinxupquote{**}} (exponentiation).

\end{itemize}


\section{Whole Number Calculations}
\label{\detokenize{lecture_notes/lec02_calculator:whole-number-calculations}}\begin{itemize}
\item {} 
Most of the calculations in the foregoing examples involve numbers
with fractional values.

\item {} 
Sometimes we want to use whole number of calculations, for example
to convert a number of minutes to a number of hours and minutes
(less than 60).

\item {} 
In this case, Python offers us different forms of divisions
\begin{itemize}
\item {} 
// is the operator for whole number division

\item {} 
\% is used to find the remainder

\end{itemize}

\item {} 
For this kind of division, be careful of negative numbers.  Can you
figure out how they work with // and \%?
\begin{itemize}
\item {} 
This is a case where experimentation with the Python interpreter
is crucial.  We will encourage you to do this throughout the
semester.

\end{itemize}

\end{itemize}


\section{Python Types}
\label{\detokenize{lecture_notes/lec02_calculator:python-types}}\begin{itemize}
\item {} 
We have seen what look like real numbers and whole numbers.  These
are two different \sphinxstyleemphasis{types} in Python.

\item {} 
A type is a set of possible values — also called a “representation” —
and a set of operations on those values.
\begin{itemize}
\item {} 
Our first examples are the “operators” such as \sphinxcode{\sphinxupquote{+}}, \sphinxcode{\sphinxupquote{-}}, \sphinxcode{\sphinxupquote{*}}, \sphinxcode{\sphinxupquote{/}} and \sphinxcode{\sphinxupquote{**}}

\end{itemize}

\item {} 
Common Python types we are working with initially include
\sphinxcode{\sphinxupquote{float}}, \sphinxcode{\sphinxupquote{int}} (short for integer) and \sphinxcode{\sphinxupquote{str}} (short for string)

\item {} 
Each value we create will be referred to as an \sphinxstyleemphasis{object}

\end{itemize}


\section{float}
\label{\detokenize{lecture_notes/lec02_calculator:float}}\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{float}} type approximates real numbers.  But computers can’t
represent all of them because computers only dedicate a finite
amount of memory to each.

\item {} 
Limited precision:  we’ll look at 2/3, 5/3 and 8/3

\item {} 
Any time integers and floats are mixed and any time we apply
division, the result is always a float.

\end{itemize}


\section{int}
\label{\detokenize{lecture_notes/lec02_calculator:int}}\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{int}} (integer) type is analogous to whole numbers:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
Python can represent seemingly arbitrarily large integers, which is
not true of other languages like C, C++ and Java
\begin{itemize}
\item {} 
Using the Python interpreter, we will look at the examples of:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\end{itemize}

\end{itemize}


\section{Precedence}
\label{\detokenize{lecture_notes/lec02_calculator:precedence}}\begin{itemize}
\item {} 
Consider the formula for converting 45 degrees Fahrenheit to
Celsius. What is wrong with the following
computation?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{45} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{32} \PYG{o}{*} \PYG{l+m+mi}{5} \PYG{o}{/} \PYG{l+m+mi}{9}
\end{sphinxVerbatim}

\item {} 
Largely following the standard rules of algebra, Python applies
operations in order of \sphinxstyleemphasis{precedence}.  Here is a
summary of these rules from highest to lowest:
\begin{enumerate}
\item {} 
\sphinxcode{\sphinxupquote{( )}} - parentheses

\item {} 
\sphinxcode{\sphinxupquote{**}} - the exponentiation operator, ordered \sphinxstyleemphasis{right-to-left}

\item {} 
\sphinxcode{\sphinxupquote{-}} - the negation (unary minus) operators, as in \sphinxcode{\sphinxupquote{-5**2}}

\item {} 
\sphinxcode{\sphinxupquote{*, /, //, \%}} - ordered \sphinxstyleemphasis{left-to-right}

\item {} 
\sphinxcode{\sphinxupquote{+, -}} - ordered \sphinxstyleemphasis{left-to-right}

\end{enumerate}

\item {} 
This example also suggests an important question:  how do we know
we’ve made a mistake - introduced a \sphinxstyleemphasis{bug} - in our code?

\end{itemize}


\section{Part 1 Practice Problems}
\label{\detokenize{lecture_notes/lec02_calculator:part-1-practice-problems}}\begin{enumerate}
\item {} 
The consider the following evaluations (some of them trivial).  Which results
are \sphinxcode{\sphinxupquote{float}} objects and which are \sphinxcode{\sphinxupquote{int}} objects?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{9}            \PYG{c+c1}{\PYGZsh{} 1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{9.}           \PYG{c+c1}{\PYGZsh{} 2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{9.0}          \PYG{c+c1}{\PYGZsh{} 3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{9} \PYG{o}{+} \PYG{l+m+mi}{3}        \PYG{c+c1}{\PYGZsh{} 4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{9} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{3.}       \PYG{c+c1}{\PYGZsh{} 5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{9} \PYG{o}{/} \PYG{l+m+mi}{4}        \PYG{c+c1}{\PYGZsh{} 6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{9} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4}       \PYG{c+c1}{\PYGZsh{} 7}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{9.} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4}      \PYG{c+c1}{\PYGZsh{} 8}
\end{sphinxVerbatim}

\item {} 
What is output by the Python interpreter?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\item {} 
Write a single line of Python code that calculates the radius of a
circle with area 15 units and prints the value.  The output should
just be the number that your code produces.  Your code should include
the use of an expression involving division and exponentiation (to
compute the square root).  Use the value 3.14159 for \sphinxstyleemphasis{pi}.

\end{enumerate}


\section{Part 2}
\label{\detokenize{lecture_notes/lec02_calculator:part-2}}

\section{Variables and Assignment}
\label{\detokenize{lecture_notes/lec02_calculator:variables-and-assignment}}\begin{itemize}
\item {} 
Most calculators have one or several memory keys. Python, and all
other programming languages, use “variables” as their memory.

\item {} 
We’ll start with a simple example of the area of a circle, typed in
class. You will notice as we go through this that there is no output
until we use the \sphinxstyleemphasis{print} functions.

\item {} 
Here is a more extensive example of computing the volume and surface
area of a cylinder:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pi} \PYG{o}{=} \PYG{l+m+mf}{3.14159}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{radius} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{height} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{base\PYGZus{}area} \PYG{o}{=} \PYG{n}{pi} \PYG{o}{*} \PYG{n}{radius} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{volume} \PYG{o}{=} \PYG{n}{base\PYGZus{}area} \PYG{o}{*} \PYG{n}{height}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{surface\PYGZus{}area} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{base\PYGZus{}area} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{pi} \PYG{o}{*} \PYG{n}{radius} \PYG{o}{*} \PYG{n}{height}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{volume is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{volume}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{, surface area is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{surface\PYGZus{}area}\PYG{p}{)}
\PYG{g+go}{volume is 125.6636 , surface area is 150.79632}
\end{sphinxVerbatim}

\item {} 
A variable is a name that has a value “associated” with it.
\begin{itemize}
\item {} 
There are six variables in the above code.

\end{itemize}

\item {} 
The value is substituted for the variable when the variable
appears on the right hand side of the \sphinxcode{\sphinxupquote{=}}.

\item {} 
The value is \sphinxstylestrong{assigned to} the variable when the variable name
appears on the left hand side of the \sphinxcode{\sphinxupquote{=}}.

\end{itemize}


\section{More on Variable Assignment}
\label{\detokenize{lecture_notes/lec02_calculator:more-on-variable-assignment}}\begin{itemize}
\item {} 
The operator \sphinxcode{\sphinxupquote{=}} is an assignment of a value (calculated on the
right side) to a variable (on the left).

\item {} 
In the following..

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} } \PYG{n}{base\PYGZus{}area} \PYG{o}{=} \PYG{n}{pi} \PYG{o}{*} \PYG{n}{radius} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

Python
\begin{itemize}
\item {} 
accesses the values associated with the variables \sphinxcode{\sphinxupquote{pi}} and \sphinxcode{\sphinxupquote{radius}},

\item {} 
squares the value associated with \sphinxcode{\sphinxupquote{radius}} and then multiplies
the result by the value associated with the variable \sphinxcode{\sphinxupquote{pi}},

\item {} 
associates the result with the variable \sphinxcode{\sphinxupquote{base\_area}}

\end{itemize}

\item {} 
Later, Python accesses the value of \sphinxcode{\sphinxupquote{base\_area}} when calculating
the values to assign to \sphinxcode{\sphinxupquote{volume}} and \sphinxcode{\sphinxupquote{surface\_area}}.

\item {} 
Thus, the meaning of \sphinxcode{\sphinxupquote{=}} in Python is quite different from the
meaning of \sphinxcode{\sphinxupquote{=}} in mathematics.

\item {} 
The statement

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} } \PYG{n}{base\PYGZus{}area} \PYG{o}{*} \PYG{n}{height} \PYG{o}{=} \PYG{n}{volume}
\end{sphinxVerbatim}

is not legal Python code. Try it!

\item {} 
It takes a while to get accustomed to the meaning of an assignment
statement in Python.

\end{itemize}


\section{print}
\label{\detokenize{lecture_notes/lec02_calculator:print}}\begin{itemize}
\item {} 
Consider the line

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{volume is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{volume}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{, surface area is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{surface\PYGZus{}area}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{print}}
is a Python “function” that combines \sphinxstyleemphasis{strings} (between the
quotations) and values of variables, separated by commas, to
generate nice output.

\item {} 
We will play with a number of examples in class to illustrate use
of \sphinxcode{\sphinxupquote{print}}.  As the semester progresses we will learn a lot more
about it.

\end{itemize}


\section{Variable Names}
\label{\detokenize{lecture_notes/lec02_calculator:variable-names}}\begin{itemize}
\item {} 
Notice that our example variable names include letters and the \sphinxcode{\sphinxupquote{\_}}
(underscore) character.

\item {} 
Legal variable names in Python must
\begin{itemize}
\item {} 
Start with a letter or a \sphinxcode{\sphinxupquote{\_}}, and

\item {} 
Be followed by any number of letters, underscores or digits.

\end{itemize}

Characters that are none of these, including spaces, signal the end
of a variable name.

\item {} 
Capital letters and small letters are different

\item {} 
We will look at many examples in class.

\end{itemize}


\section{Putting Your Code in a File}
\label{\detokenize{lecture_notes/lec02_calculator:putting-your-code-in-a-file}}\begin{itemize}
\item {} 
So far in today’s lecture we have written our code using the \sphinxstyleemphasis{Python
Shell}.
\begin{itemize}
\item {} 
This sends your Python statements directly to the \sphinxstyleemphasis{interpreter} to
execute them

\end{itemize}

\item {} 
Now we will switch to writing and saving our code in a file and then
sending the file to the Python interpreter to be run.

\item {} 
We will demonstrate using the surface area and volume calculations
from earlier in lecture.

\item {} 
Almost all code that you write for lecture exercises, labs, and
homework assignments will be stored in files.

\item {} 
You will practice in Lab 1 next week.

\item {} 
Sometimes in class we will still type things directly into the
shell.  You will know we are doing this when you see \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}\textgreater{}}}

\end{itemize}


\section{Syntax and Semantic Errors}
\label{\detokenize{lecture_notes/lec02_calculator:syntax-and-semantic-errors}}\begin{itemize}
\item {} 
Python tells us about the errors we make in writing the names of
variables and in reversing the left and right side of the \sphinxcode{\sphinxupquote{=}}
operator.

\item {} 
These are examples of \sphinxstyleemphasis{syntax errors} — errors in the form of the
code.

\item {} 
Programs with syntax errors will not run; the Python interpreter
inspects the code and tells us about these errors before it tries to
execute them. We can then fix the errors and try again

\item {} 
More difficult to find and fix are \sphinxstyleemphasis{semantic errors} — errors in the
logical meaning of our programs resulting in an incorrect result.
\begin{itemize}
\item {} 
We have already seen an example of a semantic error. Can you think
where?

\item {} 
Throughout the semester we will discuss strategies for finding and
fixing semantic errors.

\end{itemize}

\end{itemize}


\section{Python Keywords}
\label{\detokenize{lecture_notes/lec02_calculator:python-keywords}}\begin{itemize}
\item {} 
All variable names that follow the above rules are legal Python
names \sphinxstyleemphasis{except} for a set of “keywords” that have special
meaning to Python.

\item {} 
Keywords allow us to write more complicated operations
— involving logic and repetition — than just calculating.

\item {} 
You can get a list of Python keywords by typing into the shell

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{keyword}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{keyword}\PYG{o}{.}\PYG{n}{kwlist}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Over the next few lectures, we will soon understand the detailed
meaning of the . in the above statement.

\end{itemize}


\section{Do Variables Exist Before They Are Assigned a Value?}
\label{\detokenize{lecture_notes/lec02_calculator:do-variables-exist-before-they-are-assigned-a-value}}\begin{itemize}
\item {} 
Suppose we forgot to assign \sphinxcode{\sphinxupquote{pi}} a value? What would happen?
\begin{itemize}
\item {} 
Try it out!

\end{itemize}

\item {} 
Variables do not exist until they are assigned a value.

\item {} 
This is a simple form of semantic error.

\end{itemize}


\section{Example to Consider}
\label{\detokenize{lecture_notes/lec02_calculator:example-to-consider}}\begin{enumerate}
\item {} 
Create 2 invalid variable names and 4 valid variable names from the
\sphinxcode{\sphinxupquote{\_}} character, the digit \sphinxcode{\sphinxupquote{0}}, and the letter \sphinxcode{\sphinxupquote{a}}.

\end{enumerate}


\section{Mixed Operators}
\label{\detokenize{lecture_notes/lec02_calculator:mixed-operators}}\begin{itemize}
\item {} 
Assignments of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

are commonly seen in Python. We will take a careful look at what is
happening here.

\item {} 
Python contains a short-hand for these:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

These two statements are exactly equivalent.

\item {} 
Other mixed operators include

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{o}{=}     \PYG{o}{*}\PYG{o}{=}    \PYG{o}{/}\PYG{o}{=}
\end{sphinxVerbatim}

but \sphinxcode{\sphinxupquote{+=}} is used most commonly for reasons that will gradually
become clear over the first half of the semester.

\end{itemize}


\section{Terminology: Expressions}
\label{\detokenize{lecture_notes/lec02_calculator:terminology-expressions}}\begin{itemize}
\item {} 
Expressions are formed from combinations values, variables and
operators.

\item {} 
In the examples we’ve seen so far, expressions are on the
right-hand side of an assignment statement, as in:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{surface\PYGZus{}area} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{base\PYGZus{}area} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{pi} \PYG{o}{*} \PYG{n}{radius} \PYG{o}{*} \PYG{n}{height}
\end{sphinxVerbatim}

\end{itemize}


\section{Part 2 Practice Problems}
\label{\detokenize{lecture_notes/lec02_calculator:part-2-practice-problems}}\begin{enumerate}
\item {} 
Which of the following are legal Python variable names?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import}
\PYG{l+m+mi}{56}\PYG{n}{abc}
\PYG{n}{abc56}
\PYG{n}{car}\PYG{o}{\PYGZhy{}}\PYG{n}{talk}
\PYG{n}{car\PYGZus{}talk}
\PYG{n}{car} \PYG{n}{talk}
\end{sphinxVerbatim}

\item {} 
Which of these lines of code contain syntax errors? Once you fix
the syntax errors, the program (assume this has been typed into a
file and run in the Wing IDE) will still not correctly print the
area of a circle with radius 6.5.  What two more changes are needed
to fixed these errors?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pi} \PYG{o}{=} \PYG{l+m+mi}{21} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{7}
\PYG{n}{area} \PYG{o}{=} \PYG{n}{pi} \PYG{o}{*} \PYG{n}{r} \PYG{o}{*} \PYG{n}{r}
\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{6.5}
\PYG{n}{r} \PYG{o}{+} \PYG{l+m+mi}{5} \PYG{o}{=} \PYG{n}{r\PYGZus{}new}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{area}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Assuming you start with \$100 and earn 5\% interest each year, how
much will you have at the end of one year, two years and three years?
Write Python expressions to calculate these, using variables as
appropriate.  We will write the solution into a file
and run the file using the interpreter.

\item {} 
What is the output of the following Python code (when typed into a
file and run in the interpreter)? Try to figure it out by hand
before typing the statements into a file and running in the Python
interpreter.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{12}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mf}{7.4}
\PYG{n}{x} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{y}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{x} \PYG{o}{+}\PYG{l+m+mi}{7}
\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{x} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{z}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{n}{y}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\end{enumerate}


\section{Summary — Important Points to Remember}
\label{\detokenize{lecture_notes/lec02_calculator:summary-important-points-to-remember}}\begin{itemize}
\item {} 
Expressions are formed from combinations of values, variables and
operators

\item {} 
Values in Python are one of several different types — integers,
floats, and strings for now.

\item {} 
Variables are Python’s form of memory

\item {} 
Python keywords can not be used as variables.

\item {} 
\sphinxcode{\sphinxupquote{=}} is Python’s means of assigning a value to a variable

\item {} 
Variables do not exist in Python until they are given a value

\item {} 
Make sure you have the precedence correct in your Python expressions.

\end{itemize}


\chapter{Lecture 2 — Exercises}
\label{\detokenize{lecture_notes/lec02_calculator_exercises/exercises:lecture-2-exercises}}\label{\detokenize{lecture_notes/lec02_calculator_exercises/exercises::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec02_calculator_exercises/exercises:overview}}
These problems are exercises to work on at the end of lecture and
submit for a small part of your grade.  Normally, solutions will be
due within 24 hours of the end of the lecture they are associated
with.  For these Lecture 2 exercises only, they will be due by the end
of Lab 1 so that any problems with submission can be ironed out.

Students are welcome to work on these problems in small groups, but
each student should write the final version of their solutions
independently.  Each student must submit their own solutions.


\section{Getting Started with the Wing IDE}
\label{\detokenize{lecture_notes/lec02_calculator_exercises/exercises:getting-started-with-the-wing-ide}}
Open up the Wing IDE:
\begin{itemize}
\item {} 
You can practice with small sections of Python code by typing in the
interpreter in the lower right pane.

\item {} 
In order to create a Python program that you save to a file, click
\sphinxstyleemphasis{File -\textgreater{} New}.  You can save it to a file by typing \sphinxstyleemphasis{File -\textgreater{} Save
As}

\item {} 
As discussed in Lab 0 you should save your programs in an organized
manner within your Dropbox folder.

\item {} 
Once you have drafted your code to solve a problem or, better yet,
have written enough that you are ready to experiment with what you
have, click on the green triangle to run your code.  You will see
the results in the interpreter pane on the lower right.

\item {} 
If you do not see the green triangle, you need to save your code
to a file first.

\end{itemize}

Now you are ready to proceed…


\section{Problems for Grade Submission}
\label{\detokenize{lecture_notes/lec02_calculator_exercises/exercises:problems-for-grade-submission}}\begin{enumerate}
\item {} 
Write a single line of Python code that converts the temperature
64 from Celsius to Fahrenheit and prints the value.  Submit a Python
file containing just this single line of code.  The output should
just be the number that your code produces.  Your code must include
the use of an expression involving multiplication and a \sphinxcode{\sphinxupquote{print}}
function call.

\item {} 
Write Python code that creates three variables called
\sphinxcode{\sphinxupquote{length}}, \sphinxcode{\sphinxupquote{width}} and \sphinxcode{\sphinxupquote{height}} to store the dimensions of a 16.5 x
12.5 x 5 box.  Write additional code that calculates the volume
of the box and calculates its surface area, storing each in a
variable.  Print the values of these variables.  Your code must use
five assignment statements and two print function calls.  Submit a
file containing these seven lines of Python code. Your output
should be

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{volume} \PYG{o}{=} \PYG{l+m+mf}{1031.25}
\PYG{n}{area} \PYG{o}{=} \PYG{l+m+mf}{702.5}
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Your problem is to determine the output of the Python program shown
below.  You must submit a text file showing the output.  (Hint:
there should be two lines with one integer on each line.)  While it
is possible to just run the program and copy the output, we
\sphinxstyleemphasis{strongly} encourage you to not do this.  You need to develop
the ability to read code and understand what it will do.  You will
be tested on it.

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{6} \PYG{o}{\PYGZhy{}} \PYG{n}{z} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{10} \PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Lecture 3 — Python Strings}
\label{\detokenize{lecture_notes/lec03_strings:lecture-3-python-strings}}\label{\detokenize{lecture_notes/lec03_strings::doc}}

\section{Reading}
\label{\detokenize{lecture_notes/lec03_strings:reading}}
This material is drawn from Chapter 4 of \sphinxstyleemphasis{Practical Programming}, 2nd
edition.


\section{More Than Just Numbers}
\label{\detokenize{lecture_notes/lec03_strings:more-than-just-numbers}}\begin{itemize}
\item {} 
Much of what we do today with computers revolves around text:
\begin{itemize}
\item {} 
Web pages

\item {} 
Facebook

\item {} 
Text messages

\end{itemize}

These require working with \sphinxstyleemphasis{strings}.

\item {} 
Strings are our third type, after integers and floats.

\item {} 
We’ve already seen the use of strings in output,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello world}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{8}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Value of x is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{value of y is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Topics for Today}
\label{\detokenize{lecture_notes/lec03_strings:topics-for-today}}\begin{itemize}
\item {} 
String basics

\item {} 
String operations

\item {} 
Input to and output from your Python programs

\end{itemize}


\section{Strings — Definition}
\label{\detokenize{lecture_notes/lec03_strings:strings-definition}}\begin{itemize}
\item {} 
A string is a sequence of 0 or more characters delimited by single
quotes or double quotes.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Rensselaer}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Albany, NY}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4 8 15 16 23 42}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
We can print strings:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello, world!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{Hello, world!}
\end{sphinxVerbatim}

\item {} 
Strings may be assigned to variables:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Good\PYGZhy{}bye}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{Hello}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t}
\PYG{g+go}{\PYGZsq{}Good\PYGZhy{}bye\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
Notice that unlike integers and floats there is now a difference
between asking the Python function \sphinxcode{\sphinxupquote{print}} to output the variable
and asking the Python interpreter directly for the value of the
variable.

\end{itemize}


\section{Combining Single and Double Quotes in a String}
\label{\detokenize{lecture_notes/lec03_strings:combining-single-and-double-quotes-in-a-string}}\begin{itemize}
\item {} 
A string that starts with double quotes must end with double quotes,
and therefore we can have single quotes inside.

\item {} 
A string that starts with single quotes must end with single quotes
and therefore we can have double quotes inside.

\item {} 
To illustrate this, we will take a look at

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{He said, }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Hello, World!}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Many single quotes here }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{  and here }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ but correct.}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\end{itemize}


\section{Multi-Line Strings}
\label{\detokenize{lecture_notes/lec03_strings:multi-line-strings}}\begin{itemize}
\item {} 
Ordinarily, strings do not extend across multiple lines, causing an
error if you try.

\item {} 
But, starting and ending a string \sphinxcode{\sphinxupquote{"""}} or \sphinxcode{\sphinxupquote{'{'}'}} tells Python to
allow the string to cross multiple lines.
\begin{itemize}
\item {} 
Any character other than \sphinxcode{\sphinxupquote{'{'}'}} (or \sphinxcode{\sphinxupquote{"""}}, if that is how the
string started) is allowed inside the string.

\end{itemize}

\item {} 
Example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+s2}{This}
\PYG{g+go}{is a multi\PYGZhy{}line}
\PYG{g+go}{string.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1}
\PYG{g+go}{\PYGZsq{}This\PYGZbs{}nis a multi\PYGZhy{}line\PYGZbs{}nstring.\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print} \PYG{n}{s1}
\PYG{g+go}{This}
\PYG{g+go}{is a multi\PYGZhy{}line}
\PYG{g+go}{string.}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
Notice the \sphinxcode{\sphinxupquote{\textbackslash{}n}} when we ask Python for the value of the string
(instead of printing it). This is an \sphinxstyleemphasis{escape character}, as we will
discuss next.

\end{itemize}


\section{Escape Characters}
\label{\detokenize{lecture_notes/lec03_strings:escape-characters}}\begin{itemize}
\item {} 
Inserting a \sphinxcode{\sphinxupquote{\textbackslash{}}} in the middle of a string tells Python that the
next character will have special meaning (if it is possible for it to
have special meaning).

\item {} 
Most importantly:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}n}} — end the current line of text and start a new one

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}t}} — skip to the next “tab stop” in the text. This allows
output in columns

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}'}} — do not interpret the \sphinxcode{\sphinxupquote{'}} as a string delimiter

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}"}} — do not interpret the \sphinxcode{\sphinxupquote{"}} as a string delimiter

\item {} 
\sphinxcode{\sphinxupquote{\textbackslash{}\textbackslash{}}} — put a true back-slash character into the string

\end{itemize}

\item {} 
We’ll explore the following strings in class

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s0} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{*}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{*}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{**}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{**}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{***}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{***}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I said, }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s2}{This is a valid string.}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\end{itemize}


\section{String Operations — Concatenation}
\label{\detokenize{lecture_notes/lec03_strings:string-operations-concatenation}}\begin{itemize}
\item {} 
Concatenation: Two (or more) strings may be concatenated to form a
new string, either with or without the \sphinxcode{\sphinxupquote{+}} operator. We’ll look at

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s0} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{World}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s0} \PYG{o}{+} \PYG{n}{s1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s0} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{s1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Good}\PYG{l+s+s1}{\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Morning}\PYG{l+s+s1}{\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{America!}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Good }\PYG{l+s+s1}{\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Morning }\PYG{l+s+s1}{\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{America!}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
Notice that

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s0} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ World}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s0} \PYG{n}{s1}
\end{sphinxVerbatim}

is a syntax error but

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ World}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

is not. Can you think why?

\end{itemize}


\section{String Operations — Replication}
\label{\detokenize{lecture_notes/lec03_strings:string-operations-replication}}\begin{itemize}
\item {} 
You can replicate strings by multiplying them by an integer:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ha}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s} \PYG{o}{*} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+go}{HaHaHaHaHaHaHaHaHaHa}
\end{sphinxVerbatim}

\item {} 
What do you think multiplying a string by a negative integer or 0
does? Try it.

\item {} 
Many expressions you might try to write involving strings and either
ints or floats are illegal Python, including the following:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{*} \PYG{l+m+mf}{8.1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{123}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+m+mi}{4}
\end{sphinxVerbatim}

Think about why

\end{itemize}


\section{Practice Problems - Part 1}
\label{\detokenize{lecture_notes/lec03_strings:practice-problems-part-1}}
We will go over these during lecture:
\begin{enumerate}
\item {} 
Which are valid Python strings:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{}\PYGZgt{} s1 = \PYGZsq{}\PYGZdq{}Hi mom\PYGZdq{}, I said.  \PYGZdq{}How are you?\PYGZdq{}\PYGZsq{}
\PYGZgt{}\PYGZgt{}\PYGZgt{} s2 = \PYGZsq{}\PYGZdq{}Hi mom\PYGZdq{}, I said.  \PYGZsq{}\PYGZdq{}How are you?\PYGZdq{}
\PYGZgt{}\PYGZgt{}\PYGZgt{} s3 = \PYGZsq{}\PYGZdq{}Hi mom\PYGZdq{}, I said.  \PYGZsq{}\PYGZdq{}How are you?\PYGZdq{}\PYGZsq{}
\PYGZgt{}\PYGZgt{}\PYGZgt{} s4 = \PYGZdq{}\PYGZdq{}\PYGZdq{}\PYGZsq{}Hi mom\PYGZdq{}, I said.  \PYGZsq{}\PYGZdq{}How are you?\PYGZdq{}\PYGZsq{}\PYGZdq{}\PYGZdq{}\PYGZdq{}
\PYGZgt{}\PYGZgt{}\PYGZgt{} s5 = \PYGZdq{}\PYGZdq{}I want to be a lion tamer!\PYGZdq{}\PYGZsq{}
\PYGZgt{}\PYGZgt{}\PYGZgt{} s6 = \PYGZdq{}\PYGZbs{}\PYGZdq{}Is this a cheese shop?\PYGZbs{}\PYGZdq{}\PYGZbs{}n\PYGZbs{}t\PYGZsq{}Yes\PYGZsq{}\PYGZbs{}n\PYGZbs{}t\PYGZbs{}\PYGZdq{}We have all kinds!\PYGZbs{}\PYGZdq{}\PYGZdq{}
\end{sphinxVerbatim}

For those that are not valid, what needs to be fixed?  For those
that are, what is the output when they are passed to the \sphinxcode{\sphinxupquote{print}}
function?

\item {} 
What is the output?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cats}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{are}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{good}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{sources}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{of}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{internet}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{memes}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
What is the output?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Good\PYGZhy{}bye}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Which of the following are legal? For those that are, show what
Python outputs when these are typed directly into the interpreter.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{def}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{def}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc }\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{def}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{def}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{+}\PYG{n}{y}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{n}{y}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{enumerate}


\section{String Operations — Functions}
\label{\detokenize{lecture_notes/lec03_strings:string-operations-functions}}\begin{itemize}
\item {} 
Python provides many operations for us to use in the form of
\sphinxstylestrong{functions}.  We have already seen \sphinxcode{\sphinxupquote{print()}}, but now we
are going to look at other functions that operate on strings.

\item {} 
You can compute the length of a string with \sphinxcode{\sphinxupquote{len()}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello!}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Here is what happens:
\begin{enumerate}
\item {} 
Function \sphinxcode{\sphinxupquote{len}} is provided with the value of the string associated
with variable \sphinxcode{\sphinxupquote{s}}

\item {} 
\sphinxcode{\sphinxupquote{len}} calculates the number of characters in the provided
string using its own code, code that is \sphinxstyleemphasis{built-in} to Python.

\item {} 
\sphinxcode{\sphinxupquote{len}} \sphinxstyleemphasis{returns} the calculated value (in this case, 6) and
this value is sent to the \sphinxcode{\sphinxupquote{print}} function, which actually
generates the output.

\end{enumerate}

\item {} 
We will learn more about using functions in Lectures 4 and 5.

\end{itemize}


\section{Example String Functions}
\label{\detokenize{lecture_notes/lec03_strings:example-string-functions}}\begin{itemize}
\item {} 
We will look at examples of all of the following during lecture…

\item {} 
You can convert an integer or float to a string with \sphinxcode{\sphinxupquote{str()}}.

\item {} 
You can convert a string that is in the form of an integer to an
integer using \sphinxcode{\sphinxupquote{int()}}

\item {} 
You can convert a string that is in the form of a float to a float
using, not surprisingly, \sphinxcode{\sphinxupquote{float()}}

\end{itemize}


\section{The print Function in More Detail}
\label{\detokenize{lecture_notes/lec03_strings:the-print-function-in-more-detail}}\begin{itemize}
\item {} 
We already know a bit about how to use \sphinxcode{\sphinxupquote{print()}}, but we can learn
about more using \sphinxcode{\sphinxupquote{help()}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n+nb}{print}\PYG{p}{)}
\PYG{n}{Help} \PYG{n}{on} \PYG{n}{built}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{function} \PYG{n+nb}{print} \PYG{o+ow}{in} \PYG{n}{module} \PYG{n}{builtins}\PYG{p}{:}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{value}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{file}\PYG{o}{=}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{stdout}\PYG{p}{,} \PYG{n}{flush}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

    \PYG{n}{Prints} \PYG{n}{the} \PYG{n}{values} \PYG{n}{to} \PYG{n}{a} \PYG{n}{stream}\PYG{p}{,} \PYG{o+ow}{or} \PYG{n}{to} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{stdout} \PYG{n}{by} \PYG{n}{default}\PYG{o}{.}
    \PYG{n}{Optional} \PYG{n}{keyword} \PYG{n}{arguments}\PYG{p}{:}
    \PYG{n}{file}\PYG{p}{:}  \PYG{n}{a} \PYG{n}{file}\PYG{o}{\PYGZhy{}}\PYG{n}{like} \PYG{n+nb}{object} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{)}\PYG{p}{;} \PYG{n}{defaults} \PYG{n}{to} \PYG{n}{the} \PYG{n}{current} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{stdout}\PYG{o}{.}
    \PYG{n}{sep}\PYG{p}{:}   \PYG{n}{string} \PYG{n}{inserted} \PYG{n}{between} \PYG{n}{values}\PYG{p}{,} \PYG{n}{default} \PYG{n}{a} \PYG{n}{space}\PYG{o}{.}
    \PYG{n}{end}\PYG{p}{:}   \PYG{n}{string} \PYG{n}{appended} \PYG{n}{after} \PYG{n}{the} \PYG{n}{last} \PYG{n}{value}\PYG{p}{,} \PYG{n}{default} \PYG{n}{a} \PYG{n}{newline}\PYG{o}{.}
    \PYG{n}{flush}\PYG{p}{:} \PYG{n}{whether} \PYG{n}{to} \PYG{n}{forcibly} \PYG{n}{flush} \PYG{n}{the} \PYG{n}{stream}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{flush}} is useful when trying to debug. If you are trying to trace your
program execution using print, adding \sphinxcode{\sphinxupquote{flush=True}} as your final argument
will give you more accurate results. We will talk about this more later.

\item {} 
For now, we will focus on the \sphinxcode{\sphinxupquote{sep}} and \sphinxcode{\sphinxupquote{end}} and illustrate with examples.

\end{itemize}


\section{User Input}
\label{\detokenize{lecture_notes/lec03_strings:user-input}}\begin{itemize}
\item {} 
Python programs can ask the user for input using the function called
\sphinxcode{\sphinxupquote{input}}.

\item {} 
This waits for the user to type a line of input, which Python reads
as a string.

\item {} 
This string can be converted to an integer or a float (as long as it
is properly an int/float).

\item {} 
Here is a toy example

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter a number}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The square of}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We can also insert the string right into the \sphinxcode{\sphinxupquote{input}} function
call:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter a new number }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The square of}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
A similar function exists to convert a string to an integer:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter an integer }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We will use this idea to modify our area and volume calculation so
that the user of the program types in the numbers.
\begin{itemize}
\item {} 
The result is more useful and feels more like a real program
(run from the command line).

\item {} 
It will be posted on the course website.

\end{itemize}

\end{itemize}


\section{Practice Problems - Part 2}
\label{\detokenize{lecture_notes/lec03_strings:practice-problems-part-2}}\begin{enumerate}
\item {} 
What is the output for this Python program?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{George}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ Tom  }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+s2}{Hi}
\PYG{l+s+s2}{sis!}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Which of the following are legal? For those that are, show what
Python outputs when these are typed directly into the interpreter.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{*} \PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+m+mi}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{*} \PYG{l+m+mi}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+m+mf}{5.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{float}\PYG{p}{(}\PYG{l+m+mf}{5.0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mf}{3.0}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\item {} 
What is the output of the following when the user types 4 when
running the following Python program?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Enter an integer ==\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x is:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
What is the output when the user types the value 64 when running
the following Python program?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Enter an integer ==\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{x} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{10}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{y} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{10}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

What happens when you do not have the call to the \sphinxcode{\sphinxupquote{int}} function?

\item {} 
Write a program that requests an integer from the user as an input
and stores in the variable \sphinxcode{\sphinxupquote{n}}.  The program should then print
\sphinxcode{\sphinxupquote{n}} 1’s with 0’s inbetween.  For example if the user input the
value 4 then the output should be

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1010101}
\end{sphinxVerbatim}

\end{enumerate}


\section{Summary}
\label{\detokenize{lecture_notes/lec03_strings:summary}}\begin{itemize}
\item {} 
Strings represent character sequences — our third Python type

\item {} 
String operations include addition (concatenate) and replication

\item {} 
Functions on strings may be used to determine length and to convert
back and forth to integers and floats.

\item {} 
Escape sequences change the meaning of special Python characters or
make certain characters have special meaning.

\item {} 
Some special characters of note: \sphinxcode{\sphinxupquote{\textbackslash{}n}} for new line, \sphinxcode{\sphinxupquote{\textbackslash{}t}} for tab.
They are each preceded by \sphinxcode{\sphinxupquote{\textbackslash{}}}

\item {} 
The \sphinxcode{\sphinxupquote{print()}} function offers significant flexibility.

\item {} 
We can read input using \sphinxcode{\sphinxupquote{input()}}

\end{itemize}


\chapter{Lecture 3 — Exercises}
\label{\detokenize{lecture_notes/lec03_strings_exercises/exercises:lecture-3-exercises}}\label{\detokenize{lecture_notes/lec03_strings_exercises/exercises::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec03_strings_exercises/exercises:overview}}
Solutions to the problems below must be sent to Submitty for grading.
A separate file must submitted for each problem, as practiced in
Lab 1.  For these Lecture 3 exercises, you must submit your
solutions before Wednesday, September 13 at 11:59:59. Starting with Lecture 4,
you will be required to submit you lecture exercises within 24 hours
of the end of lecture.  Students are
welcome to work on these problems in small groups, but each student
should write the final version of their solutions independently to
assure themselves that they understand.


\section{Problems}
\label{\detokenize{lecture_notes/lec03_strings_exercises/exercises:problems}}\begin{enumerate}
\item {} 
Which of the following are valid strings?  Upload a text file to
Submitty that contains just the variable names that are assigned to
strings that are correct.  For example if only the first two were
correct your file would contain s0 on the first line and s1 on the
second.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{}\PYGZgt{} s0 = \PYGZdq{}Sheldon Cooper\PYGZsq{}s apartment is in Pasedena\PYGZdq{}

\PYGZgt{}\PYGZgt{}\PYGZgt{} s1 = \PYGZsq{}This cheese shop\PYGZsq{}s cheese is all gone\PYGZdq{}

\PYGZgt{}\PYGZgt{}\PYGZgt{} s2 = \PYGZdq{}\PYGZdq{}\PYGZdq{}We are
\PYGZdq{}The Knights of the Round Table\PYGZdq{}
\PYGZdq{}\PYGZdq{}\PYGZdq{}

\PYGZgt{}\PYGZgt{}\PYGZgt{} s3 = \PYGZdq{}Toto, I said,\PYGZbs{}n\PYGZdq{}We aren\PYGZsq{}t in Kansas, anymore!\PYGZdq{}


\PYGZgt{}\PYGZgt{}\PYGZgt{} s4 = \PYGZsq{}Have you seen the \PYGZdq{}Final Five\PYGZdq{}\PYGZsq{}s picture?\PYGZsq{}


\PYGZgt{}\PYGZgt{}\PYGZgt{} s5 = \PYGZdq{}Have you seen the \PYGZsq{}Final Five\PYGZsq{}\PYGZsq{}s picture?\PYGZdq{}
\end{sphinxVerbatim}

\item {} 
Submit a Python file that includes a single line of code that prints
25 \sphinxcode{\sphinxupquote{'*'}} characters followed by 25 \sphinxcode{\sphinxupquote{'+'}} characters, with no
space in between.  It must, of course, use the \sphinxcode{\sphinxupquote{print}} function.
The two characters must appear in your code \sphinxstyleemphasis{much less} than 25
times - at most three each!

\item {} 
Write a program that assigns the value 4 to the variable \sphinxcode{\sphinxupquote{x}}, the
value 2 to the variable \sphinxcode{\sphinxupquote{y}} and then uses exactly \sphinxstyleemphasis{three}
\sphinxcode{\sphinxupquote{print}} function calls to generate the output below (four lines,
with the second line blank).  The \sphinxcode{\sphinxupquote{print}} calls must use the
variables \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}} rather than the values 4 and 2.  The
trick is to change the assignment of the \sphinxcode{\sphinxupquote{sep}} and \sphinxcode{\sphinxupquote{end}}
parameters in the call to \sphinxcode{\sphinxupquote{print}}.  The character \sphinxcode{\sphinxupquote{4}} is the
first character on the 1st, 3rd and 4th lines of output.

\end{enumerate}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{2}

\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}
\PYG{l+m+mi}{42}
\end{sphinxVerbatim}
\end{quote}


\chapter{Lecture 4 — Using functions and modules}
\label{\detokenize{lecture_notes/lec04_modules_functions1:lecture-4-using-functions-and-modules}}\label{\detokenize{lecture_notes/lec04_modules_functions1::doc}}

\section{Reading}
\label{\detokenize{lecture_notes/lec04_modules_functions1:reading}}\begin{itemize}
\item {} 
Material for this lecture is drawn from Sections 3.1, 6.1 and
7.1-7.3 of \sphinxstyleemphasis{Practical Programming}.

\item {} 
Topics that we will discuss include:
\begin{itemize}
\item {} 
Python functions for different data types.

\item {} 
String functions and calling functions on objects

\item {} 
Using modules provided with Python

\end{itemize}

\item {} 
We will revisit all these concepts several times throughout the semester.

\end{itemize}


\section{What have we learned so far?}
\label{\detokenize{lecture_notes/lec04_modules_functions1:what-have-we-learned-so-far}}\begin{itemize}
\item {} 
So far, we have learned about three basic data types: integer, float
and strings.

\item {} 
We also learned some valuable functions that operate on strings
(\sphinxcode{\sphinxupquote{len}}) and that convert between data types (\sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{str}}, \sphinxcode{\sphinxupquote{float}})
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Pickle Rick}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}
\PYG{g+go}{11}
\end{sphinxVerbatim}
\end{quote}

\item {} 
The functions that Python provides are called \sphinxstyleemphasis{built-in} functions.

\item {} 
We will see examples of these functions and experiment with their
use in this class.

\end{itemize}


\section{How about numerical functions?}
\label{\detokenize{lecture_notes/lec04_modules_functions1:how-about-numerical-functions}}\begin{itemize}
\item {} 
Many numerical functions also exist. Let us experiment with some of
these first. You should make a note of what they do.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{abs()}}

\item {} 
\sphinxcode{\sphinxupquote{pow()}}

\item {} 
\sphinxcode{\sphinxupquote{int()}}

\item {} 
\sphinxcode{\sphinxupquote{float()}}

\item {} 
\sphinxcode{\sphinxupquote{round()}}

\item {} 
\sphinxcode{\sphinxupquote{max()}}

\item {} 
\sphinxcode{\sphinxupquote{min()}}

\end{itemize}

\item {} 
We will look carefully in class at how these work.

\end{itemize}


\section{Objects and Methods}
\label{\detokenize{lecture_notes/lec04_modules_functions1:objects-and-methods}}\begin{itemize}
\item {} 
All variables in Python are objects.

\item {} 
Objects are abstractions:
\begin{itemize}
\item {} 
Each object defines an organization and structure to the data they
store.

\item {} 
They have operations/functions — we call them \sphinxstylestrong{methods} —
that we can apply to access and manipulate this data.

\item {} 
We don’t think about how they are implemented; instead we just
think about how to use them.  This is why they are called
abstractions.

\end{itemize}

\item {} 
Methods associate with objects often use a function call syntax of
the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{variable}\PYG{o}{.}\PYG{n}{method}\PYG{p}{(}\PYG{n}{arguments}\PYG{p}{)}
\end{sphinxVerbatim}

For example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{good morning}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

This also works on particular values instead of variables:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{value}\PYG{o}{.}\PYG{n}{method}\PYG{p}{(}\PYG{n}{arguments}\PYG{p}{)}
\end{sphinxVerbatim}

as in

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{good morning}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
You can see all the methods that apply to an object type with help
as well. Try:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{help}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{String Methods}
\label{\detokenize{lecture_notes/lec04_modules_functions1:string-methods}}\begin{itemize}
\item {} 
Here are a few more (of many) string methods:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Neil Degrasse Tyson}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{name}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}neil degrasse tyson\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{lowername} \PYG{o}{=} \PYG{n}{name}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{lowername}\PYG{o}{.}\PYG{n}{upper}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}NEIL DEGRASSE TYSON\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{lowername}\PYG{o}{.}\PYG{n}{capitalize}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}Neil degrasse tyson\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{lowername}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}Neil Degrasse Tyson\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{abracadabra}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{br}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dr}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}adracadadra\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{abracadabra}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}brcdbr\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Neil Degrasse Tyson}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Neil Degrasse Tyson}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{9}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Neil Degrasse Tyson}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Monty Python}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{o}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{aaabbbfsassassaaaa}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}bbbfsassass\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
As described above, all of these are called in the form of
\sphinxcode{\sphinxupquote{object.method(arguments)}}, where \sphinxcode{\sphinxupquote{object}} is either a string
variable or a string value.

\item {} 
Not all functions on objects are called this way. Some are called
using more of a function form, while others are called as
operators.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{episode} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cheese Shop}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{episode}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}cheese shop\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{episode}\PYG{p}{)}
\PYG{g+go}{11}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{episode} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{!}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+go}{\PYGZsq{}Cheese Shop!\PYGZsq{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
We will see the reason for the differences later in the semester.

\end{itemize}

\item {} 
Note of caution:  none of these functions change the variable that they
are applied to.

\end{itemize}


\section{Practice Problems (1)}
\label{\detokenize{lecture_notes/lec04_modules_functions1:practice-problems-1}}\begin{enumerate}
\item {} 
Write code that takes a string in a variable called \sphinxcode{\sphinxupquote{phrase}} and
prints the string with all vowels removed.

\item {} 
Create a string in a variable and assign it to a variable called
\sphinxcode{\sphinxupquote{name}}.  Write code to create a new string that repeats each
letter \sphinxcode{\sphinxupquote{a}} in \sphinxcode{\sphinxupquote{name}} as many times as \sphinxcode{\sphinxupquote{a}} appears in \sphinxcode{\sphinxupquote{name}}
(assume the word is all lower case).

For example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{amos eaton}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+go}{\PYGZsh{}\PYGZsh{} your code goes here}




\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{name}
\PYG{g+go}{\PYGZsq{}aamos eaaton\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
Given a string in a variable called \sphinxcode{\sphinxupquote{name}}, switch all letters
\sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{e}} (only lowercase versions). Assume the variable
contains only letters and spaces.

Hint: first replace each ‘a’ with ‘1’.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Rensselaer Polytechnic Institute}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+go}{\PYGZsh{}\PYGZsh{} your code goes here}



\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{name}
\PYG{g+go}{\PYGZsq{}Ranssalear Polytachnic Instituta\PYGZsq{}}
\end{sphinxVerbatim}

\end{enumerate}


\section{String Format Method}
\label{\detokenize{lecture_notes/lec04_modules_functions1:string-format-method}}\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{format()}} method provides a nice way to produce clean
looking output.

\item {} 
For example, consider the code

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pi} \PYG{o}{=} \PYG{l+m+mf}{3.14159}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{2.5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{volume} \PYG{o}{=} \PYG{n}{pi} \PYG{o}{*} \PYG{n}{r}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{h}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A cylinder of radius}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{and height}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{has volume}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{volume}\PYG{p}{)}
\PYG{g+go}{A cylinder of radius 2.5 and height 3.1622776601683795 has volume 62.09112421505237}
\end{sphinxVerbatim}

\item {} 
Now look at what we can do with the \sphinxcode{\sphinxupquote{format()}} method:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{out\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A cylinder of radius }\PYG{l+s+si}{\PYGZob{}0:.2f\PYGZcb{}}\PYG{l+s+s1}{ and height }\PYG{l+s+si}{\PYGZob{}1:.2f\PYGZcb{}}\PYG{l+s+s1}{ has volume }\PYG{l+s+si}{\PYGZob{}2:.2f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{n}{volume}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{out\PYGZus{}string}\PYG{p}{)}
\PYG{g+go}{A cylinder of radius 2.50 and height 3.16 has volume 62.09}
\end{sphinxVerbatim}

\item {} 
Method \sphinxcode{\sphinxupquote{format()}} replaces the substrings between \{ \} with
values from the argument list.
\begin{itemize}
\item {} 
\{0:.2f\} means argument 0, will be formatted as a float with 2
digits shown to the right of the decimal place.
\begin{itemize}
\item {} 
Notice it applies rounding.

\end{itemize}

\item {} 
We can leave off the 0, the 1, and the 2 from before the : unless
we want to change the order of the output.

\item {} 
We can leave off the :.2f if we want to accept print’s normal
formatting on float outputs.

\end{itemize}

\item {} 
There are many variations on this and we will see quite a few as we
progress through the semester.

\end{itemize}


\section{Built-In Functions}
\label{\detokenize{lecture_notes/lec04_modules_functions1:built-in-functions}}\begin{itemize}
\item {} 
All the functions we have seen so far are \sphinxstyleemphasis{built-in} to the core
Python. It means that these functions are available when you start
Python.

\item {} 
Type

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{help}\PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}builtins\PYGZus{}\PYGZus{}}\PYG{p}{)}
\end{sphinxVerbatim}

to see the full list.

\end{itemize}


\section{Modules}
\label{\detokenize{lecture_notes/lec04_modules_functions1:modules}}\begin{itemize}
\item {} 
Now we will begin to look at using functions that are not built
into the core of Python but rather imported as \sphinxstylestrong{modules}.

\item {} 
Modules are collections of functions and constants that
provide additional power to Python programs.

\item {} 
Some modules come with Python, but are not loaded automatically. For
example the \sphinxcode{\sphinxupquote{math}} module.

\item {} 
Other modules need to be installed first. When we installed software
in Lab 0, we installed a library called \sphinxcode{\sphinxupquote{pillow}} that has a
number of image manipulation modules.

\item {} 
To use a function in a module, first you must load it into your
program using \sphinxcode{\sphinxupquote{import}}. Let’s see the \sphinxcode{\sphinxupquote{math}} module:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+go}{2.2360679774997898}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{math}\PYG{o}{.}\PYG{n}{trunc}\PYG{p}{(}\PYG{l+m+mf}{4.5}\PYG{p}{)}
\PYG{g+go}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{math}\PYG{o}{.}\PYG{n}{ceil}\PYG{p}{(}\PYG{l+m+mf}{4.5}\PYG{p}{)}
\PYG{g+go}{5.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{math}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{10.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}
\PYG{g+go}{3.141592653589793}
\end{sphinxVerbatim}

\item {} 
We can get an explanation of what functions and variables are
provided in a module using the \sphinxcode{\sphinxupquote{help}} function

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{help}\PYG{p}{(}\PYG{n}{math}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Different Ways of Importing}
\label{\detokenize{lecture_notes/lec04_modules_functions1:different-ways-of-importing}}\begin{itemize}
\item {} 
The way you import a module determines what syntax you need to use
the contents of the module in your program.

\item {} 
We can import only a selection of functions and variables:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k}{import} \PYG{n}{sqrt}\PYG{p}{,}\PYG{n}{pi}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pi}
\PYG{g+go}{3.141592653589793}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{2.0}
\end{sphinxVerbatim}

\item {} 
Or we can give a new name to the module within our program:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k}{as} \PYG{n+nn}{m}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{m}\PYG{o}{.}\PYG{n}{pi}
\PYG{g+go}{3.141592653589793}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{2.0}
\end{sphinxVerbatim}

\item {} 
Both of these methods help us distinguish between the function
\sphinxcode{\sphinxupquote{sqrt}} and the data \sphinxcode{\sphinxupquote{pi}} defined in the math module from a
function with the same name (if we had one) in our program.

\item {} 
We can also do this (which is NOT recommended!):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k}{import} \PYG{o}{*}
\end{sphinxVerbatim}

Now, there is no name difference between the math module functions
and ours. Since this leads to confusion when the same name appears
in two different modules it is almost always avoided.

\end{itemize}


\section{Program Structure}
\label{\detokenize{lecture_notes/lec04_modules_functions1:program-structure}}\begin{itemize}
\item {} 
We have now seen several components of a program:
\sphinxcode{\sphinxupquote{import}}, comments, and our own code, including input,
computation and output statements.  We will add more components,
such as our own functions, as we proceed through the semester.

\item {} 
You should organize these components in your program files to make it
easy to see the flow of the program

\item {} 
We will use the following convention to order the program
components:
\begin{itemize}
\item {} 
an initial comment explaining the purpose of the program,

\item {} 
all \sphinxcode{\sphinxupquote{import}} statements,

\item {} 
then all variables and input commands,

\item {} 
then all computation,

\item {} 
finally all output.

\end{itemize}

\end{itemize}


\section{Putting It All Together}
\label{\detokenize{lecture_notes/lec04_modules_functions1:putting-it-all-together}}\begin{itemize}
\item {} 
In the rest of this class we will write a program that first asks
the user for a name, then asks for the radius and height of a
cylinder, and finally prints the surface area and volume of the cylinder,
nicely formatted.

\end{itemize}


\section{Practice Problems (2)}
\label{\detokenize{lecture_notes/lec04_modules_functions1:practice-problems-2}}\begin{enumerate}
\item {} 
The \sphinxcode{\sphinxupquote{math}} module contains the constant \sphinxcode{\sphinxupquote{e}} as well as \sphinxcode{\sphinxupquote{pi}}.
Write code that prints these values accurate to 3 decimal places
and then write code that computes and outputs
\begin{equation*}
\begin{split}\pi^e\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}e^\pi\end{split}
\end{equation*}
both accurate to 2 decimal places.

\item {} 
Write a short program to ask the user to input height
values (in cm) three times.  After reading these values (as
integers), the program should output the largest, the smallest and
the average of the height values.

\item {} 
What happens when we type

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{=} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

and then use \sphinxcode{\sphinxupquote{math.pi}}?

\end{enumerate}


\section{Summary}
\label{\detokenize{lecture_notes/lec04_modules_functions1:summary}}\begin{itemize}
\item {} 
Python provides many functions that perform useful operations on
strings, integers and floats.

\item {} 
Some of these functions are \sphinxstyleemphasis{built in} while others are organized
into modules.

\item {} 
Be aware of the differences between how functions are called. You
must remember them to call them correctly.
\begin{itemize}
\item {} 
Functions that require dot notation, applying the function
to an object (or a variable containing an object):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{abc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{upper}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}ABC\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
Functions that are called with arguments (no dot notation):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{4.6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}5}
\end{sphinxVerbatim}

Note that these functions are actually aliases. The same function
also exists in dot notation.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}abs\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{4.6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}round\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{4.6}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}round\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}abs\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{1}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
After a module is imported, the functions in the module can be
used by a call of the form:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{module\PYGZus{}name}\PYG{o}{.}\PYG{n}{function\PYGZus{}name}\PYG{p}{(}\PYG{n}{arguments}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
You can see the details of a function by:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{help}\PYG{p}{(}\PYG{n}{module\PYGZus{}name}\PYG{o}{.}\PYG{n}{function\PYGZus{}name}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Python has many modules that make it easy to do
complicated tasks. If you do not believe it, try typing:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{antigravity}
\end{sphinxVerbatim}

\end{itemize}


\chapter{Lecture 4 — Exercises}
\label{\detokenize{lecture_notes/lec04_modules_functions1_exercises/exercises:lecture-4-exercises}}\label{\detokenize{lecture_notes/lec04_modules_functions1_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for grading.
A separate file must submitted for each problem.  These must be
submitted by 4 pm on Tuesday, January 30.
\begin{enumerate}
\item {} 
Write a program that assigns a string to the variable called
\sphinxcode{\sphinxupquote{phrase}} and then transforms \sphinxcode{\sphinxupquote{phrase}} into a hashtag.  In other
words, all words in \sphinxcode{\sphinxupquote{phrase}} are capitalized, all spaces are
removed, and a \sphinxcode{\sphinxupquote{\#}} appears in front.  Store the result in a
variable called \sphinxcode{\sphinxupquote{hashtag}}.  Then print the value of both
\sphinxcode{\sphinxupquote{phrase}} and \sphinxcode{\sphinxupquote{hashtag}}.  Your program should start with

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{phrase} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Things you wish you knew as a freshman}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

and the output from the program (using \sphinxcode{\sphinxupquote{print()}} function
calls) should be

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{phrase} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Things you wish you knew as a freshman}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{becomes} \PYG{n}{the} \PYG{n}{hashtag} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}ThingsYouWishYouKnewAsAFreshman}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

Note that the output includes the quotation marks.

\item {} 
One of the challenges of programming is that there are often many
ways to solve even the simplest problem.  Consider computing the
area of the circle with the standard formula
\begin{equation*}
\begin{split}a(r) = \pi r^2\end{split}
\end{equation*}
Fortunately, we now have \sphinxcode{\sphinxupquote{pi}} from the \sphinxstyleemphasis{math} module, but to
compute the square of the radius we now can use \sphinxcode{\sphinxupquote{**}} or
\sphinxcode{\sphinxupquote{pow()}} or we can just multiply the radius times itself.  To
print the area accurate to only a few decimal places we can now use
the string \sphinxcode{\sphinxupquote{format()}} method or the \sphinxcode{\sphinxupquote{round()}} built-in
function, which includes an optional second argument to specify the
number of decimal places.

Write a short Python program that computes and prints the areas of
two circles, one with radius 5 and the other with radius 32.  Your
code must use \sphinxcode{\sphinxupquote{**}} once and \sphinxcode{\sphinxupquote{pow()}} once and it must use
\sphinxcode{\sphinxupquote{format()}} once and \sphinxcode{\sphinxupquote{round()}} once.  The output should be
exactly

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Area} \PYG{l+m+mi}{1} \PYG{o}{=} \PYG{l+m+mf}{78.54}
\PYG{n}{Area} \PYG{l+m+mi}{2} \PYG{o}{=} \PYG{l+m+mf}{3216.99}
\end{sphinxVerbatim}

\end{enumerate}


\chapter{Lecture 5 — Python Functions}
\label{\detokenize{lecture_notes/lec05_functions2:lecture-5-python-functions}}\label{\detokenize{lecture_notes/lec05_functions2::doc}}

\section{Reading}
\label{\detokenize{lecture_notes/lec05_functions2:reading}}
Most of this is covered late in Chapter 3 of \sphinxstyleemphasis{Practical Programming}.


\section{Why Functions?}
\label{\detokenize{lecture_notes/lec05_functions2:why-functions}}\begin{itemize}
\item {} 
The purpose of today’s class is to introduce the basics of writing
and running Python functions.
\begin{itemize}
\item {} 
Repeating code is painful.

\item {} 
It is also hard to distinguish between the same code
repeated three times and three different computations.

\item {} 
It is easy to find a mistake in one copy of a section of code
and forget to fix it in the other copies.

\end{itemize}

\item {} 
Learn a programmer’s motto: DRY \textendash{} don’t repeat yourself.
\begin{itemize}
\item {} 
Define it once and use it multiple times.

\end{itemize}

\item {} 
Functions are extremely useful for writing complex programs:
\begin{itemize}
\item {} 
They divide complex operations into a combination of simpler steps.

\item {} 
They make programs easier to read and debug by abstracting out frequently
repeated code.

\end{itemize}

\end{itemize}


\section{Functions}
\label{\detokenize{lecture_notes/lec05_functions2:functions}}\begin{itemize}
\item {} 
As we have learned, a function
\begin{itemize}
\item {} 
Takes as input one or more arguments.

\item {} 
Computes a new value, a string or a number.

\item {} 
Returns the value, so that it can be assigned to a variable or
output.

\end{itemize}

\item {} 
Let’s recall this with a built-in function:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RPI Puckman}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{11}
\end{sphinxVerbatim}

Can you identify the input argument, the computation and the
returned value?

\end{itemize}


\section{A Function to Compute the Area of a Circle}
\label{\detokenize{lecture_notes/lec05_functions2:a-function-to-compute-the-area-of-a-circle}}\begin{itemize}
\item {} 
In mathematics, many functions are given as formulas. You might
write a function to calculate the area of a circle as
\begin{equation*}
\begin{split}a(r) = \pi r^2\end{split}
\end{equation*}
\item {} 
In Python, typing into a file (in the upper pane of the Wing IDE),
we write

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{area\PYGZus{}circle}\PYG{p}{(}\PYG{n}{radius}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{pi} \PYG{o}{=} \PYG{l+m+mf}{3.14159}
    \PYG{n}{area} \PYG{o}{=} \PYG{n}{pi} \PYG{o}{*} \PYG{n}{radius}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{k}{return} \PYG{n}{area}
\end{sphinxVerbatim}

\item {} 
Note that the \sphinxcode{\sphinxupquote{def}} is not indented and the other lines are
indented four spaces.

\item {} 
We add unindented code the file below the definition of
\sphinxcode{\sphinxupquote{area\_circle()}} to execute the function and calculate
the area:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{area\PYGZus{}circle}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A circle with radius 2 has area }\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{area\PYGZus{}circle}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{75.1}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{area\PYGZus{}circle}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A circle with radius }\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{ has area }\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Note that by using examples with small values for the radius we can
easily check that our function is correct.

\item {} 
Important syntax includes
\begin{itemize}
\item {} 
Use of the keyword \sphinxcode{\sphinxupquote{def}} and the \sphinxcode{\sphinxupquote{:}} to indicate the start of
the function

\item {} 
Indentation for the lines after the \sphinxcode{\sphinxupquote{def}} line

\item {} 
Unindented lines for code outside the function to indicate the end of the function.

\end{itemize}

\end{itemize}


\section{What does Python do when we run this code?}
\label{\detokenize{lecture_notes/lec05_functions2:what-does-python-do-when-we-run-this-code}}
We can visualize this using the website \sphinxcode{\sphinxupquote{http://www.pythontutor.com}}
\begin{enumerate}
\item {} 
Reads the keyword \sphinxcode{\sphinxupquote{def}} and notes that a function is being defined.
\begin{itemize}
\item {} 
The line that starts with \sphinxcode{\sphinxupquote{def}} is called the function \sphinxstyleemphasis{header}.

\end{itemize}

\item {} 
Reads the rest of the function definition, checking its syntax.

\item {} 
Notes the end of the definition when the unindented code is reached.

\item {} 
Sees the function call inside the assignment statement

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{area\PYGZus{}circle}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

at what’s known as the “top level” or “main level” of execution
and
\begin{itemize}
\item {} 
Jumps back up to the function

\item {} 
Assigns 1 to the parameter \sphinxcode{\sphinxupquote{radius}}.

\item {} 
Runs the code inside the function using \sphinxcode{\sphinxupquote{radius}} as a variable
inside the function.

\item {} 
Returns the result of the calculation back to the top level and
assigns the value 3.14159 to the variable \sphinxcode{\sphinxupquote{a}}.

\end{itemize}

\item {} 
Repeats the process of running the function at the second
\sphinxcode{\sphinxupquote{print()}}, this time with the parameter value 2 and therefore a
new value for \sphinxcode{\sphinxupquote{radius}} inside the function.

\item {} 
Repeats the process of running the function right after we reassign
\sphinxcode{\sphinxupquote{a}}, this time with parameter value 75.1 taken from the variable
\sphinxcode{\sphinxupquote{r}}.

\end{enumerate}


\section{Flow of Control}
\label{\detokenize{lecture_notes/lec05_functions2:flow-of-control}}\begin{itemize}
\item {} 
To re-iterate, the “flow of control” of Python here involves
\begin{itemize}
\item {} 
Reading the function definition without executing the function.

\item {} 
Seeing a “call” to the function, jumping up to the start of the
function and executing its code.

\item {} 
Returning the result of the function back to the place in the
program that called the function and continuing the execution.

\end{itemize}

\item {} 
Functions can compute many different things and return any data type
Python supports.

\end{itemize}


\section{Arguments, Parameters and Local Variables}
\label{\detokenize{lecture_notes/lec05_functions2:arguments-parameters-and-local-variables}}\begin{itemize}
\item {} 
\sphinxstyleemphasis{Arguments} are the values 1, 2 and 75.1 in our above examples.

\item {} 
These are each passed to the \sphinxstyleemphasis{parameter} called \sphinxcode{\sphinxupquote{radius}} named in
the function header. This parameter is used just like a variable in
the function.

\item {} 
The variable \sphinxcode{\sphinxupquote{pi}} and \sphinxcode{\sphinxupquote{area}} are \sphinxstyleemphasis{local variables} to the
function (though we should probably use the \sphinxcode{\sphinxupquote{math}} module for \sphinxcode{\sphinxupquote{pi}}
in the future).

\item {} 
Neither \sphinxcode{\sphinxupquote{pi}} nor \sphinxcode{\sphinxupquote{radius}} nor \sphinxcode{\sphinxupquote{area}} exists at the top / main
level. At this level, they are ‘’undefined variables’‘. Try it out.

\end{itemize}


\section{Exercise / Example}
\label{\detokenize{lecture_notes/lec05_functions2:exercise-example}}
As some basic practice, we’ll write a function to convert miles per
hour to kilometers per day, and then we’ll write several calls to
demonstrate its use.  Then we will give you time to work on the first
lecture exercise.


\section{A More Complicated Example}
\label{\detokenize{lecture_notes/lec05_functions2:a-more-complicated-example}}\begin{itemize}
\item {} 
We’ll use the example below to illustrate two important concepts:
\begin{enumerate}
\item {} 
Functions can call other functions, ones that we write ourselves
or that Python provides.

\item {} 
Functions may have multiple parameters.  One argument in the
function call is required for each parameter. Arguments and
parameters are matched up \sphinxstyleemphasis{in order}.
\begin{itemize}
\item {} 
There are ways to override this, but we will not study them
yet.

\end{itemize}

\end{enumerate}

\item {} 
In the example we will switch to the use of \sphinxcode{\sphinxupquote{math.pi}} and we will
use this from now on.

\end{itemize}


\section{Computing the Surface Area of A Cylinder Using Two Functions}
\label{\detokenize{lecture_notes/lec05_functions2:computing-the-surface-area-of-a-cylinder-using-two-functions}}\begin{itemize}
\item {} 
Here is the Python code, in file \sphinxcode{\sphinxupquote{lec05\_surface\_area.py}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{k}{def} \PYG{n+nf}{area\PYGZus{}circle}\PYG{p}{(}\PYG{n}{radius}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{radius} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{k}{def} \PYG{n+nf}{area\PYGZus{}cylinder}\PYG{p}{(}\PYG{n}{radius}\PYG{p}{,}\PYG{n}{height}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{circle\PYGZus{}area} \PYG{o}{=} \PYG{n}{area\PYGZus{}circle}\PYG{p}{(}\PYG{n}{radius}\PYG{p}{)}
    \PYG{n}{height\PYGZus{}area} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{radius} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{height}
    \PYG{k}{return} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{circle\PYGZus{}area} \PYG{o}{+} \PYG{n}{height\PYGZus{}area}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The area of a circle of radius 1 is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{area\PYGZus{}circle}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{height} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The surface area of a cylinder with radius}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{r}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{and height}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{height}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{area\PYGZus{}cylinder}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{height}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Now we’ve defined two functions, one of which calls the other.

\item {} 
Flow of control proceeds in two different ways here:
\begin{enumerate}
\item {} 
Starting at the first \sphinxcode{\sphinxupquote{print()}} function call at the top
level, into \sphinxcode{\sphinxupquote{area\_circle()}} and back.

\item {} 
At the third \sphinxcode{\sphinxupquote{print()}}
\begin{enumerate}
\item {} 
into \sphinxcode{\sphinxupquote{area\_cylinder()}}

\item {} 
into \sphinxcode{\sphinxupquote{area\_circle()}}

\item {} 
back to \sphinxcode{\sphinxupquote{area\_cylinder()}}, and

\item {} 
back to the top level (and then into \sphinxcode{\sphinxupquote{round()}} and
finally into \sphinxcode{\sphinxupquote{print()}}).

\end{enumerate}

\end{enumerate}

\item {} 
The Python interpreter keeps track of where it is working and where
to return to when it is done with a function, even if it is back into
another function.

\item {} 
What are the arguments, the parameters, the local variables and the
global variables?

\end{itemize}


\section{Practice Problems}
\label{\detokenize{lecture_notes/lec05_functions2:practice-problems}}\begin{enumerate}
\item {} 
Write a function that computes the area of a rectangle. Then, write
a second function that calls this function three times to
compute the surface area of a rectangular solid.

\item {} 
Write a function that returns the middle value among three
integers.  (Hint: make use of \sphinxcode{\sphinxupquote{min()}} and \sphinxcode{\sphinxupquote{max()}}).  Write
code to test this function with different inputs.

\end{enumerate}

You will notice that the solution to the first problem in particular
is longer than the solution without using functions.  While we don’t
often write such short functions in practice, here it is a good
illustration.


\section{More on program structure}
\label{\detokenize{lecture_notes/lec05_functions2:more-on-program-structure}}\begin{itemize}
\item {} 
Let us revisit the program structure that will allow us to write
readable programs.
\begin{itemize}
\item {} 
First a general comment describing the program.

\item {} 
Second, all import statements.

\item {} 
Third, all function definitions.

\item {} 
Fourth, the main body of your program.

\end{itemize}

\item {} 
Well structured programs are easy to read and debug. We will work
hard to help you develop good habits early on.

\end{itemize}


\section{Thinking About What You See}
\label{\detokenize{lecture_notes/lec05_functions2:thinking-about-what-you-see}}
Why is it NOT a mistake to use the same name, for example \sphinxcode{\sphinxupquote{radius}}, in
different functions (and sometimes at the top level)?


\section{Let’s Make Some Mistakes}
\label{\detokenize{lecture_notes/lec05_functions2:lets-make-some-mistakes}}
In order to check our understanding, we will play around with the code
and make some mistakes on purpose
\begin{itemize}
\item {} 
Removing \sphinxcode{\sphinxupquote{math}} from \sphinxcode{\sphinxupquote{math.pi}} in one definition

\item {} 
Changing the name of a function

\item {} 
Switching the order of the parameters in a function call

\item {} 
Making an error in our calculation

\item {} 
Calling \sphinxcode{\sphinxupquote{print()}} with the result of a function that does not
return a value

\end{itemize}


\section{A Final Example, Including Documentation}
\label{\detokenize{lecture_notes/lec05_functions2:a-final-example-including-documentation}}\begin{itemize}
\item {} 
We will write a function that linearly scales a test score, so that
if \sphinxcode{\sphinxupquote{raw}} is the “raw score” then the scaled score will be

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{scaled} \PYG{o}{=} \PYG{n}{a}\PYG{o}{*}\PYG{n}{raw} \PYG{o}{+} \PYG{n}{b}
\end{sphinxVerbatim}

The values of \sphinxcode{\sphinxupquote{raw}}, \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} will be parameters of the
function.  We will also want to cap the scaled score at 100.

\item {} 
In writing our function we will be careful to document the meaning of
the parameters and the assumptions.  You should get into the habit
of doing this.

\end{itemize}


\section{Why Functions?}
\label{\detokenize{lecture_notes/lec05_functions2:id1}}
Our goal in using functions is to write code that is
\begin{itemize}
\item {} 
Easier to think about and write

\item {} 
Easier to test: we can check the correctness of \sphinxcode{\sphinxupquote{area\_circle}}
before we test \sphinxcode{\sphinxupquote{area\_cylinder}}.

\item {} 
Clearer for someone else to read

\item {} 
Reusable in other programs

\end{itemize}

Together these define the notion of \sphinxstyleemphasis{encapsulation}, another important
idea in computer science!


\section{Summary}
\label{\detokenize{lecture_notes/lec05_functions2:summary}}\begin{itemize}
\item {} 
Functions for encapsulation and reuse

\item {} 
Function syntax

\item {} 
Arguments, parameters and local variables

\item {} 
Flow of control, including functions that call other functions

\item {} 
You can find the code developed in this class under the class
modules for Lecture 5.

\end{itemize}


\section{Additional Practice:}
\label{\detokenize{lecture_notes/lec05_functions2:additional-practice}}
The lecture exercises provide just the beginnings of what you need to
do to practice with the concepts and with writing short problems.
Here is some additional material for review before our next class.  It
goes all the way back to Lecture 2…
\begin{quote}
\begin{itemize}
\item {} 
\sphinxstylestrong{Expressions:} What type of data do they return?

\item {} 
Try typing simple math formulas to the Python interpreter like:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{/} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3} \PYG{o}{/} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\end{itemize}
\begin{quote}

and manually find the output. Don’t be fooled by the spaces!
Operator precedence is in effect. Try writing your own expressions.
\end{quote}
\begin{itemize}
\item {} 
\sphinxstylestrong{Variables:} Do you know what are valid and invalid variable names?

\item {} 
What is the difference in the output between:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{p}{)}     \PYG{c+c1}{\PYGZsh{} This causes an error...}
\end{sphinxVerbatim}

Try to guess before typing them in, but make a habit of typing simple
statements like this and looking at the result.

\item {} 
\sphinxstylestrong{Assignment:} Can you trace the value of a variable after many
different assignments? Don’t be fooled by the name of variables.
Try to do it manually:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{one} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{two} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{three} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{one} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{two}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{two} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{one} \PYG{o}{+} \PYG{n}{three}
\end{sphinxVerbatim}

By the way, make a habit of picking nice variable names.  Your
variables should be meaningful whenever possible both to you and to
anyone else reading your code.

\item {} 
\sphinxstylestrong{Functions:} Write the functions from class on your own using
the Python interpreter. Try to do it without looking at
notes. Can you do it?
\begin{itemize}
\item {} 
Write a function that returns a value.

\item {} 
Write a function with no return.

\item {} 
Write a function where \sphinxcode{\sphinxupquote{return}} is not the last statement in the
function.

\item {} 
Call these functions by either printing their result or assigning
their results to a value. Here, I’ll get you started.

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{regenerate\PYGZus{}doctor}\PYG{p}{(}\PYG{n}{doctor\PYGZus{}number}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{doctor\PYGZus{}number}\PYG{o}{+}\PYG{l+m+mi}{1}

\PYG{k}{def} \PYG{n+nf}{regenerate\PYGZus{}tardis}\PYG{p}{(}\PYG{n}{doctor\PYGZus{}number}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Tardis is now ready for doctor number}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{doctor\PYGZus{}number}

\PYG{k}{def} \PYG{n+nf}{eliminate\PYGZus{}doctor}\PYG{p}{(}\PYG{n}{doctor\PYGZus{}number}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{0}
    \PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{You will be eliminated doctor}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{doctor\PYGZus{}number}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Write functions that use the built-in functions. Make sure you
memorize what they are and how they are used.

\end{itemize}

\end{itemize}
\end{quote}
\begin{itemize}
\item {} 
Finally, write some functions to a file and call them from within
the file. Now, execute the file. By next class, make sure all of this
is quite easy to do without consulting the course notes.

\end{itemize}


\chapter{Lecture 5 — Exercises}
\label{\detokenize{lecture_notes/lec05_functions2_exercises/exercises:lecture-5-exercises}}\label{\detokenize{lecture_notes/lec05_functions2_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for grading.
A separate file must submitted for each problem.  These must be
submitted by 4 pm on Friday, February 2.
\begin{enumerate}
\item {} 
Write a function called \sphinxcode{\sphinxupquote{convert2fahren}} that takes a Celsius
temperature and converts it to Fahrenheit, returning the answer.
Write code that calls the function three times to convert
temperatures 0, 32, and 100 to Fahrenheit, printing the result each
time.  To keep things simple for these exercises, the output should
be

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{32.0}
\PYG{l+m+mi}{32} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{89.6}
\PYG{l+m+mi}{100} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{212.0}
\end{sphinxVerbatim}

Submitty will check that a function exists with exactly the given
name, that it does the calculation, and that it is called three
times.

\item {} 
Write a function called \sphinxcode{\sphinxupquote{frame\_string}} that takes a string as an
argument.  Its job is to print that string with a frame around it,
just like in Lab 2.  Unlike the other functions we have written
\sphinxcode{\sphinxupquote{frame\_string}} does not need and therefore should not have a
\sphinxcode{\sphinxupquote{return}} statement.  Write code to call the function two times.
For the first call pass the string \sphinxcode{\sphinxupquote{Spanish Inquisition}}.  For the
second call, pass the string \sphinxcode{\sphinxupquote{Ni}}.  Print a blank line between
calls.  The output should be

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
\PYG{o}{*}\PYG{o}{*} \PYG{n}{Spanish} \PYG{n}{Inquisition} \PYG{o}{*}\PYG{o}{*}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}

\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
\PYG{o}{*}\PYG{o}{*} \PYG{n}{Ni} \PYG{o}{*}\PYG{o}{*}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
\end{sphinxVerbatim}

In addition to checking the output, we will check that you wrote
a function called \sphinxcode{\sphinxupquote{frame\_string}} and that your code calls this
function twice.

\end{enumerate}

For extra practice, but not to be uploaded to Submitty, solve the
following:
\begin{enumerate}
\item {} 
Add code to your first function that has a second parameter which
is the minimum temperature in Fahrenheit.  If the converted
temperature is less than this, use this minimum value.  Write code
to run this modified function using the value 459.67 and test that
it works correctly.

\item {} 
Add code to the second program you wrote to print out the
result of the calls to \sphinxcode{\sphinxupquote{frame\_string}}.  The output should be the value
\sphinxcode{\sphinxupquote{None}}.  This is a special Python value that indicates “there is
no value”.  The most common example of using \sphinxcode{\sphinxupquote{None}} is the
result of a function that has no \sphinxcode{\sphinxupquote{return}} statement.

\end{enumerate}


\chapter{Lecture 6 — Decisions}
\label{\detokenize{lecture_notes/lec06_conditionals1:lecture-6-decisions}}\label{\detokenize{lecture_notes/lec06_conditionals1::doc}}

\section{Initial Example:}
\label{\detokenize{lecture_notes/lec06_conditionals1:initial-example}}\begin{itemize}
\item {} 
Suppose we have a height measurements for two people, Chris and
Sandy.  We have the tools to write a program that determines which
height measurement is greater:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chris\PYGZus{}height} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter Chris}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s height (in cm): }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sandy\PYGZus{}height} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter Sandy}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s height (in cm): }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The greater height is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{chris\PYGZus{}height}\PYG{p}{,}\PYG{n}{sandy\PYGZus{}height}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
But, we don’t have the tools yet to \sphinxstyleemphasis{decide} who has the greater
height.  For this we need \sphinxstyleemphasis{if statements}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chris\PYGZus{}height} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter Chris}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s height (in cm): }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sandy\PYGZus{}height} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter Sandy}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s height (in cm): }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{chris\PYGZus{}height} \PYG{o}{\PYGZgt{}} \PYG{n}{sandy\PYGZus{}height}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chris is taller}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sandy is taller}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
This is the first of many lectures exploring logic, if statements,
and decision making.

\end{itemize}


\section{Overview — Logic and Decision Making}
\label{\detokenize{lecture_notes/lec06_conditionals1:overview-logic-and-decision-making}}\begin{itemize}
\item {} 
Boolean logic

\item {} 
Use in decision making

\item {} 
Use in branching and alternatives

\end{itemize}

Reading: Chapter 5 of \sphinxstyleemphasis{Practical Programming}. We will not cover all
of this today, and will return
to the rest of this chapter later in the semester.


\section{Part 1: Boolean Values}
\label{\detokenize{lecture_notes/lec06_conditionals1:part-1-boolean-values}}\begin{itemize}
\item {} 
Yet another type

\item {} 
Values are only \sphinxcode{\sphinxupquote{True}} and \sphinxcode{\sphinxupquote{False}}

\item {} 
We’ll see a series of operations that either produce or use
boolean values, including relational operators such as \sphinxcode{\sphinxupquote{\textless{}}}, \sphinxcode{\sphinxupquote{\textless{}=}},
etc. and logical operations such as \sphinxcode{\sphinxupquote{and}} and \sphinxcode{\sphinxupquote{or}}.

\item {} 
We can assign them to variables, as in,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{k+kc}{True}
\end{sphinxVerbatim}

although we will not explore this much during the current lecture.

\end{itemize}


\section{Relational Operators — Less Than and Greater Than}
\label{\detokenize{lecture_notes/lec06_conditionals1:relational-operators-less-than-and-greater-than}}\begin{itemize}
\item {} 
Comparisons between values, perhaps values associated with variables,
to produce a boolean outcome.

\item {} 
For numerical values, \sphinxcode{\sphinxupquote{\textless{}}}, \sphinxcode{\sphinxupquote{\textless{}=}}, \sphinxcode{\sphinxupquote{\textgreater{}}}, \sphinxcode{\sphinxupquote{\textgreater{}=}} are
straightforward:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{17}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mf}{15.1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{n}{y}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{y}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{17}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{n}{x}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\item {} 
The comparison operators \sphinxcode{\sphinxupquote{\textless{}}}, \sphinxcode{\sphinxupquote{\textless{}=}}, \sphinxcode{\sphinxupquote{\textgreater{}}},
\sphinxcode{\sphinxupquote{\textgreater{}=}} may also be used for strings but the results are sometimes a
bit surprising:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{art}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Art}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s3} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Music}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s4} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{music}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{\PYGZlt{}} \PYG{n}{s2}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{\PYGZlt{}} \PYG{n}{s3}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{\PYGZlt{}} \PYG{n}{s4}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{\PYGZlt{}} \PYG{n}{s3}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\item {} 
With strings, the ordering is what’s called \sphinxstyleemphasis{lexicographic} rather
than purely alphabetical order:
\begin{itemize}
\item {} 
All capital letters come before small letters, so strict
alphabetical ordering can only be ensured when there is no
mixing of caps and smalls.

\end{itemize}

\end{itemize}


\section{Relational Operators: Equality and Inequality}
\label{\detokenize{lecture_notes/lec06_conditionals1:relational-operators-equality-and-inequality}}\begin{itemize}
\item {} 
Testing if two values are equal uses the combined, double-equal
symbol \sphinxcode{\sphinxupquote{==}} rather than the single \sphinxcode{\sphinxupquote{=}}, which is reserved for
assignment.
\begin{itemize}
\item {} 
Getting accustomed to this convention requires practice, and it
is a common source of mistakes

\end{itemize}

\item {} 
Inequality is indicated by \sphinxcode{\sphinxupquote{!=}}.

\item {} 
We will play with a few examples in class.

\end{itemize}


\section{Part 1 Exercises}
\label{\detokenize{lecture_notes/lec06_conditionals1:part-1-exercises}}
We will stop here and give students a chance to work on the first
lecture exercise.


\section{Part 2: if Statements}
\label{\detokenize{lecture_notes/lec06_conditionals1:part-2-if-statements}}\begin{itemize}
\item {} 
General form of what we saw in the example we explored at the start
of lecture:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{condition}\PYG{p}{:}
   \PYG{n}{block1}
\PYG{k}{else}\PYG{p}{:}
   \PYG{n}{block2}
\end{sphinxVerbatim}

where
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{condition}} is the result of a logical expression, such as the
result of computing the value of a relational operation

\item {} 
\sphinxcode{\sphinxupquote{block1}} is Python code executed when the condition is \sphinxcode{\sphinxupquote{True}}

\item {} 
\sphinxcode{\sphinxupquote{block2}} is Python code executed when the condition is
\sphinxcode{\sphinxupquote{False}}

\end{itemize}

\item {} 
All statements in the \sphinxcode{\sphinxupquote{block1}} and \sphinxcode{\sphinxupquote{block2}} must be indented the
same number of spaces

\item {} 
The \sphinxcode{\sphinxupquote{block}} continues until the indentation stops, and returns to
the same level of indentation as the statement starting with \sphinxcode{\sphinxupquote{if}}

\item {} 
The \sphinxcode{\sphinxupquote{else:}} and \sphinxcode{\sphinxupquote{block2}} are optional, as the following example
shows.

\end{itemize}


\section{Example: Heights of Siblings}
\label{\detokenize{lecture_notes/lec06_conditionals1:example-heights-of-siblings}}\begin{itemize}
\item {} 
Here is a more extensive version of our initial example, implemented
using two consecutive \sphinxcode{\sphinxupquote{if}} statements and not using an \sphinxcode{\sphinxupquote{else}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Dale}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter the height of}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{name1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{in cm ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{height1} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{name2} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Erin}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter the height of}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{name2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{in cm ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{height2} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{height1} \PYG{o}{\PYGZlt{}} \PYG{n}{height2}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{name2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{is taller}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{max\PYGZus{}height} \PYG{o}{=} \PYG{n}{height2}

\PYG{k}{if} \PYG{n}{height1} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{height2}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{name1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{is taller}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{max\PYGZus{}height} \PYG{o}{=} \PYG{n}{height1}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The max height is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{max\PYGZus{}height}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Writing two separate \sphinxcode{\sphinxupquote{if}} statements like this, while good as an
illustration, is not a good idea in practice.  We need to read the
code to understand that the two \sphinxcode{\sphinxupquote{if}} statements produce mutually
exclusive results.  Instead we should use \sphinxcode{\sphinxupquote{else}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name1} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Dale}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{height1} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter the height of }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{name1} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ in cm ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{name2} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Erin}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{height2} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter the height of }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{name2} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ in cm ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{height1} \PYG{o}{\PYGZlt{}} \PYG{n}{height2}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{name2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{is taller}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{max\PYGZus{}height} \PYG{o}{=} \PYG{n}{height2}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{name1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{is taller}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{max\PYGZus{}height} \PYG{o}{=} \PYG{n}{height1}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The max height is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{max\PYGZus{}height}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Notes:
\begin{itemize}
\item {} 
The blank lines are added for clarity; they are not required
for these programs to have correct syntax.

\item {} 
Neither program handles the case of Dale and Erin being the same
height. For this we need the next Python construct.

\end{itemize}

\end{itemize}


\section{Elif}
\label{\detokenize{lecture_notes/lec06_conditionals1:elif}}
Recall the kids guessing game where someone thinks of a number and you
have to guess it. The only information you are given is that the person
who knows the number tells you if your guess is too high, too low, or if
you got it correct.
\begin{itemize}
\item {} 
When we have three or more alternatives to consider we use the
if-elif-else structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{condition1}\PYG{p}{:}
    \PYG{n}{block1}
\PYG{k}{elif} \PYG{n}{condition2}\PYG{p}{:}
    \PYG{n}{block2}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{block3}
\end{sphinxVerbatim}

\item {} 
We’ll rewrite the height example to use \sphinxcode{\sphinxupquote{elif}} to handle the case of Dale
and Erin having the same height.

\item {} 
Notes:
\begin{itemize}
\item {} 
You do \sphinxstylestrong{NOT} need to have an \sphinxcode{\sphinxupquote{else}} block.

\item {} 
Exactly \sphinxstylestrong{one} block of code (block1, block2, block3) is
executed!  Don’t forget this!

\item {} 
If we leave off the \sphinxcode{\sphinxupquote{else:}} and block3, then it is possible that
none of the blocks are executed.

\item {} 
You can use multiple \sphinxcode{\sphinxupquote{elif}} conditions and blocks.

\end{itemize}

\end{itemize}


\section{Part 3: More Complex Boolean Expressions, Starting with and}
\label{\detokenize{lecture_notes/lec06_conditionals1:part-3-more-complex-boolean-expressions-starting-with-and}}
Consider the following piece of Python code that outputs a message if
it was above freezing both yesterday and today
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cel\PYGZus{}today} \PYG{o}{=} \PYG{l+m+mi}{12}
\PYG{n}{cel\PYGZus{}yesterday} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{k}{if} \PYG{n}{cel\PYGZus{}today} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{cel\PYGZus{}yesterday} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{It was above freezing both yesterday and today.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
A boolean expression involving \sphinxcode{\sphinxupquote{and}} is \sphinxcode{\sphinxupquote{True}} if and only if
\sphinxstylestrong{both} the relational operations produce the value \sphinxcode{\sphinxupquote{True}}

\end{itemize}


\section{More Complex Boolean Expressions — or}
\label{\detokenize{lecture_notes/lec06_conditionals1:more-complex-boolean-expressions-or}}
Consider the following:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cel\PYGZus{}today} \PYG{o}{=} \PYG{l+m+mi}{12}
\PYG{n}{cel\PYGZus{}yesterday} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{k}{if} \PYG{n}{cel\PYGZus{}today} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o+ow}{or} \PYG{n}{cel\PYGZus{}yesterday} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{It has been above freezing in the last two days.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
The boolean expression is \sphinxcode{\sphinxupquote{True}} if ANY of the following occurs
\begin{itemize}
\item {} 
the left relational expression is \sphinxcode{\sphinxupquote{True}},

\item {} 
the right relational expression is \sphinxcode{\sphinxupquote{True}},

\item {} 
\sphinxstylestrong{both} the left and right relational expression are \sphinxcode{\sphinxupquote{True}}.

\end{itemize}

\item {} 
This is called the \sphinxstyleemphasis{inclusive or} and it is somewhat different from
common use of the word \sphinxstyleemphasis{or} in English.

\item {} 
For examples, in the sentence
\begin{quote}

You may order the pancakes or the omelet.
\end{quote}

usually means you may choose pancakes, or you may choose an omelet,
but you may not choose both (unless you pay extra).
\begin{itemize}
\item {} 
This is called the \sphinxstyleemphasis{exclusive-or}; it is only used in logic and
computer science in very special cases.

\item {} 
Hence, \sphinxcode{\sphinxupquote{or}} always means \sphinxstyleemphasis{inclusive-or}.

\end{itemize}

\end{itemize}


\section{Boolean Logic — not}
\label{\detokenize{lecture_notes/lec06_conditionals1:boolean-logic-not}}\begin{itemize}
\item {} 
We can also “logically negate” a boolean expression using \sphinxcode{\sphinxupquote{not}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{15}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{n}{b}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a is not less than b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a is less than b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Final Example - Is a Point Inside a Rectangle}
\label{\detokenize{lecture_notes/lec06_conditionals1:final-example-is-a-point-inside-a-rectangle}}
We’ll gather all of ideas from class to solve the following example:
Suppose the bounds of a rectangle are defined by
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{x1} \PYG{o}{=} \PYG{l+m+mi}{16}
\PYG{n}{y0} \PYG{o}{=} \PYG{l+m+mi}{32}
\PYG{n}{y1} \PYG{o}{=} \PYG{l+m+mi}{45}
\end{sphinxVerbatim}
\end{quote}

A point at location \(x,y\) is inside the rectangle if
\begin{quote}
\begin{equation*}
\begin{split}x0 < x < x1 \qquad \text{and} \qquad y0 < y < y1.\end{split}
\end{equation*}\end{quote}

Under what conditions are we outside of the rectangle? Under what
conditions are on the boundary?

We will write a program that reads in an x, y coordinate of a point
and outputs a message depending on whether the point is inside the
rectangle, outside the rectangle, or on the boundary.  The final code
will be posted on the course website.


\section{Summary and Looking Ahead}
\label{\detokenize{lecture_notes/lec06_conditionals1:summary-and-looking-ahead}}\begin{itemize}
\item {} 
if-else and if-elif-else are tools for making decisions and creating
alternative computations and results

\item {} 
The conditional tests involve relationship operators and logical
operators
\begin{itemize}
\item {} 
Be careful of the distinction between \sphinxcode{\sphinxupquote{=}} and \sphinxcode{\sphinxupquote{==}}

\end{itemize}

\item {} 
In Lecture 11 we will review boolean logic and discuss more complex if
structures.

\end{itemize}


\chapter{Lecture 6 — Exercises}
\label{\detokenize{lecture_notes/lec06_conditionals1_exercises/exercises:lecture-6-exercises}}\label{\detokenize{lecture_notes/lec06_conditionals1_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for grading.
A separate file must submitted for each problem.  These must be
submitted by 4 pm on Tuesday, February 6th.
\begin{enumerate}
\item {} 
Consider the following boolean expressions:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.6}
\PYG{n}{b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.7}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{15}
\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hi}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{t} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{good}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{u} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bye}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{v} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GOOD}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{w} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bye}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mf}{15.1}

\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b}             \PYG{c+c1}{\PYGZsh{} A}
\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}        \PYG{c+c1}{\PYGZsh{} B}
\PYG{n}{a} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{c}            \PYG{c+c1}{\PYGZsh{} C}
\PYG{n}{s} \PYG{o}{\PYGZlt{}} \PYG{n}{t}             \PYG{c+c1}{\PYGZsh{} D}
\PYG{n}{t} \PYG{o}{==} \PYG{n}{v}            \PYG{c+c1}{\PYGZsh{} E}
\PYG{n}{u} \PYG{o}{==} \PYG{n}{w}            \PYG{c+c1}{\PYGZsh{} F}
\PYG{n}{b} \PYG{o}{\PYGZlt{}} \PYG{n}{y}             \PYG{c+c1}{\PYGZsh{} G}
\end{sphinxVerbatim}

Upload a text file to Submitty containing only the labels (A, B, C,
etc.) of the lines that evaluate to \sphinxcode{\sphinxupquote{True}}.  Each line of the
uploaded file should contain a single capital letter and the
letters should be in alphabetical order.

\item {} 
Consider the following boolean expressions:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{15}
\PYG{n}{y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}
\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mi}{32}
\PYG{n}{x} \PYG{o}{==} \PYG{n}{y} \PYG{o+ow}{and} \PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{n}{z}        \PYG{c+c1}{\PYGZsh{}A}
\PYG{n}{x} \PYG{o}{==} \PYG{n}{y} \PYG{o+ow}{or} \PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{n}{z}         \PYG{c+c1}{\PYGZsh{}B}
\PYG{n}{x} \PYG{o}{==} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{n}{z}   \PYG{c+c1}{\PYGZsh{}C}
\PYG{n}{x} \PYG{o}{==} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)} \PYG{o+ow}{or} \PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{n}{z}    \PYG{c+c1}{\PYGZsh{}D}
\PYG{o+ow}{not} \PYG{n}{x} \PYG{o}{==} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}         \PYG{c+c1}{\PYGZsh{}E}
\PYG{o+ow}{not} \PYG{n}{x} \PYG{o}{!=} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}         \PYG{c+c1}{\PYGZsh{}F}
\end{sphinxVerbatim}

Upload a text file to Submitty containing only the labels (A, B, C,
etc.) of the lines that evaluate to \sphinxcode{\sphinxupquote{True}}.  Each line of the
file should contain a single capital letter and the letters should
be in alphabetical order.

\item {} 
So far we have assumed all input to our programs is correct.  In
practice, however, programs must do extensive error checking.  Here
is a slightly-contrived problem to illustrate this: Write a short
program that asks the user to input two numbers where one of them
must be greater than 10 and the other must be less than or equal
to 10.  It does not matter which is which.  If both inputs are
greater than 10, the program should output the error message “Both
are above 10.”  If both are less than or equal 10, the program
should output the message “Both are below 10.”  If the one of the
numbers is above 10 and the other is less than or equal to 10, no message
should be output.  Regardless of any messages, the program should then
output the average of
the two numbers, accurate to 2 decimals.  This program must use one
\sphinxcode{\sphinxupquote{if}}, one \sphinxcode{\sphinxupquote{elif}} and \sphinxstylestrong{no} \sphinxcode{\sphinxupquote{else}}.  Note: just like in HW 1, the
program should output a value immediately after reading it. Also, if you
are having problems matching our output format, explore the difference
between the output of the following two lines

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+m+mf}{112.099}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{l+m+mf}{112.099}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Here are two examples of how your program might look when run from
the interpreter:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Enter} \PYG{n}{the} \PYG{n}{first} \PYG{n}{number}\PYG{p}{:} \PYG{l+m+mf}{17.1}
\PYG{l+m+mf}{17.1}
\PYG{n}{Enter} \PYG{n}{the} \PYG{n}{second} \PYG{n}{number}\PYG{p}{:} \PYG{l+m+mf}{13.45}
\PYG{l+m+mf}{13.45}
\PYG{n}{Both} \PYG{n}{are} \PYG{n}{above} \PYG{l+m+mf}{10.}
\PYG{n}{Average} \PYG{o+ow}{is} \PYG{l+m+mf}{15.28}
\end{sphinxVerbatim}

and

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Enter} \PYG{n}{the} \PYG{n}{first} \PYG{n}{number}\PYG{p}{:} \PYG{l+m+mf}{4.7}
\PYG{l+m+mf}{4.7}
\PYG{n}{Enter} \PYG{n}{the} \PYG{n}{second} \PYG{n}{number}\PYG{p}{:} \PYG{l+m+mf}{15.5}
\PYG{l+m+mf}{15.5}
\PYG{n}{Average} \PYG{o+ow}{is} \PYG{l+m+mf}{10.1}
\end{sphinxVerbatim}

\end{enumerate}


\chapter{Lecture 7 — Tuples, Modules, Images}
\label{\detokenize{lecture_notes/lec07_modules_images:lecture-7-tuples-modules-images}}\label{\detokenize{lecture_notes/lec07_modules_images::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec07_modules_images:overview}}\begin{itemize}
\item {} 
While most of this lecture is not covered in our text book, this
lecture serves as an introduction to using more complex data types
like lists.

\item {} 
We will first learn a simple data type called tuples which allow
us to work with multiple values together - including returning two
or more values from a function.

\item {} 
We will then revisit modules, how functions you write can be used
in other programs.

\item {} 
Most of the class we will be learning how to use a new module for
manipulating images.
\begin{itemize}
\item {} 
We will introduce a new data type - an image - which is much more
complex than the other data types we have learned so far.

\item {} 
We will study a module called \sphinxstyleemphasis{pillow} which is specifically
designed for this data type.

\end{itemize}

\item {} 
Class will end with a \sphinxstyleemphasis{review} for Monday’s Exam 1, so it will be a
bit long…

\end{itemize}


\section{Tuple Data Type}
\label{\detokenize{lecture_notes/lec07_modules_images:tuple-data-type}}\begin{itemize}
\item {} 
A \sphinxstyleemphasis{tuple} is a simple data type that puts together multiple values
as a single unit.

\item {} 
A Tuple allows you to access individual elements:
first value starts at zero (this “indexing” will turn into a big
Computer Science thing!)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} note the parentheses}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{10}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{3}
\end{sphinxVerbatim}

\item {} 
As we will explore in class tuples and strings are similar in many
ways.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}a\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}b\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
Just like strings, you cannot change a part of the tuple; you can
only change the entire tuple!

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{}\PYGZgt{} x[1] = 2
Traceback (most recent call last):
File \PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}, line 1, in \PYGZlt{}module\PYGZgt{}
TypeError: \PYGZsq{}tuple\PYGZsq{} object does not support item assignment
\PYGZgt{}\PYGZgt{}\PYGZgt{} s[1] = \PYGZsq{}A\PYGZsq{}
Traceback (most recent call last):
File \PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}, line 1, in \PYGZlt{}module\PYGZgt{}
TypeError: \PYGZsq{}str\PYGZsq{} object does not support item assignment
\end{sphinxVerbatim}

\end{itemize}


\section{What are tuples good for?}
\label{\detokenize{lecture_notes/lec07_modules_images:what-are-tuples-good-for}}\begin{itemize}
\item {} 
Tuples are Python’s way of making multiple assignments.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}
\PYG{g+go}{(2, 3)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}
\PYG{g+go}{(2, 3)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{o}{=}\PYG{n}{x}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}
\PYG{g+go}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}\PYG{p}{,}\PYG{n}{d}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}
\PYG{g+go}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d}
\PYG{g+go}{4}
\end{sphinxVerbatim}

\item {} 
You can write functions that return multiple values.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{split}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Split a two\PYGZhy{}digit number into its tens and ones digit \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n}{tens} \PYG{o}{=} \PYG{n}{n} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{10}
    \PYG{n}{ones} \PYG{o}{=} \PYG{n}{n} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{10}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{tens}\PYG{p}{,} \PYG{n}{ones}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{83}
\PYG{n}{ten}\PYG{p}{,}\PYG{n}{one} \PYG{o}{=} \PYG{n}{split}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{n}{x}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{has tens digit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ten}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{and ones digit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{one} \PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}

outputs
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{83} \PYG{n}{has} \PYG{n}{tens} \PYG{n}{digit} \PYG{l+m+mi}{8} \PYG{o+ow}{and} \PYG{n}{ones} \PYG{n}{digit} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
We can do the reverse, passing a tuple to a function.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{combine}\PYG{p}{(} \PYG{n}{digits} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{digits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{100} \PYG{o}{+} \PYG{n}{digits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{10} \PYG{o}{+} \PYG{n}{digits}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}

\PYG{n}{d} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{n}{combine}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}

outputs
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{527}
\end{sphinxVerbatim}
\end{quote}


\section{First Lecture Exercise}
\label{\detokenize{lecture_notes/lec07_modules_images:first-lecture-exercise}}
We will take five minutes and work on the (only) two lecture exercises.


\section{Basics of modules}
\label{\detokenize{lecture_notes/lec07_modules_images:basics-of-modules}}\begin{itemize}
\item {} 
Recall that a module is a collection of Python variables, functions
and objects, all stored in a file.

\item {} 
Modules allow code to be shared across many different programs.

\item {} 
Before we can use a module, we need to import it.  The import of a
module and use of functions within the module have the follow
general form.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{module\PYGZus{}name}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{module\PYGZus{}name}\PYG{o}{.}\PYG{n}{function}\PYG{p}{(}\PYG{n}{arguments}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Area and Volume Module}
\label{\detokenize{lecture_notes/lec07_modules_images:area-and-volume-module}}\begin{itemize}
\item {} 
Here are a number of functions from the area calculations we’ve been
developing so far, gathered in a single Python file called \sphinxcode{\sphinxupquote{lec08\_area.py}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{k}{def} \PYG{n+nf}{circle}\PYG{p}{(}\PYG{n}{radius}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Compute and return the area of a circle \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{return} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{radius}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}

\PYG{k}{def} \PYG{n+nf}{cylinder}\PYG{p}{(}\PYG{n}{radius}\PYG{p}{,}\PYG{n}{height}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Compute and return the surface area of a cylinder \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n}{circle\PYGZus{}area} \PYG{o}{=} \PYG{n}{circle}\PYG{p}{(}\PYG{n}{radius}\PYG{p}{)}
    \PYG{n}{height\PYGZus{}area} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{radius} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{height}
    \PYG{k}{return} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{circle\PYGZus{}area} \PYG{o}{+} \PYG{n}{height\PYGZus{}area}

\PYG{k}{def} \PYG{n+nf}{sphere}\PYG{p}{(}\PYG{n}{radius}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}  Compute and return the surface area of a sphere \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{return} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{radius}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\item {} 
Now we can write another program that imports this code and uses
it:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{lec08\PYGZus{}area}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{a1} \PYG{o}{=} \PYG{n}{lec08\PYGZus{}area}\PYG{o}{.}\PYG{n}{circle}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}       \PYG{c+c1}{\PYGZsh{}  Call a module function}
\PYG{n}{a2} \PYG{o}{=} \PYG{n}{lec08\PYGZus{}area}\PYG{o}{.}\PYG{n}{cylinder}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{}  Call a module function}
\PYG{n}{a3} \PYG{o}{=} \PYG{n}{lec08\PYGZus{}area}\PYG{o}{.}\PYG{n}{sphere}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}       \PYG{c+c1}{\PYGZsh{}  Call a module function}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Area circle }\PYG{l+s+si}{\PYGZob{}:.1f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Surface area cylinder }\PYG{l+s+si}{\PYGZob{}:.1f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Surface area sphere }\PYG{l+s+si}{\PYGZob{}:.1f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We will review this in class.

\end{itemize}


\section{PIL/PILLOW — Python Image Library}
\label{\detokenize{lecture_notes/lec07_modules_images:pil-pillow-python-image-library}}\begin{itemize}
\item {} 
PILLOW is a series of modules built around the \sphinxcode{\sphinxupquote{Image}} type, our first
object type that is not part of the main Python language
\begin{itemize}
\item {} 
We have to tell Python about this type through \sphinxcode{\sphinxupquote{import}}

\end{itemize}

\item {} 
We will use images as a continuing example of what can be done in
programming beyond numbers and beyond text.

\item {} 
See

\sphinxurl{http://pillow.readthedocs.org/en/latest/handbook/tutorial.html}

for more details.

\end{itemize}


\section{Images}
\label{\detokenize{lecture_notes/lec07_modules_images:images}}\begin{itemize}
\item {} 
An image is a two-dimensional matrix of pixel values

\item {} 
The origin is in the upper left corner, see below:

\noindent\sphinxincludegraphics{{image_premier}.png}

\item {} 
Pixel values stored in an image can be:
\begin{itemize}
\item {} 
RGB — a “three-tuple” consisting of the red, green and blue
values, all non-negative integers

\item {} 
L — a single “gray-scale” integer value representing the
brightness of each pixel

\end{itemize}

\item {} 
Some basic colors:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Color
&\sphinxstyletheadfamily 
(red,green,blue) value
\\
\hline
Black
&
(0,0,0)
\\
\hline
Red
&
(255,0,0)
\\
\hline
Green
&
(0,255,0)
\\
\hline
Blue
&
(0,0,255)
\\
\hline
White
&
(255,255,255)
\\
\hline
Light Gray
&
(122,122,122)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\end{itemize}


\section{Some important image modules}
\label{\detokenize{lecture_notes/lec07_modules_images:some-important-image-modules}}\begin{itemize}
\item {} 
\sphinxstylestrong{Image} module contains main functions to manipulate images: open,
save, resize, crop, paste, create new images, change pixels, etc.

\item {} 
\sphinxstylestrong{ImageDraw} module contains functions to touch up images by adding
text to it, draw ellipses, rectangles, etc.

\item {} 
\sphinxstylestrong{ImageFont} contains functions to create images of text for a
specific font.

\item {} 
We will only use the Image module in this lecture.

\end{itemize}


\section{Our First Image Program}
\label{\detokenize{lecture_notes/lec07_modules_images:our-first-image-program}}\begin{itemize}
\item {} 
We’ll start by working through the following example which you can
save as \sphinxcode{\sphinxupquote{lec08\_images\_init.py}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k}{import} \PYG{n}{Image}

\PYG{n}{filename} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{chipmunk.jpg}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{im} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{********************}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Here}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s the information about}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{im}\PYG{o}{.}\PYG{n}{format}\PYG{p}{,} \PYG{n}{im}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{n}{im}\PYG{o}{.}\PYG{n}{mode}\PYG{p}{)}

\PYG{n}{gray\PYGZus{}im} \PYG{o}{=} \PYG{n}{im}\PYG{o}{.}\PYG{n}{convert}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{scaled} \PYG{o}{=} \PYG{n}{gray\PYGZus{}im}\PYG{o}{.}\PYG{n}{resize}\PYG{p}{(} \PYG{p}{(}\PYG{l+m+mi}{128}\PYG{p}{,}\PYG{l+m+mi}{128}\PYG{p}{)} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{After converting to gray scale and resizing,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{the image information has changed to}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{scaled}\PYG{o}{.}\PYG{n}{format}\PYG{p}{,} \PYG{n}{scaled}\PYG{o}{.}\PYG{n}{size}\PYG{p}{,} \PYG{n}{scaled}\PYG{o}{.}\PYG{n}{mode}\PYG{p}{)}

\PYG{n}{scaled}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{scaled}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{filename} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}scaled.jpg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Image Type and Methods}
\label{\detokenize{lecture_notes/lec07_modules_images:image-type-and-methods}}\begin{itemize}
\item {} 
Let us now see some very useful image methods. You need to be very
careful with the image functions.
\begin{itemize}
\item {} 
Some functions do change the
image and return nothing.

\item {} 
Some functions do not change the image and return a value, which
is sometimes a new image.

\end{itemize}

It is crucial that you use each function correctly.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{im = Image.open(filename)}} reads an image with the given filename}] \leavevmode
and returns an image object (which we are associating with the variable
\sphinxcode{\sphinxupquote{im}}).
\begin{itemize}
\item {} 
Because we only give the file name, and not a more complete
path, the Python script and the image must be stored in the
same folder.

\end{itemize}

\end{description}

\item {} 
Images are complex objects. They have associated properties
that you can print or use.  For example

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{swarm.jpg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{size}
\PYG{g+go}{(600, 800)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{format}
\PYG{g+go}{\PYGZsq{}JPEG\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{mode}
\PYG{g+go}{\PYGZsq{}RGB\PYGZsq{}}
\end{sphinxVerbatim}

You can see that \sphinxcode{\sphinxupquote{im.format}} and \sphinxcode{\sphinxupquote{im.mode}} are strings, while
\sphinxcode{\sphinxupquote{im.size}} is a tuple. All of these are values associated with an
image object.

\item {} 
\sphinxcode{\sphinxupquote{im.show()}} is a function that displays the image.

\item {} 
\sphinxcode{\sphinxupquote{im.save(filename)}} saves the image in the given file name

\item {} 
You can create an empty new image with given dimensions using:
\sphinxcode{\sphinxupquote{Image.new("RGB",(width,height))}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im5} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{new}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RGB}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im5}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
You can also create a new image by cropping a part of a given
image:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{crop}\PYG{p}{(}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,}\PYG{n}{h1}\PYG{p}{,}\PYG{n}{w2}\PYG{p}{,}\PYG{n}{h2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

which will crop a box from upper left corner (w1, h1) to lower
right corner (w2,h2).

You can see that the box is entered as a tuple.

The image object \sphinxcode{\sphinxupquote{im}} is not changed by this function, but a
new image is returned. So, we must assign it to a new variable.

Try this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im2} \PYG{o}{=} \PYG{n}{im}\PYG{o}{.}\PYG{n}{crop}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{300}\PYG{p}{,}\PYG{l+m+mi}{400}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im2}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
You can get a new image that is a resized version of an existing
image. The new size must be given as a tuple:
\sphinxcode{\sphinxupquote{im.resize((width,height))}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im3} \PYG{o}{=} \PYG{n}{im}\PYG{o}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im3}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{resized.jpg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{im.convert(mode)}} creates a copy of in image with a new mode -
gray scale (\sphinxcode{\sphinxupquote{'L'}}) in the following example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im4} \PYG{o}{=} \PYG{n}{im}\PYG{o}{.}\PYG{n}{convert}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im4}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Something new, functions that change an image}
\label{\detokenize{lecture_notes/lec07_modules_images:something-new-functions-that-change-an-image}}\begin{itemize}
\item {} 
The functions we have seen so far return a new result, but never
change the object that they apply to.

\item {} 
More complex types such as images, often provide methods that allow us to change the
object (image)
for efficiency reason.

\item {} 
You just have to remember how each function works.

\item {} 
Here is our first function with this property: \sphinxcode{\sphinxupquote{im1.paste(im2,
(x,y))}} pastes one image (\sphinxcode{\sphinxupquote{im2}}) into the first image (\sphinxcode{\sphinxupquote{im1}})
starting at the top left coordinates \sphinxcode{\sphinxupquote{(x,y)}}. The first image is
changed as a result, but not the second one.

Note that the second image must fit in the first image starting
with these coordinates; otherwise, the pasted image will be cropped.

\item {} 
How we call such a function is different:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im1} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sheep.jpg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im1}\PYG{o}{.}\PYG{n}{size}
\PYG{g+go}{(600, 396)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{new}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RGB}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{600}\PYG{p}{,} \PYG{l+m+mi}{396}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{paste}\PYG{p}{(} \PYG{n}{im1}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{}\PYGZsh{}not assigning the result of paste to a new variable}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{paste}\PYG{p}{(} \PYG{n}{im1}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{396}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
The fact that the function \sphinxcode{\sphinxupquote{paste}} changes an image is an
implementation decision made by the designers of PIL, mostly
because images are so large and copying is therefore time
consuming.

Later in the semester, we will learn how to write such functions.

\end{itemize}


\section{Example 2: Cut and pasting parts of an image}
\label{\detokenize{lecture_notes/lec07_modules_images:example-2-cut-and-pasting-parts-of-an-image}}\begin{itemize}
\item {} 
This example crops three boxes from an image, creates a new image and
pastes the boxes at different locations of this new image.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k}{import} \PYG{n}{Image}

\PYG{n}{im} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lego\PYGZus{}movie.jpg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{w}\PYG{p}{,}\PYG{n}{h} \PYG{o}{=} \PYG{n}{im}\PYG{o}{.}\PYG{n}{size}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Crop out three columns from the image}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Note: the crop function returns a new image}
\PYG{n}{part1} \PYG{o}{=} \PYG{n}{im}\PYG{o}{.}\PYG{n}{crop}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{w}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{part2} \PYG{o}{=} \PYG{n}{im}\PYG{o}{.}\PYG{n}{crop}\PYG{p}{(}\PYG{p}{(}\PYG{n}{w}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{part3} \PYG{o}{=} \PYG{n}{im}\PYG{o}{.}\PYG{n}{crop}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{w}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Create a new image}
\PYG{n}{newim} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{new}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RGB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Paste the image in different order}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} Note: the paste function changes the image it is applied to}
\PYG{n}{newim}\PYG{o}{.}\PYG{n}{paste}\PYG{p}{(}\PYG{n}{part3}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{newim}\PYG{o}{.}\PYG{n}{paste}\PYG{p}{(}\PYG{n}{part1}\PYG{p}{,} \PYG{p}{(}\PYG{n}{w}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{newim}\PYG{o}{.}\PYG{n}{paste}\PYG{p}{(}\PYG{n}{part2}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{newim}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Summary}
\label{\detokenize{lecture_notes/lec07_modules_images:summary}}\begin{itemize}
\item {} 
Tuples are similar to strings and numbers in many ways. You cannot
change a part of a tuple. However, unlike other simple data types,
tuples allow access to the individual components using the indexing
notation \sphinxcode{\sphinxupquote{{[} {]}}}.

\item {} 
Modules contain a combination of functions, variables, object
definitions, and other code, all designed for use in other Python
programs and modules

\item {} 
\sphinxcode{\sphinxupquote{PILLOW}} provides a set of modules that define the \sphinxcode{\sphinxupquote{Image}} object
type and associated methods.

\end{itemize}


\section{Reviewing for the exam:  topics and ideas}
\label{\detokenize{lecture_notes/lec07_modules_images:reviewing-for-the-exam-topics-and-ideas}}
Here are crucial topics to review before the exam.
\begin{itemize}
\item {} 
Syntax: can you find syntax errors in code?

\item {} 
Correct variable names, assigning a value to a variable

\item {} 
Output: can you predict the output of a piece of code?

\item {} 
Expressions and operator precedence

\item {} 
The distinction between integer and float division

\item {} 
The distinction between division (4//5) and modulo (4\%5) operators,
and how they work for positive and negative numbers

\item {} 
Remember shorthands: \sphinxcode{\sphinxupquote{+=}}, \sphinxcode{\sphinxupquote{-=}}, \sphinxcode{\sphinxupquote{/=}}, \sphinxcode{\sphinxupquote{*=}}.

\item {} 
Functions: defining functions and using them

\item {} 
Distinguish between variables local to functions and variables that
are global

\item {} 
Modules: how to import and call functions that are from a specific
module (\sphinxcode{\sphinxupquote{math}} is the only one we learned so far)

\item {} 
How to access variable values defined in a module (see \sphinxcode{\sphinxupquote{math.pi}}
for example)

\item {} 
Strings: how to create them, how to escape characters, multi-line strings

\item {} 
How to use \sphinxcode{\sphinxupquote{input()}}: remember it always returns a string

\item {} 
Boolean data type: distinguish between expressions that return
integer/float/string/Boolean

\item {} 
Remember the distinction between \sphinxcode{\sphinxupquote{=}} and \sphinxcode{\sphinxupquote{==}}

\item {} 
Boolean value of conditions involving AND/OR/NOT

\item {} 
\sphinxcode{\sphinxupquote{if}}/\sphinxcode{\sphinxupquote{elif}}/\sphinxcode{\sphinxupquote{else}}:  how to write them. Understand what parts
are optional and how they work

\item {} 
Remember the same function may work differently and do different
things when applied to a different data type.

\item {} 
Review all about the different ways to call the print function for
multiple lines of input

\item {} 
Operators: \sphinxcode{\sphinxupquote{+}} (concatenation and addition), \sphinxcode{\sphinxupquote{*}} (replication
and multiplication), \sphinxcode{\sphinxupquote{/}}, \sphinxcode{\sphinxupquote{\%}}, \sphinxcode{\sphinxupquote{**}}

\item {} 
Functions:  \sphinxcode{\sphinxupquote{int()}}, \sphinxcode{\sphinxupquote{float()}}, \sphinxcode{\sphinxupquote{str()}},
\sphinxcode{\sphinxupquote{math.sqrt()}}, \sphinxcode{\sphinxupquote{min()}}, \sphinxcode{\sphinxupquote{max()}}, \sphinxcode{\sphinxupquote{abs()}},
\sphinxcode{\sphinxupquote{round()}}, \sphinxcode{\sphinxupquote{sum()}} etc.

\item {} 
Functions applied to string objects using the dot notation, where
\sphinxcode{\sphinxupquote{string}} is a string object, such as \sphinxcode{\sphinxupquote{"car"}} or the name of a
string variable:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{string.upper()}}, \sphinxcode{\sphinxupquote{string.lower()}}, \sphinxcode{\sphinxupquote{string.replace()}},
\sphinxcode{\sphinxupquote{string.capitalize()}}, \sphinxcode{\sphinxupquote{string.title()}},
\sphinxcode{\sphinxupquote{string.find()}}, \sphinxcode{\sphinxupquote{string.count()}}, \sphinxcode{\sphinxupquote{len()}}

\end{itemize}

\item {} 
Distinguish between the different types of functions we have
learned in this class:

\end{itemize}
\begin{quote}
\begin{itemize}
\item {} 
Functions that take one or more values as input and return
something (input objects/values are not modified)

\end{itemize}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{min}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mystr} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monty Python}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{mystr}\PYG{p}{)}
\PYG{g+go}{12}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
Functions that take one or more values as input and return
nothing (input objects/values are not modified)

\end{itemize}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}max}\PYG{p}{(}\PYG{n}{val1}\PYG{p}{,} \PYG{n}{val2}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Maximum value is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{val1}\PYG{p}{,} \PYG{n}{val2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x1} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x2} \PYG{o}{=} \PYG{l+m+mi}{15}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{print\PYGZus{}max}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{)}
\PYG{g+go}{Maximum value is 15}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
Functions that apply to an object, like a string, and return a
value (but do not modify the object that they are applied to)

\end{itemize}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mystr} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Monty Python}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mystr}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}Mxnty Pythxn\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mystr}
\PYG{g+go}{\PYGZsq{}Monty Python\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mystr}\PYG{o}{.}\PYG{n}{upper}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}MONTY PYTHON\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mystr}
\PYG{g+go}{\PYGZsq{}Monty Python\PYGZsq{}}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
Functions that are applied to an object, like an \sphinxcode{\sphinxupquote{Image}} and
modify it (but not return anything), we have only learned \sphinxcode{\sphinxupquote{Image.paste}}
so far (and images will NOT be on the exam).

\end{itemize}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{paste}\PYG{p}{(} \PYG{n}{im2}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}
\end{quote}
\begin{itemize}
\item {} 
Local vs. global variables: Can you tell what each of the print statements
print and explain why?

\end{itemize}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}

\PYG{k}{def} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}

\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{10}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\section{Reviewing for the exam:  problem solving}
\label{\detokenize{lecture_notes/lec07_modules_images:reviewing-for-the-exam-problem-solving}}
In the remaining time we will go through several practice questions to
demonstrate how we approach these problems.  While our immediate
concern is the exam, you will be developing your problem solving
skills and programming abilities.  Most of these questions have
appeared on previous exams in CS 1.
\begin{enumerate}
\item {} 
What is the \sphinxstylestrong{exact} output of the following Python code?  What
are the global variables, the function arguments, the local
variables, and the parameters in the code?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{3}

\PYG{k}{def} \PYG{n+nf}{do\PYGZus{}something}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
   \PYG{n}{z}\PYG{o}{=}\PYG{n}{x}\PYG{o}{+}\PYG{n}{y}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
   \PYG{n}{z} \PYG{o}{+}\PYG{o}{=} \PYG{n}{z}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
   \PYG{n}{z} \PYG{o}{+}\PYG{o}{=} \PYG{n}{z} \PYG{o}{*} \PYG{n}{z}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}

\PYG{n}{do\PYGZus{}something}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{do\PYGZus{}something}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Write a Python function that takes two strings as input and
prints them together on one 35-character line, with the first string
left-justified, the second string right-justified, and as many
periods between the words as needed.  For example, the function
calls

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{print\PYGZus{}left\PYGZus{}right}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{print\PYGZus{}left\PYGZus{}right}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{syntax error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{semantic error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

should output

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{apple}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{n}{banana}
\PYG{n}{syntax} \PYG{n}{error}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{n}{semantic} \PYG{n}{error}
\end{sphinxVerbatim}

You may assume that the lengths of the two strings passed as arguments
together are less than 35 characters.

\item {} 
In the United States, a car’s fuel efficiency is measured in
miles driven per gallon used.  In the metric system it is liters
used per 100 kilometers driven.  Using the values 1.609 kilometers
equals 1 mile and 1 gallon equals 3.785 liters, write a Python
function that converts a fuel efficiency measure in miles per gallon
to one in liters per 100 kilometers and returns the result.

\item {} 
Write a program that reads Erin’s height (in cm), Erin’s age (years),
Dale’s height (in cm) and Dale’s age (years) and tells the name of
the person who is both older and taller or tells that neither is
both older and taller.

\end{enumerate}


\chapter{Lecture 7 — Exercises}
\label{\detokenize{lecture_notes/lec07_modules_images_exercises/exercises:lecture-7-exercises}}\label{\detokenize{lecture_notes/lec07_modules_images_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for grading.
A separate file must be submitted for each problem.  These must be
submitted by 4 pm on Friday, February 9th.
\begin{enumerate}
\item {} 
What is the output from the following code.  Note that we did not
cover all of these techniques in class, so you might need to do
some exploration on your own.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{hmmm}\PYG{p}{(} \PYG{n}{x} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{x}

\PYG{n}{s} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{u} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{n}{t}\PYG{o}{+}\PYG{n}{u} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{n}{hmmm}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{n}{hmmm}\PYG{p}{(} \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Write a function called \sphinxcode{\sphinxupquote{add\_tuples}} that takes three tuples,
each with two values, and returns a single tuple with two values
containing the sum of the values in the tuples.  Test your function
with the following calls:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{add\PYGZus{}tuples}\PYG{p}{(} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{add\PYGZus{}tuples}\PYG{p}{(} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Note that these two lines of code should be at the bottom of your
program.  This should output

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}
\end{sphinxVerbatim}

\end{enumerate}


\chapter{Lecture 8 — Lists Part 1}
\label{\detokenize{lecture_notes/lec08_lists1:lecture-8-lists-part-1}}\label{\detokenize{lecture_notes/lec08_lists1::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec08_lists1:overview}}\begin{itemize}
\item {} 
So far we’ve looked at working with individual values and variables.

\item {} 
This is cumbersome even for just two or three variables.

\item {} 
We need a way to aggregate multiple values and refer to them using a
single variable.

\item {} 
We have done a little bit of this with strings and tuples, but now
we are going to get started for real.

\end{itemize}

This lecture is largely based on Sections 8.1-8.3 of \sphinxstyleemphasis{Practical Programming}.


\section{Lists are Sequences of Values}
\label{\detokenize{lecture_notes/lec08_lists1:lists-are-sequences-of-values}}\begin{itemize}
\item {} 
Gather together values that have common meaning.

\item {} 
As a first example, here are scores of 7 judges for the free
skating part of a figure skating competition:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{scores} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{59}\PYG{p}{,} \PYG{l+m+mi}{61}\PYG{p}{,} \PYG{l+m+mi}{63}\PYG{p}{,} \PYG{l+m+mi}{63}\PYG{p}{,} \PYG{l+m+mi}{68}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{58} \PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
As a second example, here are the names of the planets in the solar
system (including Pluto, for now):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{planets} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mercury}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Venus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Earth}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mras}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jupiter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Saturn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neptune}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Uranus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Pluto}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
Notes on syntax:
\begin{itemize}
\item {} 
Begin with \sphinxcode{\sphinxupquote{{[}}} and end with \sphinxcode{\sphinxupquote{{]}}}

\item {} 
Commas separate the individual values

\item {} 
The spaces between values are optional and are used for clarity
here.

\item {} 
Any type of object may be stored in a list, and each list can mix
different types.

\end{itemize}

\end{itemize}


\section{Why bother?}
\label{\detokenize{lecture_notes/lec08_lists1:why-bother}}\begin{itemize}
\item {} 
Gather common values together, providing them with a common name,
\sphinxstylestrong{especially} when we don’t know how many values we will have.

\item {} 
Apply an operation to the values as a group.

\item {} 
Apply an operation to each value in the group.

\item {} 
Examples of computations on lists:
\begin{itemize}
\item {} 
Average and standard deviation

\item {} 
Which values are above and below the average

\item {} 
Correct mistakes

\item {} 
Remove values (Pluto)

\item {} 
Look at differences

\end{itemize}

\item {} 
Watch for these themes throughout the next few lectures.

\end{itemize}


\section{Accessing Individual Values — Indexing}
\label{\detokenize{lecture_notes/lec08_lists1:accessing-individual-values-indexing}}\begin{itemize}
\item {} 
Notice that we made the mistake in typing \sphinxcode{\sphinxupquote{'Mras'}}. How do we fix
this? We’ll start by looking at \sphinxstyleemphasis{indexing}.

\item {} 
The line

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{planets}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

accesses and prints the string at what’s known as index 1 of the list
\sphinxcode{\sphinxupquote{planets}}.

\item {} 
Each item / value in the list is associated with a unique index

\item {} 
Indexing in Python (and most other programming languages) starts at
0.

\item {} 
The notation is again to use \sphinxcode{\sphinxupquote{{[}}} and \sphinxcode{\sphinxupquote{{]}}} with an integer
(non-negative) to indicate which list item.

\item {} 
What is the last index in \sphinxcode{\sphinxupquote{planets}}?
\begin{itemize}
\item {} 
We can find the length using \sphinxcode{\sphinxupquote{len()}} and then figure out the
answer.

\end{itemize}

\end{itemize}


\section{A Memory Model for Lists}
\label{\detokenize{lecture_notes/lec08_lists1:a-memory-model-for-lists}}
We’ll draw a memory model in class that illustrates the relationship
among
\begin{itemize}
\item {} 
The name of the list

\item {} 
The indices

\item {} 
The values stored in the list

\end{itemize}


\section{Practice Problems}
\label{\detokenize{lecture_notes/lec08_lists1:practice-problems}}
We will work on these in class:
\begin{enumerate}
\item {} 
What is the index of the first value in \sphinxcode{\sphinxupquote{scores}} that is
greater than 65?

\item {} 
Write a line of Python code to print this value and to print the
previous and next values of the list.

\item {} 
What is the index of the middle value in a list that is odd length?
For even length lists, what are the indices of the middle two values?

\end{enumerate}


\section{Changing Values in the List}
\label{\detokenize{lecture_notes/lec08_lists1:changing-values-in-the-list}}\begin{itemize}
\item {} 
Once we know about indexing, changing a value in a list is easy:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{planets}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mars}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
This makes item 3 of \sphinxcode{\sphinxupquote{planets}} now refer to the string \sphinxcode{\sphinxupquote{'Mars'}}

\item {} 
Now we can check the output:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{planets}\PYG{p}{)}
\end{sphinxVerbatim}

to make sure we got it right.

\item {} 
Strings are similar in many ways.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}a\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}b\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
Big difference: you can change a part of a list; you cannot
change part of a string!

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{}\PYGZgt{} s[1] = \PYGZsq{}A\PYGZsq{}
Traceback (most recent call last):
File \PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}, line 1, in \PYGZlt{}module\PYGZgt{}
TypeError: \PYGZsq{}str\PYGZsq{} object does not support item assignment
\end{sphinxVerbatim}

\end{itemize}


\section{All Indices Are Not Allowed}
\label{\detokenize{lecture_notes/lec08_lists1:all-indices-are-not-allowed}}\begin{itemize}
\item {} 
If \sphinxcode{\sphinxupquote{t}} is a list, then the items are stored at indices from 0 to
\sphinxcode{\sphinxupquote{len(t)-1}}.

\item {} 
If you try to access indices at \sphinxcode{\sphinxupquote{len(t)}} or beyond, you get a
run-time error. We’ll take a look and see.

\item {} 
If you access negative indices, interesting things happen:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{planets}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{Pluto}
\end{sphinxVerbatim}

\item {} 
More specifically, for any list \sphinxcode{\sphinxupquote{t}}, if \sphinxcode{\sphinxupquote{i}} is an index from 0 to
\sphinxcode{\sphinxupquote{len(t)-1}} then \sphinxcode{\sphinxupquote{t{[}i{]}}} and \sphinxcode{\sphinxupquote{t{[}i-len(t){]}}} are the same spot in
the list.

\end{itemize}


\section{Functions on Lists: Computing the Average}
\label{\detokenize{lecture_notes/lec08_lists1:functions-on-lists-computing-the-average}}\begin{itemize}
\item {} 
There are many functions (methods) on lists. We can learn all about
them using the \sphinxcode{\sphinxupquote{help}} command.
\begin{itemize}
\item {} 
This is just like we did for strings and for modules, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{help}\PYG{p}{(}\PYG{n}{math}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{help}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
Interestingly, we can run help in two ways, one

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{)}
\end{sphinxVerbatim}

gives us the list methods, and the second

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n}{planets}\PYG{p}{)}
\end{sphinxVerbatim}

tells us that \sphinxcode{\sphinxupquote{planets}} is a list before giving us list methods.

\item {} 
First, let’s see some basic functions on the list values.

\item {} 
The basic functions \sphinxcode{\sphinxupquote{max}}, \sphinxcode{\sphinxupquote{sum}} and \sphinxcode{\sphinxupquote{min}} may be applied to lists as
well.

\item {} 
This gives us a simple way to compute the average of our list of
scores.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Average Scores = }\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{scores}\PYG{p}{)} \PYG{o}{/} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{scores}\PYG{p}{)} \PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{Average Scores = 62.29}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Max Score =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{scores}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{Max Score = 68}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Min Score =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{scores}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{Min Score = 58}
\end{sphinxVerbatim}

\item {} 
Exploring, we will look at what happens when we apply \sphinxcode{\sphinxupquote{sum}},
\sphinxcode{\sphinxupquote{max}} and \sphinxcode{\sphinxupquote{min}} to our list of planet names. Can you explain the
result?

\end{itemize}


\section{Functions that modify the input: Sorting a list}
\label{\detokenize{lecture_notes/lec08_lists1:functions-that-modify-the-input-sorting-a-list}}\begin{itemize}
\item {} 
We can also sort the values in a list by sorting it. Let’s try the
following:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{planets} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mercury}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Venus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Earth}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mras}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jupiter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYGZbs{}
\PYG{g+go}{\PYGZsq{}Saturn\PYGZsq{}, \PYGZsq{}Neptune\PYGZsq{}, \PYGZsq{}Uranus\PYGZsq{}, \PYGZsq{}Pluto\PYGZsq{} ]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{planets}
\PYG{g+go}{[\PYGZsq{}Mercury\PYGZsq{}, \PYGZsq{}Venus\PYGZsq{}, \PYGZsq{}Earth\PYGZsq{}, \PYGZsq{}Mras\PYGZsq{}, \PYGZsq{}Jupiter\PYGZsq{}, \PYGZsq{}Saturn\PYGZsq{}, \PYGZsq{}Neptune\PYGZsq{}, \PYGZsq{}Uranus\PYGZsq{}, \PYGZsq{}Pluto\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{planets}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{planets}
\PYG{g+go}{[\PYGZsq{}Earth\PYGZsq{}, \PYGZsq{}Jupiter\PYGZsq{}, \PYGZsq{}Mercury\PYGZsq{}, \PYGZsq{}Mras\PYGZsq{}, \PYGZsq{}Neptune\PYGZsq{}, \PYGZsq{}Pluto\PYGZsq{}, \PYGZsq{}Saturn\PYGZsq{}, \PYGZsq{}Uranus\PYGZsq{}, \PYGZsq{}Venus\PYGZsq{}]}
\end{sphinxVerbatim}

\item {} 
Note that we did not assign the value returned by sort to a new
variable. This is the first function we have learned outside
of our Image module that modifies the
input but returns nothing. Try the following and see what happens:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{scores} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{59}\PYG{p}{,} \PYG{l+m+mi}{61}\PYG{p}{,} \PYG{l+m+mi}{63}\PYG{p}{,} \PYG{l+m+mi}{63}\PYG{p}{,} \PYG{l+m+mi}{68}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{58} \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{new\PYGZus{}scores} \PYG{o}{=} \PYG{n}{scores}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{scores}
\PYG{g+go}{[58, 59, 61, 63, 63, 64, 68]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{new\PYGZus{}scores}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Ok, what is the value of the variable \sphinxcode{\sphinxupquote{new\_scores}}? It is
unclear. Let’s  try in a different way.

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{scores}\PYG{p}{)}
\PYG{g+go}{[58, 59, 61, 63, 63, 64, 68]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{new\PYGZus{}scores}\PYG{p}{)}
\PYG{g+go}{None}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
So, the function returns nothing! But, it does change the value of
the input list.

\item {} 
It does so because lists are containers, and functions can
manipulate what is inside containers. Functions cannot do so for simple
types like integer and float.

\item {} 
If we want a new list that is sorted without changing the original list
then we use the \sphinxcode{\sphinxupquote{sorted()}} function:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{scores} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{59}\PYG{p}{,} \PYG{l+m+mi}{61}\PYG{p}{,} \PYG{l+m+mi}{63}\PYG{p}{,} \PYG{l+m+mi}{63}\PYG{p}{,} \PYG{l+m+mi}{68}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{58} \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{new\PYGZus{}scores} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{scores}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{scores}
\PYG{g+go}{[ 59, 61, 63, 63, 68, 64, 58 ]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{new\PYGZus{}scores}
\PYG{g+go}{[58, 59, 61, 63, 63, 64, 68]}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{itemize}


\section{More Functions: Appending Values, Inserting Values, Deleting}
\label{\detokenize{lecture_notes/lec08_lists1:more-functions-appending-values-inserting-values-deleting}}\begin{itemize}
\item {} 
Now, we will see more functions that can change the value of a list
without returning anything.

\item {} 
Armed with this knowledge, we can figure out how to add and remove
values from a list:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{append()}}

\item {} 
\sphinxcode{\sphinxupquote{insert()}}

\item {} 
\sphinxcode{\sphinxupquote{pop()}}

\item {} 
\sphinxcode{\sphinxupquote{remove()}}

\end{itemize}

\item {} 
These operations are fundamental to any “container” — an object type
that stores other objects.
\begin{itemize}
\item {} 
Lists are our first example of a container

\end{itemize}

\end{itemize}


\section{Lists of Lists}
\label{\detokenize{lecture_notes/lec08_lists1:lists-of-lists}}\begin{itemize}
\item {} 
Note that lists can contain any mixture of values, including other lists.

\item {} 
For example, in

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Alice}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{3.75}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MATH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CSCI}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PSYC}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PA}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{L{[}0{]}}} is the name,

\item {} 
\sphinxcode{\sphinxupquote{L{[}1{]}}} is the GPA

\item {} 
\sphinxcode{\sphinxupquote{L{[}2{]}}} is a list of courses

\item {} 
\sphinxcode{\sphinxupquote{L{[}2{]}{[}0{]}}} is the 0th course, \sphinxcode{\sphinxupquote{'MATH'}}

\item {} 
\sphinxcode{\sphinxupquote{L{[}3{]}}} is a home state abbreviation

\end{itemize}

\item {} 
We will write code to print the courses, to change the math course to
a stats course, and to append a zipcode.

\end{itemize}


\section{Additional Practice Problems}
\label{\detokenize{lecture_notes/lec08_lists1:additional-practice-problems}}\begin{enumerate}
\item {} 
Write three different ways of removing the last value — \sphinxcode{\sphinxupquote{'Pluto'}} —
from the list of planets. Two of these will use the method \sphinxcode{\sphinxupquote{pop}}.

\item {} 
Write code to insert \sphinxcode{\sphinxupquote{'Asteroid belt'}} between \sphinxcode{\sphinxupquote{'Mars'}} and
\sphinxcode{\sphinxupquote{'Jupiter'}}.

\end{enumerate}


\section{Summary}
\label{\detokenize{lecture_notes/lec08_lists1:summary}}\begin{itemize}
\item {} 
Lists are sequences of values, allowing these values to be collected
and processed together.

\item {} 
Individual values can be accessed and changed through indexing.

\item {} 
Functions and methods can be used to \sphinxstylestrong{return} important properties
of lists like \sphinxcode{\sphinxupquote{min()}}, \sphinxcode{\sphinxupquote{max()}}, \sphinxcode{\sphinxupquote{sum()}}.

\item {} 
Functions and methods can be also used to \sphinxstylestrong{modify} lists, but not
return anything.

\end{itemize}


\chapter{Lecture 8 — Exercises}
\label{\detokenize{lecture_notes/lec08_lists1_exercises/exercises:lecture-8-exercises}}\label{\detokenize{lecture_notes/lec08_lists1_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for grading.
A separate file must submitted for each problem.  These must be
submitted by 4 pm on Friday, February 16.
\begin{enumerate}
\item {} 
Upload a text file showing the output of the following code to
Submitty.  As usual you should try to predict the output by hand.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{l1} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hello}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{l1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{l1}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{l1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(} \PYG{l+m+mi}{15} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l1}\PYG{p}{)} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l1}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)} \PYG{p}{)}
\PYG{n}{l1}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{l1}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{l1}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{]} \PYG{p}{)}
\PYG{n}{l1}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{l1}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{n}{l1}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{l1}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{l1}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{l1}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{l1}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{l1}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Write a short Python program that starts with the list

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{values} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{13} \PYG{p}{]}
\end{sphinxVerbatim}

(The above statement list should be the first line of your
program.)  Then add code that does the following steps:
\begin{enumerate}
\item {} 
Reads an integer, prints it (as we have done for input when using
Submitty), and appends it to the end of \sphinxcode{\sphinxupquote{values}}.

\item {} 
Reads another integer, prints it and inserts it at index
location 2 of \sphinxcode{\sphinxupquote{values}}.

\item {} 
Prints the integer at index 3 of \sphinxcode{\sphinxupquote{values}} and print the
integer at index -1 of \sphinxcode{\sphinxupquote{values}}, both on one line.

\item {} 
Prints the difference between the maximum and minimum of the
integers in \sphinxcode{\sphinxupquote{values}}.

\item {} 
Prints the average of the integers in \sphinxcode{\sphinxupquote{values}}, accurate to
one decimal place.  This must use the functions \sphinxcode{\sphinxupquote{sum()}} and
\sphinxcode{\sphinxupquote{len()}}.

\item {} 
Prints the median of the numbers in \sphinxcode{\sphinxupquote{values}}.  Since the list
is even length (a fact that you are allowed to use, just for this
exercise), this is the average of the two middle integers after
\sphinxcode{\sphinxupquote{values}} is sorted.

\end{enumerate}

Here is an example of running our solution (as it would look on Submitty):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Enter} \PYG{n}{a} \PYG{n}{value}\PYG{p}{:} \PYG{l+m+mi}{15}
\PYG{n}{Enter} \PYG{n}{another} \PYG{n}{value}\PYG{p}{:} \PYG{l+m+mi}{23}
\PYG{l+m+mi}{8} \PYG{l+m+mi}{15}
\PYG{n}{Difference}\PYG{p}{:} \PYG{l+m+mi}{16}
\PYG{n}{Average}\PYG{p}{:} \PYG{l+m+mf}{13.6}
\PYG{n}{Median}\PYG{p}{:} \PYG{l+m+mf}{13.5}
\end{sphinxVerbatim}

\end{enumerate}


\chapter{Lecture 9 — While Loops}
\label{\detokenize{lecture_notes/lec09_loops1_while:lecture-9-while-loops}}\label{\detokenize{lecture_notes/lec09_loops1_while::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec09_loops1_while:overview}}\begin{itemize}
\item {} 
Loops are used to access and modify information stored in lists and
are used to repeat computations many times.

\item {} 
We construct loops using logical conditions: \sphinxcode{\sphinxupquote{while}} loops

\item {} 
We will investiage single and multiple loops

\end{itemize}

Reading:  Our coverage of loops is in a different order than that of
\sphinxstyleemphasis{Practical Programming}.  A direct reference for reading material is
Section 9.6.


\section{Part 1: The Basics}
\label{\detokenize{lecture_notes/lec09_loops1_while:part-1-the-basics}}\begin{itemize}
\item {} 
Loops allow us to repeat a block of code multiple times. This is
the basis for many sophisticated programming tasks

\item {} 
We will see two ways to write loops: using \sphinxcode{\sphinxupquote{while}} loops and \sphinxcode{\sphinxupquote{for}} loops

\item {} 
In Python, \sphinxcode{\sphinxupquote{while}} loops are more general in Python because you
can always write a \sphinxcode{\sphinxupquote{for}} loop using a \sphinxcode{\sphinxupquote{while}} loop.

\item {} 
We will start with \sphinxcode{\sphinxupquote{while}} loops first and then see how we can
simplify common tasks with \sphinxcode{\sphinxupquote{for}} loops later.

\end{itemize}


\section{Basics of While}
\label{\detokenize{lecture_notes/lec09_loops1_while:basics-of-while}}\begin{itemize}
\item {} 
Our first \sphinxcode{\sphinxupquote{while}} loop just counts numbers from 1 to 9, and prints them.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{k}{while} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}   \PYG{c+c1}{\PYGZsh{}\PYGZsh{} if you forget this, your program will never end}
\end{sphinxVerbatim}

\item {} 
General form of a \sphinxcode{\sphinxupquote{while}} loop:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{n}{condition}\PYG{p}{:}
    \PYG{n}{block}
\end{sphinxVerbatim}

\item {} 
Steps
\begin{enumerate}
\item {} 
Evaluate any code before \sphinxcode{\sphinxupquote{while}}

\item {} 
Evaluate the \sphinxcode{\sphinxupquote{while}} loop \sphinxcode{\sphinxupquote{condition}}:
\begin{enumerate}
\item {} 
If it is \sphinxcode{\sphinxupquote{True}}, evaluate the block of code, and then repeat
the evaluation of the condition.

\item {} 
If it is \sphinxcode{\sphinxupquote{False}}, end the loop, and continue with the code
after the loop.

\end{enumerate}

\end{enumerate}

In other words, the cycle of evaluating the condition followed by
evaluating the block of code continues until the condition evaluates
to \sphinxcode{\sphinxupquote{False}}.

\item {} 
An important issue that is sometimes easy to answer and sometimes
very hard to answer is to know that your loop will always
terminate.

\end{itemize}


\section{Using Loops with Lists}
\label{\detokenize{lecture_notes/lec09_loops1_while:using-loops-with-lists}}\begin{itemize}
\item {} 
Often, we use loops to repeat a specific operation on every element of
a list.

\item {} 
We must be careful to create a number that will serve as the index
of elements of a list. Valid values are: 0 up to (not including)
the length of list.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{co2\PYGZus{}levels} \PYG{o}{=} \PYG{p}{[} \PYG{p}{(}\PYG{l+m+mi}{2001}\PYG{p}{,} \PYG{l+m+mf}{320.03}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2003}\PYG{p}{,} \PYG{l+m+mf}{322.16}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2004}\PYG{p}{,} \PYG{l+m+mf}{328.07}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
               \PYG{p}{(}\PYG{l+m+mi}{2006}\PYG{p}{,} \PYG{l+m+mf}{323.91}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2008}\PYG{p}{,} \PYG{l+m+mf}{341.47}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2009}\PYG{p}{,} \PYG{l+m+mf}{348.92}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
               \PYG{p}{(}\PYG{l+m+mi}{2010}\PYG{p}{,} \PYG{l+m+mf}{357.29}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2011}\PYG{p}{,} \PYG{l+m+mf}{363.77}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2012}\PYG{p}{,} \PYG{l+m+mf}{361.51}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
               \PYG{p}{(}\PYG{l+m+mi}{2013}\PYG{p}{,} \PYG{l+m+mf}{382.47}\PYG{p}{)} \PYG{p}{]}

\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i}\PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{co2\PYGZus{}levels}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Year}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{co2\PYGZus{}levels}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYGZbs{}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CO2 levels:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{co2\PYGZus{}levels}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\item {} 
Let’s make some errors to see what happens to the loop.

\end{itemize}


\section{Part 1 Practice}
\label{\detokenize{lecture_notes/lec09_loops1_while:part-1-practice}}\begin{enumerate}
\item {} 
Write a while loop to count down from 10 to 1, printing the values
of the loop counting variable \sphinxcode{\sphinxupquote{i}} (it could be some other variable
name as well).

\item {} 
Modify your loop to print the values in the list \sphinxcode{\sphinxupquote{co2\_levels}} in
reverse order.

\end{enumerate}


\section{Accumulation of values}
\label{\detokenize{lecture_notes/lec09_loops1_while:accumulation-of-values}}\begin{itemize}
\item {} 
Often, we use loops to accumulate some type of information such as
adding all the values in a list.

\item {} 
Let’s change the loop to add numbers from 1 to 9.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{:}
    \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}
    \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{total}\PYG{p}{)}
\end{sphinxVerbatim}

(Of course you can and should do this with the \sphinxcode{\sphinxupquote{sum()}}
function, but guess what that actually does!)

\item {} 
Let’s use a loop to add the numbers in a list.
\begin{itemize}
\item {} 
Now, we will use the numbers the loop generates to index a list.

\item {} 
So, the loop must generate numbers from 0 to length of the list.

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{co2\PYGZus{}levels} \PYG{o}{=} \PYG{p}{[} \PYG{p}{(}\PYG{l+m+mi}{2001}\PYG{p}{,} \PYG{l+m+mf}{320.03}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2003}\PYG{p}{,} \PYG{l+m+mf}{322.16}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2004}\PYG{p}{,} \PYG{l+m+mf}{328.07}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
               \PYG{p}{(}\PYG{l+m+mi}{2006}\PYG{p}{,} \PYG{l+m+mf}{323.91}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2008}\PYG{p}{,} \PYG{l+m+mf}{341.47}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2009}\PYG{p}{,} \PYG{l+m+mf}{348.92}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
               \PYG{p}{(}\PYG{l+m+mi}{2010}\PYG{p}{,} \PYG{l+m+mf}{357.29}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2011}\PYG{p}{,} \PYG{l+m+mf}{363.77}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2012}\PYG{p}{,} \PYG{l+m+mf}{361.51}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
               \PYG{p}{(}\PYG{l+m+mi}{2013}\PYG{p}{,} \PYG{l+m+mf}{382.47}\PYG{p}{)} \PYG{p}{]}

\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{total}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i}\PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{co2\PYGZus{}levels}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{co2\PYGZus{}levels}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Total co2\PYGZus{}levels is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{total}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Let’s have a more interesting example. Be very careful not to use
an incorrect index for the list.
\begin{itemize}
\item {} 
Count the number of CO2 values in the list that are greater
than 350.

\item {} 
Calculate and print the percentage change in each measurement year
from the previous measurement year.

\item {} 
Determine the years in which the CO2 levels dropped compared to the
previous measurement.  Output just these years.

\end{itemize}

\end{itemize}


\section{Part 2 Practice}
\label{\detokenize{lecture_notes/lec09_loops1_while:part-2-practice}}\begin{enumerate}
\item {} 
Suppose we wanted to print the first, third, fifth, etc. elements
in a list. Write code to accomplish this.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{months}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{feb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apr}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{may}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jun}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jul}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aug}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sep}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{oct}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nov}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
Now, use a similar loop code to print a little evergreen tree.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{o}{*}
   \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
  \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
 \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
   \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
   \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
\end{sphinxVerbatim}

\item {} 
Try this later: change your loop to work for any size evergreen.

\end{enumerate}


\section{Loops that end on other conditions}
\label{\detokenize{lecture_notes/lec09_loops1_while:loops-that-end-on-other-conditions}}\begin{itemize}
\item {} 
Here is a while loop to add the non-zero numbers that the user types
in.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{end\PYGZus{}found} \PYG{o}{=} \PYG{k+kc}{False}

\PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{end\PYGZus{}found}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter an integer to add (0 to end) ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{end\PYGZus{}found} \PYG{o}{=} \PYG{k+kc}{True}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{total}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We will work through this loop by hand in class.

\end{itemize}


\section{Multiple nested loops}
\label{\detokenize{lecture_notes/lec09_loops1_while:multiple-nested-loops}}\begin{itemize}
\item {} 
Loops and if statements can both be nested.

\item {} 
We’ve already seen this for if statements.

\item {} 
Here’s an example where we print every pair of values in a list.

\item {} 
First solution:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{31}\PYG{p}{]}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{while} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{L}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{j} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\item {} 
This solution prints the values from the same pair of indices twice
-  e.g.the pair 21, 12 is printed  once when \sphinxstyleemphasis{i=1}, \sphinxstyleemphasis{j=2} and
once when \sphinxstyleemphasis{i=2}, \sphinxstyleemphasis{j=1}.

\item {} 
How can we modify it so that we only print each pair once?

\item {} 
What has to change if we don’t want to print when \sphinxstyleemphasis{i==j}?

\item {} 
Finally, we will modify the resulting loop to find the two closest
values in the list.

\end{itemize}


\section{Summary}
\label{\detokenize{lecture_notes/lec09_loops1_while:summary}}\begin{itemize}
\item {} 
Loops are especially useful for iterating over a list, accessing its
contents, and adding or counting the values from a list.  This is
done in the \sphinxcode{\sphinxupquote{sum()}} and \sphinxcode{\sphinxupquote{len()}} functions of Python.

\item {} 
Each loop has a stopping condition — the boolean expression in
the \sphinxstyleemphasis{while} statement.  The loop will end when the condition
evaluates to \sphinxstyleemphasis{True}.

\item {} 
If the stopping condition is never reached, the loop will become
“infinite”.

\item {} 
Often a counter variable is used.  It (a) is given an initial value
before the loop starts, (b) is incremented (or decremented) once in
each loop iteration, and (c) is used to stop the loop when it
reaches the index of the end (or beginning) of the list.

\item {} 
We will demonstrate a simple way to write these common loops with a
\sphinxcode{\sphinxupquote{for}} loop in the next lecture.

\end{itemize}


\chapter{Lecture 9 — Exercises}
\label{\detokenize{lecture_notes/lec09_loops1_while_exercises/exercises:lecture-9-exercises}}\label{\detokenize{lecture_notes/lec09_loops1_while_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for grading.
A separate file must submitted for each problem.  Each problem
requires you to use a \sphinxstyleemphasis{while} loop. As a whole this exercise set is a
bit longer than previous ones because loops are so important and
require so much practice.  Solutions must be submitted by 4 pm on
Wednesday, February 21.
\begin{enumerate}
\item {} 
Write a program that asks the user for a single integer \sphinxcode{\sphinxupquote{n}} and
prints the non-negative multiples of 3 that are less than \sphinxcode{\sphinxupquote{n}}.
Here is an example run of the program on Submitty

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Enter} \PYG{n}{a} \PYG{n}{positive} \PYG{n}{integer}\PYG{p}{:} \PYG{l+m+mi}{12}
\PYG{l+m+mi}{0}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{6}
\PYG{l+m+mi}{9}
\end{sphinxVerbatim}

\item {} 
The following list represents the population of New York State (in
hundreds of thousands of people) for the US Census in 1790, 1800,
1810, etc., all the way through 2010.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{census} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{340}\PYG{p}{,} \PYG{l+m+mi}{589}\PYG{p}{,} \PYG{l+m+mi}{959}\PYG{p}{,} \PYG{l+m+mi}{1372}\PYG{p}{,} \PYG{l+m+mi}{1918}\PYG{p}{,} \PYG{l+m+mi}{2428}\PYG{p}{,} \PYG{l+m+mi}{3097}\PYG{p}{,} \PYG{l+m+mi}{3880}\PYG{p}{,} \PYG{l+m+mi}{4382}\PYG{p}{,} \PYG{l+m+mi}{5082}\PYG{p}{,} \PYGZbs{}
            \PYG{l+m+mi}{5997}\PYG{p}{,} \PYG{l+m+mi}{7268}\PYG{p}{,} \PYG{l+m+mi}{9113}\PYG{p}{,} \PYG{l+m+mi}{10385}\PYG{p}{,} \PYG{l+m+mi}{12588}\PYG{p}{,} \PYG{l+m+mi}{13479}\PYG{p}{,} \PYG{l+m+mi}{14830}\PYG{p}{,} \PYG{l+m+mi}{16782}\PYG{p}{,} \PYGZbs{}
            \PYG{l+m+mi}{8236}\PYG{p}{,} \PYG{l+m+mi}{17558}\PYG{p}{,} \PYG{l+m+mi}{17990}\PYG{p}{,} \PYG{l+m+mi}{18976}\PYG{p}{,} \PYG{l+m+mi}{19378} \PYG{p}{]}
\end{sphinxVerbatim}

Copy and paste this list into the start of a new program file.
Then write code to find the average percentage change from one
decade to the next, across all decades.  For example, the change
from 1790 to 1800 is (589 - 340) / 340 * 100 = 73.2\% and the change
from 1800 to 1810 is (959 - 589) / 589 * 100 = 62.8\% so the average
across just these two decades is 68.0\%.  The output of your program
would then simply be

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Average} \PYG{o}{=} \PYG{l+m+mf}{68.0}\PYG{o}{\PYGZpc{}}
\end{sphinxVerbatim}

Your answer will be different because it is taken from all
decades.

\item {} 
Write a program that inputs integer values that the user types
until the user types a 0.  Each value (other than 0) should be
stored in a list.  The program should then output the minimum,
maximum and average of the values in the list.  Your program must
start by creating an empty list to store the values.  Here’s an
example of how it might look on Submitty:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Enter} \PYG{n}{a} \PYG{n}{value} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{to} \PYG{n}{end}\PYG{p}{)}\PYG{p}{:} \PYG{l+m+mi}{5}
\PYG{n}{Enter} \PYG{n}{a} \PYG{n}{value} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{to} \PYG{n}{end}\PYG{p}{)}\PYG{p}{:} \PYG{l+m+mi}{3}
\PYG{n}{Enter} \PYG{n}{a} \PYG{n}{value} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{to} \PYG{n}{end}\PYG{p}{)}\PYG{p}{:} \PYG{l+m+mi}{11}
\PYG{n}{Enter} \PYG{n}{a} \PYG{n}{value} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{to} \PYG{n}{end}\PYG{p}{)}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{n}{Min}\PYG{p}{:} \PYG{l+m+mi}{3}
\PYG{n}{Max}\PYG{p}{:} \PYG{l+m+mi}{11}
\PYG{n}{Avg}\PYG{p}{:} \PYG{l+m+mf}{6.3}
\end{sphinxVerbatim}

\end{enumerate}


\chapter{Lecture 10 — Lists Part 2}
\label{\detokenize{lecture_notes/lec10_lists2:lecture-10-lists-part-2}}\label{\detokenize{lecture_notes/lec10_lists2::doc}}

\section{Topics}
\label{\detokenize{lecture_notes/lec10_lists2:topics}}
We will cover the first three of these topics during lecture.  The
fourth is for your own use:
\begin{itemize}
\item {} 
List aliasing, lists and functions

\item {} 
For loops to operate on lists

\item {} 
Slicing to create copies of lists and to create sublists

\item {} 
Converting back and forth between strings and lists

\end{itemize}


\section{List Aliasing}
\label{\detokenize{lecture_notes/lec10_lists2:list-aliasing}}\begin{itemize}
\item {} 
Consider the following example Python code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RPI}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{WPI}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MIT}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2} \PYG{o}{=} \PYG{n}{L1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L3} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RPI}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{WPI}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MIT}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RIT}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CalTech}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}
\PYG{g+go}{[\PYGZsq{}RPI\PYGZsq{}, \PYGZsq{}CalTech\PYGZsq{}, \PYGZsq{}MIT\PYGZsq{}, \PYGZsq{}RIT\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}
\PYG{g+go}{[\PYGZsq{}RPI\PYGZsq{}, \PYGZsq{}CalTech\PYGZsq{}, \PYGZsq{}MIT\PYGZsq{}, \PYGZsq{}RIT\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L3}
\PYG{g+go}{[\PYGZsq{}RPI\PYGZsq{}, \PYGZsq{}WPI\PYGZsq{}, \PYGZsq{}MIT\PYGZsq{}]}
\end{sphinxVerbatim}

\item {} 
Surprised? This is caused by the creation of what we call an
\sphinxstyleemphasis{alias} in computer science:
\begin{itemize}
\item {} 
L1 and L2 reference the same list - they are \sphinxstyleemphasis{aliases} of each
other and the underlying list - so changes made using either
name change the underlying list

\item {} 
L3 references a different list that just happens to have the
same string values in the same order: there would have been no
confusion if the strings in the list had been different.

\item {} 
We’ll use our memory model for lists to understand what is
happening here.

\end{itemize}

\item {} 
Python uses aliases for reasons of efficiency: lists can be quite
long and are frequently changed, so copying of entire lists is
expensive

\item {} 
This is true for other \sphinxstyleemphasis{container} data types as well.
\begin{itemize}
\item {} 
Assignments create an alias for images, lists, tuples, strings and, as we
will see later, sets and dictionaries
\begin{itemize}
\item {} 
Aliases of strings and tuples do not create the same confusion
as other containers because they can not be changed once they
are created.

\end{itemize}

\end{itemize}

\item {} 
Fortunately, if we truly want to copy a list, Python provides a
\sphinxcode{\sphinxupquote{copy()}} method for lists.  Try the following and see what
happens.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{L2} \PYG{o}{=} \PYG{n}{L1}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{L1}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{L2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(} \PYG{l+m+mi}{4} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Aliasing and Function Parameters}
\label{\detokenize{lecture_notes/lec10_lists2:aliasing-and-function-parameters}}\begin{itemize}
\item {} 
When a variable is passed to functions, a copy of its value is
created if the value is a number or a booleans:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}two}\PYG{p}{(}\PYG{n}{val1}\PYG{p}{,} \PYG{n}{val2}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{val1} \PYG{o}{+}\PYG{o}{=} \PYG{n}{val2}
    \PYG{k}{return} \PYG{n}{val1}

\PYG{n}{val1} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{val2} \PYG{o}{=} \PYG{l+m+mi}{15}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{val1}\PYG{p}{,} \PYG{n}{val2}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{add\PYGZus{}two}\PYG{p}{(}\PYG{n}{val1}\PYG{p}{,}\PYG{n}{val2}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{val1}\PYG{p}{,} \PYG{n}{val2}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
When a list is passed to functions, the parameter becomes an alias
for the argument in the function call.

\item {} 
Here is an example of a function that returns a list containing the
two smallest values in its input list:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{smallest\PYGZus{}two}\PYG{p}{(}\PYG{n}{mylist}\PYG{p}{)}\PYG{p}{:}
     \PYG{n}{mylist}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
     \PYG{n}{newlist} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
     \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{mylist}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
         \PYG{n}{newlist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{mylist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
         \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{mylist}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
             \PYG{n}{newlist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{mylist}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
     \PYG{k}{return} \PYG{n}{newlist}

\PYG{n}{values} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{35}\PYG{p}{,} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{60}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Before function:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{values}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Result of function:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{smallest\PYGZus{}two}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{After function:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{values}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
In class we will discuss what happened.

\end{itemize}


\section{What Operations Change a List? What Operations Create New Lists?}
\label{\detokenize{lecture_notes/lec10_lists2:what-operations-change-a-list-what-operations-create-new-lists}}\begin{itemize}
\item {} 
Operations that change lists include
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sort}}, \sphinxcode{\sphinxupquote{insert}}, \sphinxcode{\sphinxupquote{append}}, \sphinxcode{\sphinxupquote{pop}}, \sphinxcode{\sphinxupquote{remove}}

\end{itemize}

\item {} 
Operations that create new lists
\begin{itemize}
\item {} 
Slicing (discussed below), \sphinxcode{\sphinxupquote{copy()}}, concatenation (\sphinxcode{\sphinxupquote{+}}),
replication (\sphinxcode{\sphinxupquote{*}}) and \sphinxcode{\sphinxupquote{list()}}

\end{itemize}

\end{itemize}


\section{Part 1 Practice}
\label{\detokenize{lecture_notes/lec10_lists2:part-1-practice}}
Students will be given about 5 minutes to work on the first two
lecture exercises


\section{Part 2:  For Loops and Operations on List Items}
\label{\detokenize{lecture_notes/lec10_lists2:part-2-for-loops-and-operations-on-list-items}}\begin{itemize}
\item {} 
Although \sphinxstyleemphasis{while} loops allow us to apply an operation to each entry in a list,
Python has a construct called a \sphinxstyleemphasis{for} loop that is often easier
to use for such operations.

\item {} 
Our driving example will be the problem of capitalizing a list of
names.  We’ll start with a simple example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{animals} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{monkey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hawk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tiger}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{parrot}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{cap\PYGZus{}animals} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{animal} \PYG{o+ow}{in} \PYG{n}{animals}\PYG{p}{:}
    \PYG{n}{cap\PYGZus{}animals}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(} \PYG{n}{animal}\PYG{o}{.}\PYG{n}{capitalize}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{cap\PYGZus{}animals}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We can understand what is happening by looking at this
piece-by-piece:
\begin{itemize}
\item {} 
The keyword \sphinxcode{\sphinxupquote{for}} signals the start of a loop

\item {} 
\sphinxcode{\sphinxupquote{animal}} is a loop variable that takes on the value of each item
in the list (as indicated by the keyword \sphinxcode{\sphinxupquote{in}}) in
succession
\begin{itemize}
\item {} 
This is called \sphinxstyleemphasis{iterating} over the values/elements of the list

\end{itemize}

\item {} 
The \sphinxcode{\sphinxupquote{:}} signals the start of a block of code that is the “body
of the loop”, executed once in succession for each value that
\sphinxcode{\sphinxupquote{animal}} is assigned

\item {} 
The body of the loop here is just a single, indented line of
code, but in other cases - just as using while loops - there may
be more than one line of code.

\item {} 
The end of the loop body is indicated by returning to the same
level of the indentation as the \sphinxcode{\sphinxupquote{for ...}} line that started
the loop.

\end{itemize}

\end{itemize}


\section{Changing the Values in a List}
\label{\detokenize{lecture_notes/lec10_lists2:changing-the-values-in-a-list}}\begin{itemize}
\item {} 
What if we wanted to change the list?  We might consider copying
\sphinxcode{\sphinxupquote{cap\_animals}} back to \sphinxcode{\sphinxupquote{animals}} at the end of the code
sequence.

\item {} 
But this does not work if we wanted a function that capitalized all
strings in a list.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{capitalize\PYGZus{}list}\PYG{p}{(} \PYG{n}{names} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{cap\PYGZus{}names} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{names}\PYG{p}{:}
        \PYG{n}{cap\PYGZus{}names}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(} \PYG{n}{n}\PYG{o}{.}\PYG{n}{capitalize}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
    \PYG{n}{names} \PYG{o}{=} \PYG{n}{cap\PYGZus{}names}

\PYG{n}{animals} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{monkey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hawk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tiger}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{parrot}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{capitalize\PYGZus{}list}\PYG{p}{(}\PYG{n}{animals}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{animals}\PYG{p}{)}     \PYG{c+c1}{\PYGZsh{} Make sure you understand the output!!!}
\end{sphinxVerbatim}

\item {} 
This does not work because \sphinxcode{\sphinxupquote{names}} is an alias for the list
rather than the list itself!

\item {} 
The following does not work either because \sphinxcode{\sphinxupquote{n}} points to a string
in the list (and when string values are changed, a new string is
generated, effectively making \sphinxcode{\sphinxupquote{n}} a copy of the value):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{capitalize\PYGZus{}list}\PYG{p}{(} \PYG{n}{names} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{names}\PYG{p}{:}
        \PYG{n}{n} \PYG{o}{=} \PYG{n}{n}\PYG{o}{.}\PYG{n}{capitalize}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
So, based on what we know so far to actually change the values in
the list we need to use indexing together with a \sphinxcode{\sphinxupquote{while}} loop:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{capitalize\PYGZus{}list}\PYG{p}{(} \PYG{n}{names} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{names}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{names}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{names}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{capitalize}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\item {} 
We can also solve this using a \sphinxcode{\sphinxupquote{for}} loop and indexing, but for
this we need a \sphinxcode{\sphinxupquote{range}}

\end{itemize}


\section{Using \sphinxstyleliteralintitle{\sphinxupquote{range}}}
\label{\detokenize{lecture_notes/lec10_lists2:using-range}}\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{range}} “generates” values in a sequence, almost-but-not-quite
like a list.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

prints the values 0 through 4…

\item {} 
We can convert a range to an actual list:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{[0, 1, 2, 3, 4]}
\end{sphinxVerbatim}

\item {} 
The general form is

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{range}\PYG{p}{(} \PYG{n}{bi}\PYG{p}{,} \PYG{n}{ei}\PYG{p}{,} \PYG{n}{ii} \PYG{p}{)}
\end{sphinxVerbatim}

where
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{bi}} is the initial value (defaults to 0)

\item {} 
\sphinxcode{\sphinxupquote{ei}} is the ending value (never included in the range!)

\item {} 
\sphinxcode{\sphinxupquote{ii}} is the increment, added each time (defaults to 1)

\end{itemize}

\item {} 
We’ll look at number of examples:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Using \sphinxcode{\sphinxupquote{for}} loops on lists, we often use \sphinxcode{\sphinxupquote{len()}} in
combination with \sphinxcode{\sphinxupquote{range}} to specify the indices that should be
used.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{capitalize\PYGZus{}list}\PYG{p}{(} \PYG{n}{names} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{names}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{names}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{names}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{capitalize}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Now we have our \sphinxcode{\sphinxupquote{for}} loop based solution to capitalizing the
names in a list.

\item {} 
Unlike with a \sphinxcode{\sphinxupquote{while}} loop there is no need to write code to
compare our index / counter variable \sphinxcode{\sphinxupquote{i}} directly against the
bound and no need to write code to increment \sphinxcode{\sphinxupquote{i}}.

\item {} 
This use of \sphinxcode{\sphinxupquote{range}} to generate an index list is common
\begin{itemize}
\item {} 
When we want to change the integer, float or string values of a
list.

\item {} 
When we want to work with multiple lists at once.

\end{itemize}

\end{itemize}


\section{Part 2 Practice}
\label{\detokenize{lecture_notes/lec10_lists2:part-2-practice}}\begin{enumerate}
\item {} 
Recall our list

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{co2\PYGZus{}levels} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{320.03}\PYG{p}{,} \PYG{l+m+mf}{322.16}\PYG{p}{,} \PYG{l+m+mf}{328.07}\PYG{p}{,} \PYG{l+m+mf}{333.91}\PYG{p}{,} \PYG{l+m+mf}{341.47}\PYG{p}{,} \PYGZbs{}
  \PYG{l+m+mf}{348.92}\PYG{p}{,} \PYG{l+m+mf}{357.29}\PYG{p}{,} \PYG{l+m+mf}{363.77}\PYG{p}{,} \PYG{l+m+mf}{371.51}\PYG{p}{,} \PYG{l+m+mf}{382.47}\PYG{p}{,} \PYG{l+m+mf}{392.95} \PYG{p}{]}
\end{sphinxVerbatim}

For the purpose of this exercise only, please pretend the Python
\sphinxcode{\sphinxupquote{sum}} function does not exist, and then write a short section of
Python code that uses a \sphinxcode{\sphinxupquote{for}} loop to first compute and then
print the sum of the values in the \sphinxcode{\sphinxupquote{co2\_levels}} list.  You do not
need to use indexing.

\end{enumerate}


\section{Using Indices to “Slice” a List and Create a New List}
\label{\detokenize{lecture_notes/lec10_lists2:using-indices-to-slice-a-list-and-create-a-new-list}}\begin{itemize}
\item {} 
Recall

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{co2\PYGZus{}levels} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{320.03}\PYG{p}{,} \PYG{l+m+mf}{322.16}\PYG{p}{,} \PYG{l+m+mf}{328.07}\PYG{p}{,} \PYG{l+m+mf}{333.91}\PYG{p}{,} \PYG{l+m+mf}{341.47}\PYG{p}{,} \PYGZbs{}
  \PYG{l+m+mf}{348.92}\PYG{p}{,} \PYG{l+m+mf}{357.29}\PYG{p}{,} \PYG{l+m+mf}{363.77}\PYG{p}{,} \PYG{l+m+mf}{371.51}\PYG{p}{,} \PYG{l+m+mf}{382.47}\PYG{p}{,} \PYG{l+m+mf}{392.95} \PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
Now suppose we just want the values at indices 2, 3 and 4 of this in
a new list:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{three\PYGZus{}values} \PYG{o}{=} \PYG{n}{co2\PYGZus{}levels}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{three\PYGZus{}values}
\PYG{g+go}{[328.07, 333.91, 341.47]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{co2\PYGZus{}levels}
\PYG{g+go}{[ 320.03, 322.16, 328.07, 333.91, 341.47, 348.92, 357.29, 363.77,}
\PYG{g+go}{   371.51, 382.47, 392.95 ]}
\end{sphinxVerbatim}

\item {} 
We give the first index and one more than the last index we want

\item {} 
If we leave off the first index, 0 is assumed, and if we leave off
the second index, the length of the list is assumed.

\item {} 
Negative indices are allowed — they are just converted to their
associated positive values. Some examples:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dog}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hawk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tiger}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{parrot}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}
\PYG{g+go}{[\PYGZsq{}cat\PYGZsq{}, \PYGZsq{}dog\PYGZsq{}, \PYGZsq{}hawk\PYGZsq{}, \PYGZsq{}tiger\PYGZsq{}, \PYGZsq{}parrot\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{[\PYGZsq{}dog\PYGZsq{}, \PYGZsq{}hawk\PYGZsq{}, \PYGZsq{}tiger\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+go}{[\PYGZsq{}dog\PYGZsq{}, \PYGZsq{}hawk\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{g+go}{[]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{[]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{]}
\PYG{g+go}{[\PYGZsq{}dog\PYGZsq{}, \PYGZsq{}hawk\PYGZsq{}, \PYGZsq{}tiger\PYGZsq{}, \PYGZsq{}parrot\PYGZsq{}]}
\end{sphinxVerbatim}

\end{itemize}


\section{More on List Slicing}
\label{\detokenize{lecture_notes/lec10_lists2:more-on-list-slicing}}\begin{itemize}
\item {} 
Specifying indices for slicing and for a \sphinxcode{\sphinxupquote{range}} are very
similar:
\begin{itemize}
\item {} 
A \sphinxcode{\sphinxupquote{range}} uses () and is a generator, while slicing
using {[} {]} and is applied to a list to create a new list.

\end{itemize}

\item {} 
The most general form of slicing involves three values

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L}\PYG{p}{[}\PYG{n}{si}\PYG{p}{:}\PYG{n}{ei}\PYG{p}{:}\PYG{n}{inc}\PYG{p}{]}
\end{sphinxVerbatim}

where
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{L}} is the list

\item {} 
\sphinxcode{\sphinxupquote{si}} is the start index

\item {} 
\sphinxcode{\sphinxupquote{ei}} is the end index

\item {} 
\sphinxcode{\sphinxupquote{inc}} is the increment value

\end{itemize}

Any of the three values is optional

\item {} 
We’ll work through some examples in class to
\begin{itemize}
\item {} 
Use slicing to copy an entire list

\item {} 
Use negative increments and generate a reversed list

\item {} 
Extracting the even indexed values

\end{itemize}

\item {} 
Note: \sphinxcode{\sphinxupquote{L{[}:{]}}} returns a copy of the whole list of \sphinxcode{\sphinxupquote{L}}. This is
the same using method \sphinxcode{\sphinxupquote{L.copy()}} or the function \sphinxcode{\sphinxupquote{list()}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2} \PYG{o}{=} \PYG{n}{L1}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{monkey}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}
\PYG{g+go}{[\PYGZsq{}cat\PYGZsq{}, \PYGZsq{}dog\PYGZsq{}, \PYGZsq{}hawk\PYGZsq{}, \PYGZsq{}tiger\PYGZsq{}, \PYGZsq{}parrot\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}
\PYG{g+go}{[\PYGZsq{}cat\PYGZsq{}, \PYGZsq{}monkey\PYGZsq{}, \PYGZsq{}hawk\PYGZsq{}, \PYGZsq{}tiger\PYGZsq{}, \PYGZsq{}parrot\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L3} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L3}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{turtle}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}
\PYG{g+go}{[\PYGZsq{}cat\PYGZsq{}, \PYGZsq{}dog\PYGZsq{}, \PYGZsq{}hawk\PYGZsq{}, \PYGZsq{}tiger\PYGZsq{}, \PYGZsq{}parrot\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}
\PYG{g+go}{[\PYGZsq{}cat\PYGZsq{}, \PYGZsq{}monkey\PYGZsq{}, \PYGZsq{}hawk\PYGZsq{}, \PYGZsq{}tiger\PYGZsq{}, \PYGZsq{}parrot\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L3}
\PYG{g+go}{[\PYGZsq{}cat\PYGZsq{}, \PYGZsq{}turtle\PYGZsq{}, \PYGZsq{}hawk\PYGZsq{}, \PYGZsq{}tiger\PYGZsq{}, \PYGZsq{}parrot\PYGZsq{}]}
\end{sphinxVerbatim}

\end{itemize}


\section{Concatentation and Replication}
\label{\detokenize{lecture_notes/lec10_lists2:concatentation-and-replication}}\begin{itemize}
\item {} 
Just like with strings, concatenation and replication can be
applied to lists:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{+}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v}
\PYG{g+go}{[1,2,3,4,5]}
\end{sphinxVerbatim}

\item {} 
and

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{3}
\PYG{g+go}{[1,1,1]}
\end{sphinxVerbatim}

\end{itemize}


\section{Part 3 Practice}
\label{\detokenize{lecture_notes/lec10_lists2:part-3-practice}}\begin{enumerate}
\item {} 
What is the output of the following?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{x}
\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{n}{y}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Write a slicing command to extract values indexed
by 1, 4, 7, 10, etc from a list \sphinxcode{\sphinxupquote{L0}} .

\end{enumerate}


\section{Converting Strings to Lists}
\label{\detokenize{lecture_notes/lec10_lists2:converting-strings-to-lists}}\begin{itemize}
\item {} 
Version 1: use the function \sphinxcode{\sphinxupquote{list}} to create a list of the
characters in the string:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello world}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}H\PYGZsq{}, \PYGZsq{}e\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}o\PYGZsq{}, \PYGZsq{} \PYGZsq{}, \PYGZsq{}w\PYGZsq{}, \PYGZsq{}o\PYGZsq{}, \PYGZsq{}r\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}d\PYGZsq{}]}
\end{sphinxVerbatim}

\item {} 
Version 2:  use the string \sphinxcode{\sphinxupquote{split}} function, which breaks a string up into a
list of strings based on the character provided as the argument.
\begin{itemize}
\item {} 
The default is \sphinxcode{\sphinxupquote{' '}}:

\item {} 
Other common splitting characters are \sphinxcode{\sphinxupquote{','}}, \sphinxcode{\sphinxupquote{'\textbar{}'}} and
\sphinxcode{\sphinxupquote{'\textbackslash{}t'}}

\end{itemize}

\item {} 
We will play with the \sphinxcode{\sphinxupquote{s = "Hello world"}} example in class.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}Hello\PYGZsq{}, \PYGZsq{}world\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello     worl   d}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}Hello\PYGZsq{}, \PYGZsq{}worl\PYGZsq{}, \PYGZsq{}d\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}Hello\PYGZsq{}, \PYGZsq{}\PYGZsq{}, \PYGZsq{}\PYGZsq{}, \PYGZsq{}\PYGZsq{}, \PYGZsq{}\PYGZsq{}, \PYGZsq{}worl\PYGZsq{}, \PYGZsq{}\PYGZsq{}, \PYGZsq{}\PYGZsq{}, \PYGZsq{}d\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}He\PYGZsq{}, \PYGZsq{}\PYGZsq{}, \PYGZsq{}o     wor\PYGZsq{}, \PYGZsq{}   d\PYGZsq{}]}
\end{sphinxVerbatim}

\end{itemize}


\section{Converting Lists to Strings}
\label{\detokenize{lecture_notes/lec10_lists2:converting-lists-to-strings}}\begin{itemize}
\item {} 
What happens when we type the following?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello world}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\end{sphinxVerbatim}

This is will not concatenate all the strings in the list (assumming they are
strings).

\item {} 
We can write a \sphinxcode{\sphinxupquote{for}} loop to do this, but Python provides
something simpler that works:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{No}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{one}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{expects}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{the}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spanish}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Inquisition}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{NooneexpectstheSpanishInquisition}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{No one expects the Spanish Inquisition}
\end{sphinxVerbatim}

Can you infer from this the role of the string that the \sphinxcode{\sphinxupquote{join}} funciton
is applied to?

\end{itemize}


\section{Indexing and Slicing Strings}
\label{\detokenize{lecture_notes/lec10_lists2:indexing-and-slicing-strings}}\begin{itemize}
\item {} 
We can index strings:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello, world!}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{!}
\end{sphinxVerbatim}

\item {} 
We can apply all of the slicing operations to strings to create new
strings:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello, world!}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{p}{[}\PYG{p}{:}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}Hlo ol!\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
Unlike lists, however, we can not use indexing to replace individual
characters in strings:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{\PYGZlt{}module\PYGZgt{}}
\PYG{g+gr}{TypeError}: \PYG{n}{\PYGZsq{}str\PYGZsq{} object does not support item assignment}
\end{sphinxVerbatim}

\end{itemize}


\section{Part 4 Practice}
\label{\detokenize{lecture_notes/lec10_lists2:part-4-practice}}\begin{enumerate}
\item {} 
Given a list

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dog}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tiger}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lion}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
\end{sphinxVerbatim}

Rewrite \sphinxcode{\sphinxupquote{L}} so that it is a list of lists, with household pets in
the 0th (sub)list, zoo animals in the first.  Using slicing of
\sphinxcode{\sphinxupquote{L}} to create this new list and assign L to the result.

\item {} 
How can you append an additional list of farm animals (e.g.
\sphinxcode{\sphinxupquote{'horse'}}, \sphinxcode{\sphinxupquote{'pig'}} and \sphinxcode{\sphinxupquote{'cow'}}) to \sphinxcode{\sphinxupquote{L}}?

\item {} 
Write code to remove \sphinxcode{\sphinxupquote{'tiger'}} from the sublist of zoo animals.

\item {} 
Suppose you have the string

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cat \textbar{}  dog  \textbar{} mouse \textbar{} rat}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

and you’d like to have the list of strings

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dog}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mouse}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

Splitting the list alone does not solve the problem. Instead, you
need to use a combination of splitting, and a loop that strips off
the extra space characters from each string and appends to the final
result. Write this code. It should be at most 4-5 lines of Python.

\end{enumerate}


\section{Summary}
\label{\detokenize{lecture_notes/lec10_lists2:summary}}\begin{itemize}
\item {} 
Assignment of lists and passing of lists as parameters creates
aliases of lists rather than copies.

\item {} 
We use \sphinxcode{\sphinxupquote{for}} loops to iterate through a list to work on each enty
in the list.

\item {} 
We need to combine \sphinxcode{\sphinxupquote{for}} loops with indices generated by a
\sphinxcode{\sphinxupquote{range}} in order to change the contents of a list of integers,
floats or strings.  These indices are also used to work with
multiple lists at once.

\item {} 
Concatentation, replication and slicing create new lists.

\item {} 
Most other list functions that modify a list do so without creating a
new list: insert, sort, append, pop, etc.

\item {} 
Strings may be indexed and sliced, but indexing may not be used to
change a string.

\item {} 
Conversion of a string to a list is accomplished using either
\sphinxcode{\sphinxupquote{list}} or \sphinxcode{\sphinxupquote{split}}; conversion of a list of strings to a string
uses \sphinxcode{\sphinxupquote{join}}.

\end{itemize}


\section{Additional Review Exercises: What Does Python Output?}
\label{\detokenize{lecture_notes/lec10_lists2:additional-review-exercises-what-does-python-output}}\begin{enumerate}
\item {} 
Without typing into the Python interpreter, find the outputs from
the following operations:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{x}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{...}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{=}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}
\end{sphinxVerbatim}

\item {} 
What about these operations?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y}


\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dog}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pig}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ant}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z1} \PYG{o}{=} \PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z1}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z}
\end{sphinxVerbatim}

\item {} 
Write a function that returns a list containing the smallest and
largest values in the list that is passed to it as an argument
\sphinxstyleemphasis{without changing the list}? Can you think of several ways to do
this?
\begin{enumerate}
\item {} 
Using \sphinxcode{\sphinxupquote{min}} and \sphinxcode{\sphinxupquote{max}}

\item {} 
Using sorting (but remember, you can’t change the original list)

\item {} 
Using a \sphinxcode{\sphinxupquote{for}} loop that searches for the smallest and largest
values.

\end{enumerate}

\end{enumerate}


\chapter{Lecture 10 — Exercises}
\label{\detokenize{lecture_notes/lec10_lists2_exercises/exercises:lecture-10-exercises}}\label{\detokenize{lecture_notes/lec10_lists2_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for grading.
A separate file must submitted for each problem.
Due date is 4 pm on Tuesday, October 27th.
\begin{enumerate}
\item {} 
Submit a text file showing the output of the following code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L1} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hello}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
\PYG{n}{L2} \PYG{o}{=} \PYG{n}{L1}
\PYG{n}{L3} \PYG{o}{=} \PYG{n}{L1}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{L2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(} \PYG{l+m+mi}{4} \PYG{p}{)}
\PYG{n}{L1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(} \PYG{l+m+mi}{3} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L2}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L3}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Submit a text file showing the output of the following code

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{head\PYGZus{}and\PYGZus{}tail}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{from\PYGZus{}back} \PYG{o}{=} \PYG{n}{L}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{from\PYGZus{}front} \PYG{o}{=} \PYG{n}{L}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{L}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{from\PYGZus{}front}\PYG{p}{)}
    \PYG{n}{L}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{from\PYGZus{}back}\PYG{p}{)}

\PYG{n}{L1} \PYG{o}{=} \PYG{p}{[} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{3} \PYG{p}{]}
\PYG{n}{L3} \PYG{o}{=} \PYG{n}{L1}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{L2} \PYG{o}{=} \PYG{n}{L1}
\PYG{n}{L2}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{L2}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{head\PYGZus{}and\PYGZus{}tail}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{L1}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{L2}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L2}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L3}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{L3}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
The solution to this problem and the two that follow should start
with the assignment

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{co2\PYGZus{}levels} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{320.03}\PYG{p}{,} \PYG{l+m+mf}{322.16}\PYG{p}{,} \PYG{l+m+mf}{328.07}\PYG{p}{,} \PYG{l+m+mf}{333.91}\PYG{p}{,} \PYG{l+m+mf}{341.47}\PYG{p}{,} \PYGZbs{}
               \PYG{l+m+mf}{348.92}\PYG{p}{,} \PYG{l+m+mf}{357.29}\PYG{p}{,} \PYG{l+m+mf}{363.77}\PYG{p}{,} \PYG{l+m+mf}{371.51}\PYG{p}{,} \PYG{l+m+mf}{382.47}\PYG{p}{,} \PYG{l+m+mf}{392.95} \PYG{p}{]}
\end{sphinxVerbatim}

Write a Python program that prints the number of values that are greater
than the average of the list.  For this you may use Python’s
\sphinxcode{\sphinxupquote{sum}} and \sphinxcode{\sphinxupquote{len}} functions and you must use a \sphinxcode{\sphinxupquote{for}} loop.  Do
NOT use a \sphinxcode{\sphinxupquote{range,}} however, and do not use indexing.

Your output should simply be:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Average}\PYG{p}{:} \PYG{l+m+mf}{351.14}
\PYG{n}{Num} \PYG{n}{above} \PYG{n}{average}\PYG{p}{:} \PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\item {} 
Suppose we discovered that the measurement of CO2 values was
uniformly too low by a small fraction \sphinxcode{\sphinxupquote{p}}.  Write a function that
increases each value in \sphinxcode{\sphinxupquote{co2\_levels}} by the fraction \sphinxcode{\sphinxupquote{p}}.  (In
other words if \sphinxcode{\sphinxupquote{x}} is the value before the increase then
\sphinxcode{\sphinxupquote{x*(1+p)}} is the value after.)  For this problem you need to use
a \sphinxcode{\sphinxupquote{range}}, \sphinxcode{\sphinxupquote{len()}} and indexing.  Start by asking the user for the
percentage.  Output the first and last values of the revised list.
Your program should end with the lines

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{First: }\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{co2\PYGZus{}levels}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Last: }\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{co2\PYGZus{}levels}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Here is an example of running your program:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Enter} \PYG{n}{the} \PYG{n}{fraction}\PYG{p}{:} \PYG{l+m+mf}{0.03}
\PYG{n}{First}\PYG{p}{:} \PYG{l+m+mf}{329.63}
\PYG{n}{Last}\PYG{p}{:} \PYG{l+m+mf}{404.74}
\end{sphinxVerbatim}

\item {} 
Write a function called \sphinxcode{\sphinxupquote{is\_increasing}} that returns \sphinxcode{\sphinxupquote{True}} if
the values in the list it is passed are in increasing order and
\sphinxcode{\sphinxupquote{False}} otherwise.  Use a \sphinxcode{\sphinxupquote{for}} loop and indexing to accomplish
this.  Test the function with the following main code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{co2\PYGZus{}levels is increasing: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{is\PYGZus{}increasing}\PYG{p}{(}\PYG{n}{co2\PYGZus{}levels}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{test\PYGZus{}L1} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{45} \PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test\PYGZus{}L1 is increasing: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{is\PYGZus{}increasing}\PYG{p}{(}\PYG{n}{test\PYGZus{}L1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{test\PYGZus{}L2} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{arc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{circle}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{diameter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{radius}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{volume}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{area}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test\PYGZus{}L2 is increasing: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{is\PYGZus{}increasing}\PYG{p}{(}\PYG{n}{test\PYGZus{}L2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{test\PYGZus{}L3} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{28}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{31}\PYG{p}{,} \PYG{l+m+mi}{45} \PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test\PYGZus{}L3 is increasing: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{is\PYGZus{}increasing}\PYG{p}{(}\PYG{n}{test\PYGZus{}L3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

These should be the only \sphinxcode{\sphinxupquote{print()}} function calls in the code
you submit.

\end{enumerate}


\chapter{Lecture 11 — Decisions Part 2}
\label{\detokenize{lecture_notes/lec11_conditionals2:lecture-11-decisions-part-2}}\label{\detokenize{lecture_notes/lec11_conditionals2::doc}}

\section{Overview — Logic and Decision Making, part 2}
\label{\detokenize{lecture_notes/lec11_conditionals2:overview-logic-and-decision-making-part-2}}\begin{itemize}
\item {} 
Program structure

\item {} 
Debugging and “hardening” a simple function

\item {} 
A bit of design and a bit of a random walk

\item {} 
More on logic - the key to getting programs right
\begin{itemize}
\item {} 
Boolean logic

\item {} 
Nested if statements

\item {} 
Assigning boolean variables

\end{itemize}

\end{itemize}


\section{Part 1: Program Structure}
\label{\detokenize{lecture_notes/lec11_conditionals2:part-1-program-structure}}
Programming requires four basic skills:
\begin{enumerate}
\item {} 
Develop a solution.
\begin{itemize}
\item {} 
Start with small steps, solve them, and then add complexity

\end{itemize}

\item {} 
Structure your code.
\begin{itemize}
\item {} 
Move repeated code into functions

\item {} 
Make your code easy to read and modify. Use meaningful variable names
and break complex operations into smaller parts.

\item {} 
Place values in variables so they are easy to change.

\item {} 
Include comments for important functions, but do not clutter
your code with unnecessary comments.  A classic example of a
completely unnecessary comment is

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}   \PYG{c+c1}{\PYGZsh{} increment x}
\end{sphinxVerbatim}

\item {} 
Document assumptions about what is passed to a function.

\item {} 
If your function is meant to return a value, make sure it always
does.

\end{itemize}

\item {} 
Test your code.
\begin{itemize}
\item {} 
Find all possible cases that your program should handle, including typos
in the input.  As
programs get larger, this is increasingly hard.

\item {} 
If you cannot check for all inputs, then you must then check your code
for meaningful inputs: regular (expected inputs) and edge cases (inputs
that can break your code).

\end{itemize}

\item {} 
Debug your code.
\begin{itemize}
\item {} 
Never assume an untested part of your code is bug free. “If it ain’t tested, it’s broken.”

\item {} 
Learn syntax well so that you can spot and fix syntax errors
fast.

\item {} 
Semantic errors are much harder to find and fix. You need
strategies to isolate where the error is.

\item {} 
Print output before and after crucial steps.

\item {} 
Look at where your program crashed.

\item {} 
Fix the first error first, not the biggest error.  The first
error may be the cause of bigger errors later in your code.

\item {} 
Use a debugger.

\item {} 
Simplify the problem: remove (by commenting out) parts of your
code until you no longer have an error.  Look at the last code
removed for a source of at least part of your errors.

\item {} 
Test parts of your code separately and once you are convinced
they are bug free, concentrate on other parts.

\end{itemize}

\end{enumerate}


\section{Help with debugging}
\label{\detokenize{lecture_notes/lec11_conditionals2:help-with-debugging}}\begin{itemize}
\item {} 
Consider the following code to add the first \sphinxcode{\sphinxupquote{n}} integers:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter a positive integer ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{n}\PYG{p}{:}
    \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}
    \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sum is}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{total}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Does it work?  For all inputs?  Might it run forever?  (We’ll
ignore the fact that a \sphinxcode{\sphinxupquote{for}} loop would be better here.)

\item {} 
How might we find such an error?
\begin{itemize}
\item {} 
Careful reading of the code

\item {} 
Insert print statements

\item {} 
Use the Wing IDE debugger.

\end{itemize}

\item {} 
We will practice with the Wing IDE debugger in class, using it to
understand the behavior of the program. We will explain the following
picture

\noindent\sphinxincludegraphics{{debugger}.png}

and note the use of
\begin{itemize}
\item {} 
The hand, bug and stop symbols on the top of the display, and

\item {} 
The Debug I/O and Stack Data at the bottom of the display.

\end{itemize}

\item {} 
Debugging becomes crucial in tracking logic errors as well.

\end{itemize}


\section{Program organization}
\label{\detokenize{lecture_notes/lec11_conditionals2:program-organization}}\begin{itemize}
\item {} 
Envision your code as having two main parts: the main body and the
functions that help the main code.

\item {} 
Make sure your functions accomplish one well-defined task.  This
makes them both easy to test and useful in many places.

\item {} 
As we will see in an example below, in Python it is good practice to
separate the functions and the main body with the following
addition to the program structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} Put the main body of the program below this line}
\end{sphinxVerbatim}

\item {} 
This will have no apparent effect when a program is run.
However, if a program is imported as a module into another program
(like the utility code we have been giving you), any code within the
above \sphinxcode{\sphinxupquote{if}} block is skipped!

\item {} 
This allows programs to work both as modules and stand alone
code.

\item {} 
When the primary purpose of your code is to provide functionality
as a module, it is best to use the code in the main body to test
the module functions.

\end{itemize}


\section{Part 2:  Extended Example of a Random Walk}
\label{\detokenize{lecture_notes/lec11_conditionals2:part-2-extended-example-of-a-random-walk}}\begin{itemize}
\item {} 
Many numerical simulations, including many video games, involve random
events.

\item {} 
Python includes a module to generate numbers at random. For
example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}

\PYG{c+c1}{\PYGZsh{} Print three numbers randomly generated between 0 and 1.}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Print a random integer in the range 0..5}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We’d like to use this to simulate a “random walk”:
\begin{itemize}
\item {} 
Hypothetically, a person takes a step forward or backward,
completely at random (equally likely to go either way).  This
can be repeated over and over again until some stopping point is
reached.

\item {} 
Suppose the person is on a platform with \(N\) steps and the person
starts in the middle, this random forward/backward stepping
process is repeated until they fall off (reach step 0 or step
\(N+1\))
\begin{itemize}
\item {} 
“forward” is represented by an increasing step, while
“backward” is represented by a decreasing step

\end{itemize}

\item {} 
How many steps does it take to fall off?

\end{itemize}

\item {} 
Many variations on this problem appear in physical simulations.

\item {} 
We can simulate a step in several ways:
\begin{enumerate}
\item {} 
If \sphinxcode{\sphinxupquote{random.random()}} returns a value less than 0.5 step backward;
otherwise step forward.

\item {} 
If \sphinxcode{\sphinxupquote{random.randint(0,1)}} returns 1 then step forward; otherwise,
step backward.

\item {} 
Eliminate the \sphinxcode{\sphinxupquote{if}} entirely and just increment by whatever \sphinxcode{\sphinxupquote{random.choice({[}-1,1{]})}}
returns (it will return either -1 (step backward) or 1 (step forward)).

\end{enumerate}

\item {} 
So, in summary, we want to start a random walk at position \(N/2\) and
repeatedly take a step forward or backward based on the
output of the random number generator until the walker falls off.

\item {} 
We will solve this problem together during lecture.
We we start by enumerating some of the needed steps and then
solving them individually before putting together the whole
program.
\begin{itemize}
\item {} 
Once we see the result we can think of several ways to change
things and explore new questions and ideas.  Remember, a program
is never done!

\end{itemize}

\end{itemize}


\section{Part 3:  Review of Boolean Logic}
\label{\detokenize{lecture_notes/lec11_conditionals2:part-3-review-of-boolean-logic}}\begin{itemize}
\item {} 
Invented / discovered by George Boole in the 1840’s to reduce
classical logic to an algebra
\begin{itemize}
\item {} 
This was a crucial mathematical step on the road to computation
and computers

\end{itemize}

\item {} 
Values (in Python) are \sphinxcode{\sphinxupquote{True}} and \sphinxcode{\sphinxupquote{False}}

\item {} 
Operators
\begin{itemize}
\item {} 
Comparisons: \sphinxcode{\sphinxupquote{\textless{}, \textgreater{}, \textless{}=, \textgreater{}=, == !=}}

\item {} 
Logic: \sphinxcode{\sphinxupquote{and}}, \sphinxcode{\sphinxupquote{or}}, \sphinxcode{\sphinxupquote{not}}

\end{itemize}

\end{itemize}


\section{Truth Tables}
\label{\detokenize{lecture_notes/lec11_conditionals2:truth-tables}}\begin{itemize}
\item {} 
Aside to recall the syntax: \sphinxcode{\sphinxupquote{and, or, not}} are lower case!

\item {} 
If we have two boolean expressions, which we will refer to as \sphinxcode{\sphinxupquote{ex1}}
and \sphinxcode{\sphinxupquote{ex2}}, and if we combine their “truth” values using \sphinxcode{\sphinxupquote{and}} we
have the following “truth table” to describe the result


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{ex1}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{ex2}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{ex1 and ex2}}
\\
\hline
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{False}}
\\
\hline
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{False}}
\\
\hline
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{False}}
\\
\hline
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{True}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\item {} 
If we combine the two expressions using \sphinxcode{\sphinxupquote{or}}, we have


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{ex1}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{ex2}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{ex1 or ex2}}
\\
\hline
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{False}}
\\
\hline
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{True}}
\\
\hline
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{True}}
\\
\hline
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{True}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\item {} 
Finally, using \sphinxcode{\sphinxupquote{not}} we have


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{ex1}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{not ex1}}
\\
\hline
\sphinxcode{\sphinxupquote{False}}
&
\sphinxcode{\sphinxupquote{True}}
\\
\hline
\sphinxcode{\sphinxupquote{True}}
&
\sphinxcode{\sphinxupquote{False}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\end{itemize}


\section{DeMorgan’s Laws Relating and, or, not}
\label{\detokenize{lecture_notes/lec11_conditionals2:demorgans-laws-relating-and-or-not}}\begin{itemize}
\item {} 
Using \sphinxcode{\sphinxupquote{ex1}} and \sphinxcode{\sphinxupquote{ex2}} once again to represent boolean
expressions, we have

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{ex1} \PYG{o+ow}{and} \PYG{n}{ex2}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{ex1}\PYG{p}{)} \PYG{o+ow}{or} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{ex2}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
And,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{ex1} \PYG{o+ow}{or} \PYG{n}{ex2}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{ex1}\PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{ex2}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Also, distribution laws

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ex1} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{ex2} \PYG{o+ow}{or} \PYG{n}{ex3}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{n}{ex1} \PYG{o+ow}{and} \PYG{n}{ex2}\PYG{p}{)} \PYG{o+ow}{or} \PYG{p}{(}\PYG{n}{ex1} \PYG{o+ow}{and} \PYG{n}{ex3}\PYG{p}{)}
\PYG{n}{ex1} \PYG{o+ow}{or} \PYG{p}{(}\PYG{n}{ex2} \PYG{o+ow}{and} \PYG{n}{ex3}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{n}{ex1} \PYG{o+ow}{or} \PYG{n}{ex2}\PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{ex1} \PYG{o+ow}{or} \PYG{n}{ex3}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We can prove these using truth tables.

\end{itemize}


\section{Why Do We Care?}
\label{\detokenize{lecture_notes/lec11_conditionals2:why-do-we-care}}\begin{itemize}
\item {} 
When we’ve written logical expressions into our programs, it no
longer matters what we intended; it matters what the logic actually
does.

\item {} 
For complicated boolean expressions, we may need to almost prove that
they are correct

\end{itemize}


\section{Part 4: Additional Techniques in Logic and Decision Making}
\label{\detokenize{lecture_notes/lec11_conditionals2:part-4-additional-techniques-in-logic-and-decision-making}}
We will examine:
\begin{itemize}
\item {} 
Short-ciruiting

\item {} 
Nested conditionals

\item {} 
Storing the result of boolean expressions in variables

\end{itemize}

and then apply them to several problems


\section{Short-Circuited Boolean Expressions}
\label{\detokenize{lecture_notes/lec11_conditionals2:short-circuited-boolean-expressions}}\begin{itemize}
\item {} 
Python only evaluates expressions as far as needed to make a
decision.

\item {} 
Therefore, in a boolean expression of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ex1} \PYG{o+ow}{and} \PYG{n}{ex2}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{ex2}} will not be evaluated if \sphinxcode{\sphinxupquote{ex1}} evaluates to \sphinxcode{\sphinxupquote{False}}.
Think about why.

\item {} 
Also, in a boolean expression of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ex1} \PYG{o+ow}{or} \PYG{n}{ex2}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{ex2}} will not be evaluated if \sphinxcode{\sphinxupquote{ex1}} evalues to \sphinxcode{\sphinxupquote{True}}.

\item {} 
This “short-circuiting” is common across many programming languages.

\end{itemize}


\section{Nested If Statements}
\label{\detokenize{lecture_notes/lec11_conditionals2:nested-if-statements}}\begin{itemize}
\item {} 
We can place \sphinxcode{\sphinxupquote{if}} statements inside of other \sphinxcode{\sphinxupquote{if}} statements.

\item {} 
To illustrate, consider the following where \sphinxcode{\sphinxupquote{ex1}}, \sphinxcode{\sphinxupquote{ex2}},
\sphinxcode{\sphinxupquote{ex3}} and \sphinxcode{\sphinxupquote{ex4}} are all boolean expressions, and \sphinxcode{\sphinxupquote{blockA}},
\sphinxcode{\sphinxupquote{blockB}}, \sphinxcode{\sphinxupquote{blockD}} and \sphinxcode{\sphinxupquote{blockE}} are sections of code.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{ex1}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{ex2}\PYG{p}{:}
       \PYG{n}{blockA}
    \PYG{k}{elif} \PYG{n}{ex3}\PYG{p}{:}
       \PYG{n}{blockB}
\PYG{k}{elif} \PYG{n}{ex4}\PYG{p}{:}
    \PYG{n}{blockD}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{blockE}
\end{sphinxVerbatim}

\item {} 
We will examine this example in class and answer the following
questions:
\begin{itemize}
\item {} 
Under what conditions is each block executed?

\item {} 
Is it possible that no blocks are executed?

\item {} 
What is the equivalent non-nested if-elif-else structure?

\end{itemize}

\end{itemize}


\section{Storing the Result of a Boolean Expression}
\label{\detokenize{lecture_notes/lec11_conditionals2:storing-the-result-of-a-boolean-expression}}\begin{itemize}
\item {} 
Sometimes we store the result of boolean expressions in a variable
for later use:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter a Fahrenheit temperature: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{is\PYGZus{}below\PYGZus{}freezing} \PYG{o}{=} \PYG{n}{f} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{32.0}
\PYG{k}{if} \PYG{n}{is\PYGZus{}below\PYGZus{}freezing}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Brrr.  It is cold}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We use this to
\begin{itemize}
\item {} 
Make code clearer

\item {} 
Avoid repeated evaluation of the same expression, especially if
the expression requires a lot of computation.

\end{itemize}

\end{itemize}


\section{Examples for Lecture}
\label{\detokenize{lecture_notes/lec11_conditionals2:examples-for-lecture}}
We will work on the following examples during class, as time permits.
\begin{enumerate}
\item {} 
In the following code, for what values of \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}} does the
code print 1, for what values does the code print 2, and for what
values does the code print nothing at all?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{5} \PYG{o+ow}{and} \PYG{n}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{5} \PYG{o+ow}{or} \PYG{n}{y}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{2}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{y}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{3} \PYG{o+ow}{or} \PYG{n}{z}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{3}\PYG{p}{:}
            \PYG{n+nb}{print} \PYG{l+m+mi}{1}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

The moral of the story is that you should be careful to ensure that
your logic and if structures \sphinxstylestrong{cover the entire range of
possibilities}!

\item {} 
Doctors sometimes assess a patient’s risk of heart disease in terms of a
combination of the BMI (body mask index) and age using the following
table:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
Age \(\leq 45\)
&\sphinxstyletheadfamily 
Age \(> 45\)
\\
\hline
BMI \(< 22.0\)
&
Low
&
Medium
\\
\hline
BMI \(\geq 22.0\)
&
Medium
&
High
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Assuming the values for a patient are stored in variables \sphinxcode{\sphinxupquote{age}} and
\sphinxcode{\sphinxupquote{bmi}}, we can write the following code

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{slim} \PYG{o}{=} \PYG{n}{bmi} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{22.0}
\PYG{n}{young} \PYG{o}{=} \PYG{n}{age} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{45}
\end{sphinxVerbatim}

We will work out two different ways of printing \sphinxstyleemphasis{Low}, \sphinxstyleemphasis{Medium} or
\sphinxstyleemphasis{High} according to the table based on the values of the boolean
variables \sphinxcode{\sphinxupquote{slim}} and \sphinxcode{\sphinxupquote{young}}.

\item {} 
Challenge example:  Suppose two rectangles are determined by their
corner points - \sphinxcode{\sphinxupquote{(x0,y0)}} and \sphinxcode{\sphinxupquote{(x1,y1)}} for one rectangle and
\sphinxcode{\sphinxupquote{(u0,v0)}} and \sphinxcode{\sphinxupquote{(u1,v1)}} for the other.  Write a function that
takes these four tuples as arguments and returns \sphinxcode{\sphinxupquote{True}} when the
two rectangles intersect and \sphinxcode{\sphinxupquote{False}} otherwise.

\end{enumerate}


\section{Summary of Discussion of If Statements and Logic}
\label{\detokenize{lecture_notes/lec11_conditionals2:summary-of-discussion-of-if-statements-and-logic}}\begin{itemize}
\item {} 
Logic is a crucial component of every program.

\item {} 
Basic rules of logic, including DeMorgan’s laws, help us to write and
understand boolean expressions.

\item {} 
It sometimes requires careful, precise thinking, even at the level of
a proof, to ensure logical expressions and if statement structures
are correct.
\begin{itemize}
\item {} 
Many bugs in supposedly-working programs are caused by conditions
that the programmers did not fully consider.

\end{itemize}

\item {} 
If statements can be structured in many ways, sometimes nested several
levels deep.
\begin{itemize}
\item {} 
Nesting deeply can lead to confusing code, however.

\item {} 
Warning specifically for Python: you can easily change the meaning of
your program by accidentally changing indentation. It is very
hard to debug these changes.

\end{itemize}

\item {} 
Using variables to store boolean values can make code easier to
understand and avoids repeated tests.

\item {} 
Make sure your logic and resulting expressions cover the universe of
possibilities!

\end{itemize}


\chapter{Lecture 11 — Exercises}
\label{\detokenize{lecture_notes/lec11_conditionals_exercises/exercises:lecture-11-exercises}}\label{\detokenize{lecture_notes/lec11_conditionals_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for grading.
A separate file must submitted for each problem.  Solutions must be
submitted by 4 pm on Friday February 23.
\begin{enumerate}
\item {} 
Suppose you have a tuple that stores the semester and year a course
was taken, as in

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{when} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spring}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2015}\PYG{p}{)}
\end{sphinxVerbatim}

Write a function called \sphinxcode{\sphinxupquote{earlier\_semester()}} that takes two
such tuples as arguments and returns \sphinxcode{\sphinxupquote{True}} if the first tuple
represents an earlier semester and \sphinxcode{\sphinxupquote{False}} otherwise. The
possible semesters are \sphinxcode{\sphinxupquote{'Spring'}} and \sphinxcode{\sphinxupquote{'Fall'}}.  (Just to be
clear, Fall 2013 is later than Spring 2013.) Test it using the
following main code (you can cut-and-paste from the browser), which
should be your only print function calls.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Insert your function def here...}

\PYG{n}{w1} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spring}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2015}\PYG{p}{)}
\PYG{n}{w2} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Spring}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2014}\PYG{p}{)}
\PYG{n}{w3} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fall}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2014}\PYG{p}{)}
\PYG{n}{w4} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fall}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2015}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ earlier than }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{? }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{earlier\PYGZus{}semester}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,}\PYG{n}{w2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ earlier than }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{? }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{earlier\PYGZus{}semester}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,}\PYG{n}{w1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ earlier than }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{? }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w4}\PYG{p}{,} \PYG{n}{earlier\PYGZus{}semester}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,}\PYG{n}{w4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ earlier than }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{? }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{w4}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{earlier\PYGZus{}semester}\PYG{p}{(}\PYG{n}{w4}\PYG{p}{,}\PYG{n}{w1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ earlier than }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{? }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{w3}\PYG{p}{,} \PYG{n}{w4}\PYG{p}{,} \PYG{n}{earlier\PYGZus{}semester}\PYG{p}{(}\PYG{n}{w3}\PYG{p}{,}\PYG{n}{w4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ earlier than }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{? }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w3}\PYG{p}{,} \PYG{n}{earlier\PYGZus{}semester}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,}\PYG{n}{w3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Suppose three siblings, \sphinxcode{\sphinxupquote{Dale}}, \sphinxcode{\sphinxupquote{Erin}} and \sphinxcode{\sphinxupquote{Sam}}, have
heights \sphinxcode{\sphinxupquote{hd}}, \sphinxcode{\sphinxupquote{he}} and \sphinxcode{\sphinxupquote{hs}}, respectively.  Write a program
that reads in integer values of their heights and outputs
the ordering from tallest to shortest.  (For simplicity of
this exercises, you may assume that the three heights you will be
given are all different.)  Try writing your solution using nested
if statements and trying writing it without nested if statements;
either is acceptable on Submitty and trying both is good practice.
Here is an example as the code would look on Submitty.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Enter} \PYG{n}{Dale}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s height: 124}
\PYG{n}{Enter} \PYG{n}{Erin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s height: 112}
\PYG{n}{Enter} \PYG{n}{Sam}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s height: 119}
\PYG{n}{Dale}
\PYG{n}{Sam}
\PYG{n}{Erin}
\end{sphinxVerbatim}

\end{enumerate}


\chapter{Lecture 12 — Controlling Loops}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:lecture-12-controlling-loops}}\label{\detokenize{lecture_notes/lec12_loops2_for_double::doc}}

\section{Restatement of the Basics}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:restatement-of-the-basics}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{for}} loops tend to have a fixed number of iterations computed at
the start of the loop

\item {} 
\sphinxcode{\sphinxupquote{while}} loops tend to have an indefinite termination, determined by
the conditions of the data

\item {} 
Most Python \sphinxcode{\sphinxupquote{for}} loops are easily rewritten as \sphinxcode{\sphinxupquote{while}} loops,
but not vice-versa.
\begin{itemize}
\item {} 
In other programming languages, \sphinxcode{\sphinxupquote{for}} and \sphinxcode{\sphinxupquote{while}} are almost
interchangeable, at least in principle.

\end{itemize}

\end{itemize}


\section{Overview of Today}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:overview-of-today}}\begin{itemize}
\item {} 
Ranges and control of loop iterations

\item {} 
Nested loops

\item {} 
Lists of lists

\item {} 
Contolling loops through \sphinxcode{\sphinxupquote{break}} and \sphinxcode{\sphinxupquote{continue}}

\end{itemize}

Reading: \sphinxstyleemphasis{Practical Programming}, rest of Chapter 9.


\section{Part 1: Ranges and For Loops— A Review}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:part-1-ranges-and-for-loops-a-review}}\begin{itemize}
\item {} 
A range is a function to generate a sequence of integers:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

outputs the digits 0 through 9 in succession, one per line.
\begin{itemize}
\item {} 
Remember that this is up to and \sphinxstylestrong{not including} the end
value specified!

\end{itemize}

\item {} 
A range is not quite a list — instead it generates values for each
successive iteration of a \sphinxcode{\sphinxupquote{for}} loop.
\begin{itemize}
\item {} 
For now we will convert each range to a list as the basis for
studying them.

\end{itemize}

\item {} 
If we want to start with something other than 0, we provide two
integer values

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[3, 4, 5, 6, 7]}
\end{sphinxVerbatim}

\item {} 
With a third integer values we can create increments. For example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[4, 7, 10, 13, 16, 19]}
\end{sphinxVerbatim}

starts at 4, increments by 3, stops when 20 is reached or surpassed.

\item {} 
We can create backwards increments

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZhy{}1, \PYGZhy{}2, \PYGZhy{}3, \PYGZhy{}4, \PYGZhy{}5, \PYGZhy{}6, \PYGZhy{}7, \PYGZhy{}8, \PYGZhy{}9]}
\end{sphinxVerbatim}

\end{itemize}


\section{Using Ranges in For Loops}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:using-ranges-in-for-loops}}\begin{itemize}
\item {} 
We can use the \sphinxcode{\sphinxupquote{range}} to generate the sequence of loop variable
values in a for loop. Our first example is printing the contents of
the \sphinxcode{\sphinxupquote{planets}} list

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{planets} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mercury}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Venus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Earth}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mars}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jupiter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Saturn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Uranus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neptune}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Pluto}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{planets}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{planets}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

(In this case we don’t need a index variable - we can just iterate
over the values in the list.)

\item {} 
The variable \sphinxcode{\sphinxupquote{i}} is variously known as the \sphinxstyleemphasis{index} or the \sphinxstyleemphasis{loop}
index variable or the subscript.

\item {} 
We will modify the loop in class to do the following:
\begin{itemize}
\item {} 
Print the indices of the planets (starting at 1!)

\item {} 
Print the planets backward.

\item {} 
Print every other planet.

\end{itemize}

\end{itemize}


\section{Loops That Do Not Iterate Over All Indices}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:loops-that-do-not-iterate-over-all-indices}}\begin{itemize}
\item {} 
Sometimes the loop index should not go over the entire range of
indices, and we need to think about where to stop it \sphinxstyleemphasis{early}, as the
next example shows.

\item {} 
Example: Returning to our example from Lecture 1, we will briefly
re-examine our solution to the following problem: Given a string,
how can we write a function that decides if it has three
consecutive double letters?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{has\PYGZus{}three\PYGZus{}doubles}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{==} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o+ow}{and} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{==} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o+ow}{and} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{==} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{:}
            \PYG{k}{return} \PYG{k+kc}{True}
    \PYG{k}{return} \PYG{k+kc}{False}
\end{sphinxVerbatim}

\item {} 
We have to think carefully about where to start our looping and
where to stop!

\item {} 
Refer back to Lecture 10 for further examples

\end{itemize}


\section{Part 1 Practice}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:part-1-practice}}
We will only go over a few of these in class, but you should be sure
you can handle all of them
\begin{enumerate}
\item {} 
Generate a range for the positive integers less than 100. Use this to
calculate the sum of these values, with and without (i.e. use
\sphinxcode{\sphinxupquote{sum}}) a for loop.

\item {} 
Use a range and a for loop to print the positive, even numbers less than the
integer value associated with \sphinxcode{\sphinxupquote{n}}.

\item {} 
Suppose we want a list of the squares of the digits 0..9. The
following does NOT work

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{squares} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{s} \PYG{o+ow}{in} \PYG{n}{squares}\PYG{p}{:}
    \PYG{n}{s} \PYG{o}{=} \PYG{n}{s}\PYG{o}{*}\PYG{n}{s}
\end{sphinxVerbatim}

Why not? Write a different for loop that uses indexing into the
\sphinxcode{\sphinxupquote{squares}} list to accomplish our goal.

\item {} 
The following code for finding out if a word has two consecutive
double letters is wrong. Why? When, specifically, does it fail?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{has\PYGZus{}two\PYGZus{}doubles}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{==} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o+ow}{and} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{==} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{:}
            \PYG{k}{return} \PYG{k+kc}{True}
    \PYG{k}{return} \PYG{k+kc}{False}
\end{sphinxVerbatim}

\end{enumerate}


\section{Part 2: Nested Loops}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:part-2-nested-loops}}\begin{itemize}
\item {} 
Some problems require \sphinxstyleemphasis{iterating} over either
\begin{itemize}
\item {} 
two dimensions of data, or

\item {} 
all pairs of values from a list

\end{itemize}

\item {} 
As an example, here is code to print all of the products of digits:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digits} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{digits}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{digits}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ x }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ = }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{i}\PYG{o}{*}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
How does this work?
\begin{itemize}
\item {} 
for each value of \sphinxcode{\sphinxupquote{i}} the variable in the first, or “outer”,
loop, Python executes the \sphinxstyleemphasis{entire} second, or \sphinxcode{\sphinxupquote{inner}}, loop

\item {} 
Importantly, \sphinxcode{\sphinxupquote{i}} stays fixed during the entire inner loop.

\end{itemize}

\item {} 
We will look at finding the two closest points in a list.

\end{itemize}


\section{Example: Finding the Two Closest Points}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:example-finding-the-two-closest-points}}\begin{itemize}
\item {} 
Suppose we are given a list of point locations in two dimensions,
where each point is a tuple. For example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{points} \PYG{o}{=} \PYG{p}{[} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{13.5}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
Our problem is to find the two points that are closest to each
other.
\begin{itemize}
\item {} 
We started working on a slightly simpler version of this problem
at the end of Lecture 10.

\end{itemize}

\item {} 
The natural idea is to compute the distance between any two points
and find the minimum.
\begin{itemize}
\item {} 
We can do this with and without using a list of distances.

\end{itemize}

\item {} 
Let’s work through the approach to this and post the result on the
course website.

\end{itemize}


\section{Part 3:  Lists of Lists}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:part-3-lists-of-lists}}\begin{itemize}
\item {} 
In programming you often must deal with data much more complicated
than a single list.  For example, we might have a list of lists, where
each list might be temperature (or pH) measurements at one location of
a study site:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{temps\PYGZus{}at\PYGZus{}sites} \PYG{o}{=} \PYG{p}{[} \PYG{p}{[} \PYG{l+m+mf}{12.12}\PYG{p}{,} \PYG{l+m+mf}{13.25}\PYG{p}{,} \PYG{l+m+mf}{11.17}\PYG{p}{,} \PYG{l+m+mf}{10.4}\PYG{p}{]}\PYG{p}{,}
                   \PYG{p}{[} \PYG{l+m+mf}{22.1}\PYG{p}{,} \PYG{l+m+mf}{29.3}\PYG{p}{,} \PYG{l+m+mf}{25.3}\PYG{p}{,} \PYG{l+m+mf}{20.2}\PYG{p}{,} \PYG{l+m+mf}{26.4}\PYG{p}{,} \PYG{l+m+mf}{24.3} \PYG{p}{]}\PYG{p}{,}
                   \PYG{p}{[} \PYG{l+m+mf}{18.3}\PYG{p}{,} \PYG{l+m+mf}{17.9}\PYG{p}{,} \PYG{l+m+mf}{24.3}\PYG{p}{,} \PYG{l+m+mf}{27.2}\PYG{p}{,} \PYG{l+m+mf}{21.7}\PYG{p}{,} \PYG{l+m+mf}{22.2} \PYG{p}{]}\PYG{p}{,}
                   \PYG{p}{[} \PYG{l+m+mf}{12.4}\PYG{p}{,} \PYG{l+m+mf}{12.5}\PYG{p}{,} \PYG{l+m+mf}{12.14}\PYG{p}{,} \PYG{l+m+mf}{14.4}\PYG{p}{,} \PYG{l+m+mf}{15.2} \PYG{p}{]} \PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
Here is code to find the site with the maximum average
temperature; note that no indices are used.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{averages} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{site} \PYG{o+ow}{in} \PYG{n}{temps\PYGZus{}at\PYGZus{}sites}\PYG{p}{:}
    \PYG{n}{avg} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{site}\PYG{p}{)} \PYG{o}{/} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{site}\PYG{p}{)}
    \PYG{n}{averages}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{avg}\PYG{p}{)}

\PYG{n}{max\PYGZus{}avg} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{averages}\PYG{p}{)}
\PYG{n}{max\PYGZus{}index} \PYG{o}{=} \PYG{n}{averages}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{max\PYGZus{}avg}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Maximum average of }\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{ occurs at site }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{max\PYGZus{}avg}\PYG{p}{,} \PYG{n}{max\PYGZus{}index}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Notes:
\begin{itemize}
\item {} 
for loop variable \sphinxcode{\sphinxupquote{site}} is an \sphinxstylestrong{alias} for each successive
list in \sphinxcode{\sphinxupquote{temps\_at\_sites}}

\item {} 
A separate list is created to store the computed averages

\item {} 
We will see in class how this would be written without the
separate \sphinxcode{\sphinxupquote{averages}} list.

\end{itemize}

\end{itemize}


\section{Part 4: Controlling Execution of Loops}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:part-4-controlling-execution-of-loops}}\begin{itemize}
\item {} 
We can control loops through use of
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{break}}

\item {} 
\sphinxcode{\sphinxupquote{continue}}

\end{itemize}

\item {} 
We need to be careful to avoid infinite loops

\end{itemize}


\section{Using a Break}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:using-a-break}}\begin{itemize}
\item {} 
We can terminate a loop immediately upon seeing the 0 using
Python’s \sphinxcode{\sphinxupquote{break}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter an integer to add (0 to end) ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{break}
    \PYG{n+nb}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{break}} sends the flow of control immediately to the first line of code
outside the current loop, and

\item {} 
The while condition of \sphinxcode{\sphinxupquote{True}} essentially means that the only way
to stop the loop is when the condition that triggers the \sphinxcode{\sphinxupquote{break}} is
met.

\end{itemize}


\section{Continue: Skipping the Rest of a Loop Iteration}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:continue-skipping-the-rest-of-a-loop-iteration}}\begin{itemize}
\item {} 
Suppose we want to skip over negative entries in a list. We can do
this by telling Python to \sphinxcode{\sphinxupquote{continue}} when it the loop variable,
taken from the list, is negative:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{mylist}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{item} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{continue}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
When it sees \sphinxcode{\sphinxupquote{continue}}, Python immediate goes back to the “top”
of the loop, skipping the rest of the code, and initiates the next
iteration of the loop with a new value for \sphinxcode{\sphinxupquote{item}}.

\item {} 
Any loop that uses \sphinxcode{\sphinxupquote{break}} or \sphinxcode{\sphinxupquote{continue}} can be rewritten
without either of these.
\begin{itemize}
\item {} 
Therefore, we choose to use them only if they make our code
clearer.

\item {} 
A loop with more than one \sphinxcode{\sphinxupquote{continue}} or \sphinxcode{\sphinxupquote{break}} is rarely
well-structured, so if you find that you have written such a
loop you should stop and rewrite your code.

\end{itemize}

\item {} 
The example above, while illustrative, is probably better without
the \sphinxcode{\sphinxupquote{continue}}.
\begin{itemize}
\item {} 
Usually when we use \sphinxcode{\sphinxupquote{continue}} the rest of the loop is
relative long. The condition that triggers the \sphinxcode{\sphinxupquote{continue}} is
tested at or near the top of the loop.

\end{itemize}

\end{itemize}


\section{Termination of a While Loop}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:termination-of-a-while-loop}}\begin{itemize}
\item {} 
When working with a while loop one always needs to ensure that the
loop will terminate!  Otherwise we have an \sphinxstyleemphasis{infinite loop}.

\item {} 
Sometimes it is easy to decide if a loop will terminate.  Sometimes
it is not.

\item {} 
Do either of the following examples cause an infinite loop?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter a positive number \PYGZhy{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{while} \PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{flush}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter a positive number \PYGZhy{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{while} \PYG{n}{x} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{flush}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Summary}
\label{\detokenize{lecture_notes/lec12_loops2_for_double:summary}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{range}} is used to generate a sequence of indices in a \sphinxcode{\sphinxupquote{for}}
loop.

\item {} 
Nested for loops may be needed to iterate over two dimensions of
data.

\item {} 
Lists of lists may be used to specify more complex data.  We process
these using a combination of \sphinxcode{\sphinxupquote{for}} loops, which may need to be
nested, and Python’s built-in functions.  Use of Python’s built-in
functions, as illustrated in the example here in these notes, is
often preferred.

\item {} 
Loops (either for or while) may be controlled using \sphinxcode{\sphinxupquote{continue}} to
skip the rest of a loop iteration and using \sphinxcode{\sphinxupquote{break}} to terminate
the loop altogether.  These should be used sparingly!

\end{itemize}


\chapter{Lecture 12 — Exercises}
\label{\detokenize{lecture_notes/lec12_loops2_exercises/exercises:lecture-12-exercises}}\label{\detokenize{lecture_notes/lec12_loops2_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for grading.
A separate file must submitted for each problem.  Solutions must be
submitted by 4 pm on Friday, March 2.
\begin{enumerate}
\item {} 
The following simple exercise will help you understand loops better.
Show the output of each of the following pairs of \sphinxcode{\sphinxupquote{for}} loops. The
first two pairs are nested loops, and the third pair is formed by
consecutive, or \sphinxstyleemphasis{sequential}, loops.  Submit a single text file
containing three lines, each with an integer on it.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Version 1}
\PYG{n+nb}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Version 2}
\PYG{n+nb}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Version 3}
\PYG{n+nb}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Write a function called \sphinxcode{\sphinxupquote{first\_day\_greater}} that takes two lists,
\sphinxcode{\sphinxupquote{L1}} and \sphinxcode{\sphinxupquote{L2}},
representing the daily measured weights of rat 1 and rat 2,
respectively, and returns the index of the first day for which the
weight for the first rat is greater than the weight of the second
rat.  If there are no such days then the function should return
-1.  You may NOT assume that \sphinxcode{\sphinxupquote{L1}} and \sphinxcode{\sphinxupquote{L2}} are the same length.

Use the following to test your program:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{L1} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{15.1}\PYG{p}{,} \PYG{l+m+mf}{17.3}\PYG{p}{,} \PYG{l+m+mf}{12.3}\PYG{p}{,} \PYG{l+m+mf}{16.4} \PYG{p}{]}
    \PYG{n}{L2} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{15.0}\PYG{p}{,} \PYG{l+m+mf}{17.7}\PYG{p}{,} \PYG{l+m+mf}{12.5}\PYG{p}{,} \PYG{l+m+mf}{16.9} \PYG{p}{]}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Test 1: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{first\PYGZus{}day\PYGZus{}greater}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{,}\PYG{n}{L2}\PYG{p}{)} \PYG{p}{)}\PYG{p}{)}
    \PYG{n}{L2} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{15.6}\PYG{p}{,} \PYG{l+m+mf}{17.9}\PYG{p}{,} \PYG{l+m+mf}{18.2}\PYG{p}{,} \PYG{l+m+mf}{16.5}\PYG{p}{,} \PYG{l+m+mf}{12.7} \PYG{p}{]}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Test 2: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{first\PYGZus{}day\PYGZus{}greater}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{,}\PYG{n}{L2}\PYG{p}{)} \PYG{p}{)}\PYG{p}{)}
    \PYG{n}{L2} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{15.9}\PYG{p}{,} \PYG{l+m+mf}{18.8}\PYG{p}{,} \PYG{l+m+mf}{11.4} \PYG{p}{]}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Test 3: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{first\PYGZus{}day\PYGZus{}greater}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{,}\PYG{n}{L2}\PYG{p}{)} \PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Write a function called \sphinxcode{\sphinxupquote{find\_min}} that takes a list of lists and
returns the minimum value across all lists.  Test it with the
following

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{v} \PYG{o}{=} \PYG{p}{[} \PYG{p}{[} \PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{18}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{]} \PYG{p}{]}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Min of list v: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{find\PYGZus{}min}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)}
    \PYG{n}{u} \PYG{o}{=} \PYG{p}{[} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{car}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tailor}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ball}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dress}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{can}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cheese}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}\PYG{p}{,} \PYGZbs{}
              \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rain}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{snow}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sun}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]} \PYG{p}{]}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Min of list u: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{find\PYGZus{}min}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)}
\end{sphinxVerbatim}

\end{enumerate}


\chapter{Lecture 13 — Data from Files and Web Pages}
\label{\detokenize{lecture_notes/lec13_files_web:lecture-13-data-from-files-and-web-pages}}\label{\detokenize{lecture_notes/lec13_files_web::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec13_files_web:overview}}\begin{itemize}
\item {} 
Review of string operations

\item {} 
Files on your computer
\begin{itemize}
\item {} 
Opening and reading files

\item {} 
Closing

\item {} 
Writing files

\end{itemize}

\item {} 
Accessing files across the web

\item {} 
Parsing basics

\item {} 
Parsing html

\end{itemize}

Our discussion is only loosely tied to Chapter 8 of the text.


\section{Review — String operations often used in file parsing}
\label{\detokenize{lecture_notes/lec13_files_web:review-string-operations-often-used-in-file-parsing}}
Let’s review and go over some very common string operations that are
particularly useful in parsing files.
\begin{itemize}
\item {} 
Remove characters from the beginning, end or both sides of a
string with \sphinxcode{\sphinxupquote{lstrip}}, \sphinxcode{\sphinxupquote{rstrip}} and \sphinxcode{\sphinxupquote{strip}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red! Let}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s go red! Go red! Go red!}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZdq{} Let\PYGZsq{}s go red! Go red! Go \PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{edr!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZdq{} Let\PYGZsq{}s go red! Go red! Go \PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{lstrip}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZdq{} Let\PYGZsq{}s go red! Go red! Go red!\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{rstrip}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZdq{}red! Let\PYGZsq{}s go red! Go red! Go \PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{    Go red!      }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}Go red!\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{   Go red!    }\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{  }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}Go red!\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{   Go red!    }\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{  }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}\PYGZbs{}n   Go red!    \PYGZbs{}t\PYGZsq{}}
\end{sphinxVerbatim}

With no arguments, the \sphinxcode{\sphinxupquote{strip}} functions remove all white space characters.

\item {} 
Split a string using a delimiter, and get a list of strings. Whitespace
is the default delimiter:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Let}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s go red! Let}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s go red! Go red! Go red!}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZdq{}Let\PYGZsq{}s\PYGZdq{}, \PYGZsq{}go\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}, \PYGZdq{}Let\PYGZsq{}s\PYGZdq{}, \PYGZsq{}go\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}, \PYGZsq{}Go\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}, \PYGZsq{}Go\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZdq{}Let\PYGZsq{}s go red\PYGZdq{}, \PYGZdq{} Let\PYGZsq{}s go red\PYGZdq{}, \PYGZsq{} Go red\PYGZsq{}, \PYGZsq{} Go red\PYGZsq{}, \PYGZsq{}\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZdq{}Let\PYGZsq{}s go \PYGZdq{}, \PYGZdq{} Let\PYGZsq{}s go \PYGZdq{}, \PYGZsq{} Go \PYGZsq{}, \PYGZsq{} Go \PYGZsq{}, \PYGZsq{}\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Let}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s go red! }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ Let}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s go    red! Go red! }\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{ Go red!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZdq{}Let\PYGZsq{}s\PYGZdq{}, \PYGZsq{}go\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}, \PYGZsq{}\PYGZbs{}n\PYGZsq{}, \PYGZdq{}Let\PYGZsq{}s\PYGZdq{}, \PYGZsq{}go\PYGZsq{}, \PYGZsq{}\PYGZsq{}, \PYGZsq{}\PYGZsq{}, \PYGZsq{}\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}, \PYGZsq{}Go\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}, \PYGZsq{}\PYGZbs{}t\PYGZsq{}, \PYGZsq{}Go\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Let}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s go red! }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ Let}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s go    red! Go red! }\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{ Go red!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZdq{}Let\PYGZsq{}s\PYGZdq{}, \PYGZsq{}go\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}, \PYGZdq{}Let\PYGZsq{}s\PYGZdq{}, \PYGZsq{}go\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}, \PYGZsq{}Go\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}, \PYGZsq{}Go\PYGZsq{}, \PYGZsq{}red!\PYGZsq{}]}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{split}} returns the strings before and after the delimiter string in a
list.

\item {} 
The \sphinxcode{\sphinxupquote{find}} function returns the first location of a substring in a
string, and returns -1 if the substring is not found. You can also
optionally give a starting and end point to search from:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}
\PYG{g+go}{\PYGZdq{}Let\PYGZsq{}s go red! Let\PYGZsq{}s go red! Go red! Go red!\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{9}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{edr!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+go}{23}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{x}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Red}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{x}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{itemize}


\section{Opening and Reading Files}
\label{\detokenize{lecture_notes/lec13_files_web:opening-and-reading-files}}\begin{itemize}
\item {} 
On to our main topic….

\item {} 
Given the name of a file as a string, we can open it to read:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

This is the same as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Variable \sphinxcode{\sphinxupquote{f}} now “points” to the first line of file \sphinxcode{\sphinxupquote{abc.txt}}.

\item {} 
The \sphinxcode{\sphinxupquote{'r'}} tells Python we will be reading from this file — this
is the default.

\end{itemize}

\item {} 
One way to access contents of a file is by doing so one input line
at a time.  In particular,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{line} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

reads in the next line up to and including the end-of-line character,
and “advances” \sphinxcode{\sphinxupquote{f}} to point to the next line of file \sphinxcode{\sphinxupquote{abc.txt}}.

\item {} 
By contrast,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

reads the entire \sphinxstylestrong{remainder} of the input file as a single string,
\begin{itemize}
\item {} 
storing the one (big) string in \sphinxcode{\sphinxupquote{s}}, and

\item {} 
advancing \sphinxcode{\sphinxupquote{f}} to the end of the file!

\end{itemize}

\item {} 
When you are at the end of a file, \sphinxcode{\sphinxupquote{f.read()}} and \sphinxcode{\sphinxupquote{f.readline()}} will
both return the empty string: \sphinxcode{\sphinxupquote{""}}.

\end{itemize}


\section{Reading the contents of a file}
\label{\detokenize{lecture_notes/lec13_files_web:reading-the-contents-of-a-file}}\begin{itemize}
\item {} 
The most common way to read a file is illustrated in the following
example that reads each line from a file and prints it on the screen:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\end{sphinxVerbatim}

(Of course you can replace the call to \sphinxcode{\sphinxupquote{print()}} with any other
processing code since each \sphinxcode{\sphinxupquote{line}} is just a string!)

\item {} 
You can combine the above steps into a single for loop:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Closing and Reopening Files}
\label{\detokenize{lecture_notes/lec13_files_web:closing-and-reopening-files}}\begin{itemize}
\item {} 
The code below opens, reads, closes and reopens a file

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Insert whatever code is need to read from the file}
\PYG{c+c1}{\PYGZsh{} and use its contents ...}

\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{f}} now points again to the beginning of the file.

\item {} 
This can be used to read the same file multiple times.

\end{itemize}


\section{Example: Computing the Average Score}
\label{\detokenize{lecture_notes/lec13_files_web:example-computing-the-average-score}}\begin{itemize}
\item {} 
We are given a file that contains a sequence of integers
representing test scores, one score per line.  We need to write a
program that computes the average of these scores.

\item {} 
Here is one solution

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{file\PYGZus{}name} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter the name of the scores file: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{file\PYGZus{}name} \PYG{o}{=} \PYG{n}{file\PYGZus{}name}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} Elminate extra white space that the user may have typed}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{file\PYGZus{}name}\PYG{p}{)}

\PYG{n}{num\PYGZus{}scores} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{sum\PYGZus{}scores} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{s} \PYG{o+ow}{in} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{file\PYGZus{}name}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{sum\PYGZus{}scores} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
    \PYG{n}{num\PYGZus{}scores} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Average score is }\PYG{l+s+si}{\PYGZob{}:.1f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{sum\PYGZus{}scores} \PYG{o}{/} \PYG{n}{num\PYGZus{}scores} \PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
In class we will discuss:
\begin{itemize}
\item {} 
Getting the file name from the user

\item {} 
The importance of using \sphinxcode{\sphinxupquote{strip}}

\item {} 
The rest of the program.

\end{itemize}

\end{itemize}


\section{Writing to a File}
\label{\detokenize{lecture_notes/lec13_files_web:writing-to-a-file}}\begin{itemize}
\item {} 
In order to write to a file we must first open it and associate it
with a file variable, e.g.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f\PYGZus{}out} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{outfile.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
The \sphinxcode{\sphinxupquote{"w"}} signifies \sphinxstyleemphasis{write mode} which causes Python to completely
delete the previous contents of \sphinxcode{\sphinxupquote{outfile.txt}} (if the file
previously existed).

\item {} 
It is also possible to use \sphinxstyleemphasis{append mode}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f\PYGZus{}out} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{outfile.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

which means that the contents of \sphinxcode{\sphinxupquote{outfile.txt}} are kept and new
output is added to the end of the file.

\item {} 
Write mode is much more common than append mode.

\item {} 
To actually write to a file, we use the \sphinxcode{\sphinxupquote{write}} method:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f\PYGZus{}out}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello world!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Each call to \sphinxcode{\sphinxupquote{write}} passes only a \sphinxstylestrong{single string}.

\item {} 
Unlike what happens when using \sphinxcode{\sphinxupquote{print}}, spacing and newline
characters are required explicitly

\item {} 
You can use the \sphinxcode{\sphinxupquote{format}} method of each string before you
print it.

\end{itemize}

\item {} 
You must close the files you write! Otherwise, the changes you made
will not be recorded!

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f\PYGZus{}out}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Lecture Exercise 1:}
\label{\detokenize{lecture_notes/lec13_files_web:lecture-exercise-1}}
You will have a few minutes to work on the first lecture exercise.


\section{Opening Static Web Pages}
\label{\detokenize{lecture_notes/lec13_files_web:opening-static-web-pages}}\begin{itemize}
\item {} 
We can use the \sphinxcode{\sphinxupquote{urllib}} module to access web pages.

\item {} 
We did this with our very first “real” example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{urllib}\PYG{n+nn}{.}\PYG{n+nn}{request}
\PYG{n}{word\PYGZus{}url} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{http://www.greenteapress.com/thinkpython/code/words.txt}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{word\PYGZus{}file} \PYG{o}{=} \PYG{n}{urllib}\PYG{o}{.}\PYG{n}{request}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{word\PYGZus{}url}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Once we have \sphinxcode{\sphinxupquote{words\_file}} we can use the \sphinxcode{\sphinxupquote{read}}, \sphinxcode{\sphinxupquote{readline}},
and \sphinxcode{\sphinxupquote{close}} methods just like we did with “ordinary” files.

\item {} 
When the web page is dynamic, we usually need to work through a
separate API (application program interface) to access the contents
of the web site.

\end{itemize}


\section{Parsing}
\label{\detokenize{lecture_notes/lec13_files_web:parsing}}\begin{itemize}
\item {} 
Before writing code to read a data file or to read the contents of a
web page, we must know the format of the data in the file.

\item {} 
The work of reading a data file or a web page is referred to as
\sphinxstyleemphasis{parsing}.

\item {} 
Files can be of a fixed well-known format
\begin{itemize}
\item {} 
Python code

\item {} 
C++ code

\item {} 
HTML (HyperText Markup Language, used in all web pages)

\item {} 
JSON (Javascript Object Notation, a common data exchange format)

\item {} 
RDF (resource description framework)

\end{itemize}

\item {} 
Often there is a parser module for these formats that you can
simply use instead of implementing them from scratch.

\item {} 
For code, parsers check for syntax errors.

\end{itemize}


\section{Short tour of data formats}
\label{\detokenize{lecture_notes/lec13_files_web:short-tour-of-data-formats}}\begin{itemize}
\item {} 
Python code:
\begin{itemize}
\item {} 
Each statement is on a separate line

\item {} 
Changes in indentation are used to indicate entry/exit to blocks
of code, e.g. within \sphinxcode{\sphinxupquote{def}}, \sphinxcode{\sphinxupquote{for}}, \sphinxcode{\sphinxupquote{if}}, \sphinxcode{\sphinxupquote{while}}…

\end{itemize}

\item {} 
HTML: Basic structure is a mix of text with commands that are
inside “tags”  \sphinxcode{\sphinxupquote{\textless{} ... \textgreater{}}}.

Example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{html}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{head}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{title}\PYG{o}{\PYGZgt{}}\PYG{n}{HTML} \PYG{n}{example} \PYG{k}{for} \PYG{n}{CSCI}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{title}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{head}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n}{body}\PYG{o}{\PYGZgt{}}
      \PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{page} \PYG{n}{about} \PYG{o}{\PYGZlt{}}\PYG{n}{a} \PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http://python.org}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Python}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{a}\PYG{o}{\PYGZgt{}}\PYG{o}{.}
      \PYG{n}{It} \PYG{n}{contains} \PYG{n}{links} \PYG{o+ow}{and} \PYG{n}{other} \PYG{n}{information}\PYG{o}{.}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{body}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{html}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
Despite the clean formatting of this example, html is in fact
free-form, so that, for example, the following produces exactly the
same web page:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{html}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{head}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{title}\PYG{o}{\PYGZgt{}}\PYG{n}{HTML}   \PYG{n}{example} \PYG{k}{for} \PYG{n}{CSCI}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{title}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{head}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{body}\PYG{o}{\PYGZgt{}} \PYG{n}{This} \PYG{o+ow}{is} \PYG{n}{a} \PYG{n}{page} \PYG{n}{about} \PYG{o}{\PYGZlt{}}\PYG{n}{a}
\PYG{n}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http://python.org}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Python}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{a}\PYG{o}{\PYGZgt{}}\PYG{o}{.}  \PYG{n}{It} \PYG{n}{contains}   \PYG{n}{links}
\PYG{o+ow}{and} \PYG{n}{other}   \PYG{n}{information}\PYG{o}{.} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{body}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{html}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\item {} 
JSON: used often with Python in many Web based APIs:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
   \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{class\PYGZus{}name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CSCI 1100}\PYG{l+s+s2}{\PYGZdq{}}
   \PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lab\PYGZus{}sections}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{p}{[}
          \PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Section 01}\PYG{l+s+s2}{\PYGZdq{}}
             \PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scheduled}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T 10AM\PYGZhy{}12PM}\PYG{l+s+s2}{\PYGZdq{}}
             \PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{location}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sage 2704}\PYG{l+s+s2}{\PYGZdq{}}
          \PYG{p}{\PYGZcb{}}
          \PYG{p}{,} \PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Section 02}\PYG{l+s+s2}{\PYGZdq{}}
             \PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scheduled}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{T 12PM\PYGZhy{}2PM}\PYG{l+s+s2}{\PYGZdq{}}
             \PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{location}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sage 2112}\PYG{l+s+s2}{\PYGZdq{}}
          \PYG{p}{\PYGZcb{}} \PYG{p}{]}

 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Similar to HTML, spaces do not matter.
\begin{itemize}
\item {} 
Json is a simple module for converting between a string in
JSON format and a Python variable:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{json}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ [ }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{, [ }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{, 3 ] ] }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{json}\PYG{o}{.}\PYG{n}{loads}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}a\PYGZsq{}, [\PYGZsq{}b\PYGZsq{}, 3]]}
\end{sphinxVerbatim}

\end{itemize}

\end{itemize}


\section{Parsing ad-hoc data formats - Regular tabular data}
\label{\detokenize{lecture_notes/lec13_files_web:parsing-ad-hoc-data-formats-regular-tabular-data}}
We will examine some simple formats that you have already seen in
various homeworks.
\begin{itemize}
\item {} 
Parsing files with fixed format in each line, delimited by a
character

Often used: comma (csv), tab or space
\begin{itemize}
\item {} 
One example is a file of comma separated values, Each line has a label of a soup type and
a number of cans we have available:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chicken} \PYG{n}{noodle}\PYG{p}{,} \PYG{l+m+mi}{2}
\PYG{n}{clam} \PYG{n}{chowder}\PYG{p}{,} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\item {} 
Here is pseudo code for processing such files:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{each} \PYG{n}{line} \PYG{n}{of} \PYG{n}{the} \PYG{n}{file}
  \PYG{n}{split} \PYG{n}{into} \PYG{n}{a} \PYG{n+nb}{list} \PYG{n}{using} \PYG{n}{the} \PYG{n}{separator}
  \PYG{n}{process} \PYG{n}{the} \PYG{n}{entries} \PYG{n}{of} \PYG{n}{the} \PYG{n+nb}{list} \PYG{n}{into} \PYG{n}{the} \PYG{n}{desired} \PYG{n}{form}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxstylestrong{Practice Problem:} write a simple parser for the soup list that returns a
list of the form:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{chicken noodle}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{chicken noodle}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{clam chowder}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{clam chowder}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{clam chowder}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{itemize}


\section{Parsing ad-hoc data formats - Irregular tabular data}
\label{\detokenize{lecture_notes/lec13_files_web:parsing-ad-hoc-data-formats-irregular-tabular-data}}\begin{itemize}
\item {} 
Parsing files with one line per row of information, different
columns containing unknown amount of information separated with a
secondary delimiter
\begin{itemize}
\item {} 
Example: Yelp data with the name of a restaurant, the lattitude,
the longitude, the address, the URL, and a sequence of reviews

Meka’s Lounge\textbar{}42.74\textbar{}-73.69\textbar{}407 River Street+Troy, NY 12180\textbar{}http://www.yelp.com/biz/mekas-lounge-troy\textbar{}Bars\textbar{}5\textbar{}2\textbar{}4\textbar{}4\textbar{}3\textbar{}4\textbar{}5

\end{itemize}

Information after column 5 are all reviews

The address field is separated with a plus sign

Pseudo code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{each} \PYG{n}{line} \PYG{n}{of} \PYG{n}{the} \PYG{n}{file}
    \PYG{n}{split} \PYG{n}{using} \PYG{n}{the} \PYG{n}{separator}
    \PYG{n}{split} \PYG{n}{the} \PYG{n}{entry} \PYG{k}{with} \PYG{n}{secondary} \PYG{n}{separator}
    \PYG{k}{for} \PYG{n}{each} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{column}
        \PYG{n}{handle} \PYG{n}{value}
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{Practice Problem:} Write a function that returns a list of lists for a file
containing Yelp data.  Each list should contain the name of the
restaurant and the average review.

\end{itemize}


\section{Summary}
\label{\detokenize{lecture_notes/lec13_files_web:summary}}\begin{itemize}
\item {} 
You should now have enough information to easily write code to open,
read, write and close files on local computers.

\item {} 
Once text (or HTML) files found on the web are opened, the same
reading methods apply just as though the files were local. Binary
files such as images require special modules.

\item {} 
Parsing a file requires understanding its format, which is, in a
sense, the “language” in which it is written.

\item {} 
You will practice with file reading and writing in future labs and
homework assignments.

\end{itemize}


\chapter{Lecture 13 — Exercises}
\label{\detokenize{lecture_notes/lec13_files_exercises/exercises:lecture-13-exercises}}\label{\detokenize{lecture_notes/lec13_files_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for grading.
A separate file must submitted for each problem.  Solutions must be
submitted by 4 pm on Tuesday, October 17.
\begin{enumerate}
\item {} 
Given the file \sphinxcode{\sphinxupquote{census\_data.txt}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Line} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{n}{Location}    \PYG{l+m+mi}{2000}    \PYG{l+m+mi}{2011}
\PYG{n}{Line} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}}\PYG{n}{New} \PYG{n}{York} \PYG{n}{State}  \PYG{l+m+mi}{18}\PYG{p}{,}\PYG{l+m+mi}{976}\PYG{p}{,}\PYG{l+m+mi}{811}  \PYG{l+m+mi}{19}\PYG{p}{,}\PYG{l+m+mi}{378}\PYG{p}{,}\PYG{l+m+mi}{102}
\PYG{n}{Line} \PYG{l+m+mi}{3} \PYG{o}{\textbar{}}\PYG{n}{New} \PYG{n}{York} \PYG{n}{City}   \PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{008}\PYG{p}{,}\PYG{l+m+mi}{686}   \PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{175}\PYG{p}{,}\PYG{l+m+mi}{133}
\PYG{n}{Line} \PYG{l+m+mi}{4} \PYG{o}{\textbar{}}
\end{sphinxVerbatim}

What is the output of the following code? (Note: the line
numbers and the “\textbar{}” are not actually in the file, they are just there to show
that the contents of the 4 lines.)

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{census\PYGZus{}data.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{line1} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{line1} \PYG{o}{=} \PYG{n}{line1}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{line2} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{line3} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{line1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{line2}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{line3}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{census\PYGZus{}data.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{line\PYGZus{}list} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{line\PYGZus{}list} \PYG{o}{=} \PYG{n}{s}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Submit your output as a text file.

\item {} 
Given a file containing test scores, one per line, we want to have
a new file that contains the scores in increasing order.  To do
this, write a Python program that asks the user for two file name
strings, one for the input scores and the second for the output,
sorted scores.  The program should open the first file (to read),
read the scores, sort them, open the second file (to write), and
output to this file the scores in increasing order.  There should be
one score per line, with the index on each line.

As an example, suppose the input file is \sphinxcode{\sphinxupquote{scores.txt}} and it
contains

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{75}
\PYG{l+m+mi}{98}
\PYG{l+m+mi}{75}
\PYG{l+m+mi}{100}
\PYG{l+m+mi}{21}
\PYG{l+m+mi}{66}
\PYG{l+m+mi}{83}
\PYG{l+m+mi}{15}
\end{sphinxVerbatim}

then running your program should look like (in Wing IDE):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Enter} \PYG{n}{the} \PYG{n}{scores} \PYG{n}{file}\PYG{p}{:} \PYG{n}{scores}\PYG{o}{.}\PYG{n}{txt}
\PYG{n}{scores}\PYG{o}{.}\PYG{n}{txt}
\PYG{n}{Enter} \PYG{n}{the} \PYG{n}{output} \PYG{n}{file}\PYG{p}{:} \PYG{n}{scores\PYGZus{}sorted}\PYG{o}{.}\PYG{n}{txt}
\PYG{n}{scores\PYGZus{}sorted}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

When you look at the contents of \sphinxcode{\sphinxupquote{scores\_sorted.txt}} you should
see

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}\PYG{p}{:}  \PYG{l+m+mi}{15}
\PYG{l+m+mi}{1}\PYG{p}{:}  \PYG{l+m+mi}{21}
\PYG{l+m+mi}{2}\PYG{p}{:}  \PYG{l+m+mi}{66}
\PYG{l+m+mi}{3}\PYG{p}{:}  \PYG{l+m+mi}{75}
\PYG{l+m+mi}{4}\PYG{p}{:}  \PYG{l+m+mi}{75}
\PYG{l+m+mi}{5}\PYG{p}{:}  \PYG{l+m+mi}{83}
\PYG{l+m+mi}{6}\PYG{p}{:}  \PYG{l+m+mi}{98}
\PYG{l+m+mi}{7}\PYG{p}{:} \PYG{l+m+mi}{100}
\end{sphinxVerbatim}

(Output the indices using two integer spaces \{:2d\} and the scores using
three \{:3d\}.) You only need to submit the Python file.  We will test with the
example above and with a new file you have not seen.

\end{enumerate}


\chapter{Lecture 14 — Problem Solving and Design, Part 1}
\label{\detokenize{lecture_notes/lec14_design_part1:lecture-14-problem-solving-and-design-part-1}}\label{\detokenize{lecture_notes/lec14_design_part1::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec14_design_part1:overview}}
This is the first of our lectures dedicated primarily to problem
solving and design rather than on particular programming constructs
and techniques
\begin{itemize}
\item {} 
Design:
\begin{itemize}
\item {} 
Choice of container/data structure; choice of algorithm.
\begin{itemize}
\item {} 
At the moment, we don’t know too many containers, but we will
think about different ways to use the one container - lists -
we do know about.

\end{itemize}

\item {} 
Implementation

\item {} 
Testing

\item {} 
Debugging

\end{itemize}

\item {} 
We will discuss these in the context of several variations on one
problem:
\begin{itemize}
\item {} 
Finding the mode in a sequence of values — the value (or values)
occuring most often.

\end{itemize}

\item {} 
There is no direct connect to a chapter in the text.

\item {} 
We will start with a completely blank slate so that the whole process
unfolds from scratch. This includes looking for other code to
adapt.

\item {} 
Working through problems like this is a good way to review what
we’ve learned thus far.

\end{itemize}


\section{Problem: Finding the Mode}
\label{\detokenize{lecture_notes/lec14_design_part1:problem-finding-the-mode}}\begin{itemize}
\item {} 
Given a series of values, find the one that occurs most often.

\item {} 
Variation 1: is there a limited, indexable range of values?
\begin{itemize}
\item {} 
Examples that are consistent with this variation include test
scores or letters of the alphabet

\item {} 
Examples not consistent include counting words and counting amino
acids

\end{itemize}

\item {} 
Variation 2: do we want just the modes or do we want to know how many
times each value occurs?

\item {} 
Variation 3: do we want a histogram where values are grouped?
\begin{itemize}
\item {} 
Example: ocean temperature measurements, pixel intensities, income
values.

\item {} 
In each of these cases, a specific value, the number of
occurrences of a specific temperature, such as 2.314C, is not really of
interest. More important is the number of temperature values in
certain ranges.

\end{itemize}

\end{itemize}


\section{Our Focus: A Sequence of Numbers}
\label{\detokenize{lecture_notes/lec14_design_part1:our-focus-a-sequence-of-numbers}}\begin{itemize}
\item {} 
Integers, such as test scores

\item {} 
Floats, such as temperature measurements

\end{itemize}


\section{Sequence of Discussion}
\label{\detokenize{lecture_notes/lec14_design_part1:sequence-of-discussion}}\begin{itemize}
\item {} 
Brainstorm ideas for the basic approach. We’ll come with at least
two.
\begin{itemize}
\item {} 
We will discuss an additional approach when we learn about
dictionaries.

\end{itemize}

\item {} 
Algorithm / implementation

\item {} 
Testing
\begin{itemize}
\item {} 
Generate test cases

\item {} 
Which test cases we generate will depend on the choice of
algorithm. We will combine them.

\end{itemize}

\item {} 
Debugging:
\begin{itemize}
\item {} 
If we find a failed test case, we will need to find the error and
fix it.

\item {} 
Use a combination of carefully reading the code, working with a
debugger, and generating print statements.

\end{itemize}

\item {} 
Evaluation
\begin{itemize}
\item {} 
We can analyze using theoretical tools we will learn about
later or through experimental timing

\end{itemize}

\end{itemize}


\section{Discussion of Variations}
\label{\detokenize{lecture_notes/lec14_design_part1:discussion-of-variations}}\begin{itemize}
\item {} 
Frequency of occurrence:
\begin{itemize}
\item {} 
What are the ten most frequently occurring values? What are the
top ten percent most frequent values?

\item {} 
Output the occurrences for each value.

\end{itemize}

\item {} 
Clusters / histograms:
\begin{itemize}
\item {} 
Test scores in each range of 10

\end{itemize}

\item {} 
Quantiles: bottom 25\% of scores, median, top 25\%

\end{itemize}


\chapter{Lecture 15 — Sets}
\label{\detokenize{lecture_notes/lec15_sets:lecture-15-sets}}\label{\detokenize{lecture_notes/lec15_sets::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec15_sets:overview}}\begin{itemize}
\item {} 
Example: finding all individuals listed in the Internet Movie
Database (IMDB)

\item {} 
A solution based on lists

\item {} 
Sets and set operations

\item {} 
A solution based on sets.

\item {} 
Efficiency and set representation

\end{itemize}

Reading is Section 11.1 of \sphinxstyleemphasis{Practical Programming}.


\section{Finding All Persons in the IMDB file}
\label{\detokenize{lecture_notes/lec15_sets:finding-all-persons-in-the-imdb-file}}\begin{itemize}
\item {} 
We are given a file extracted from the Internet Movie Database (IMDB)
called \sphinxcode{\sphinxupquote{imdb\_data.txt}} containing, on each line, a person’s name, a
movie name, and a year. For example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Kishiro}\PYG{p}{,} \PYG{n}{Yukito}   \PYG{o}{\textbar{}} \PYG{n}{Battle} \PYG{n}{Angel}    \PYG{o}{\textbar{}} \PYG{l+m+mi}{2016}
\end{sphinxVerbatim}

\item {} 
Goal:
\begin{itemize}
\item {} 
Find all persons named in the file

\item {} 
Count the number of different persons named.

\item {} 
Ask if a particular person is named in the file

\end{itemize}

\item {} 
The challenge in doing this is that many names appear multiple times.

\item {} 
First solution: store names in a list. We’ll start from the
following code, posted on Piazza in
\sphinxcode{\sphinxupquote{lec15\_find\_names\_start.py}}, which is part of a Lecture 15 zip file.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{imdb\PYGZus{}file} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter the name of the IMDB file ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{name\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{imdb\PYGZus{}file}\PYG{p}{,} \PYG{n}{encoding} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ISO\PYGZhy{}8859\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{words} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\textbar{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{name} \PYG{o}{=} \PYG{n}{words}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

and complete the code in class.

\item {} 
The challenge is that we need to check that a name is not already in
the list before adding it.

\item {} 
You may access the data files and the starting code .py file from
the Resources page of the Piazza site.

\end{itemize}


\section{How To Test?}
\label{\detokenize{lecture_notes/lec15_sets:how-to-test}}\begin{itemize}
\item {} 
The file \sphinxcode{\sphinxupquote{imdb\_data.txt}} has about 260K entries. How will we know
our results are correct?

\item {} 
Even if we restrict it to movies released in 2010-2012 (the file
\sphinxcode{\sphinxupquote{imdb\_2010-12.txt}}), we still have 25K entries!

\item {} 
We need to generate a smaller file with results we can test by hand
\begin{itemize}
\item {} 
I have generated \sphinxcode{\sphinxupquote{hanks.txt}} for you and will use it to test our
program before testing on the larger files.

\end{itemize}

\end{itemize}


\section{What Happens?}
\label{\detokenize{lecture_notes/lec15_sets:what-happens}}\begin{itemize}
\item {} 
Very slow on the large files because we need to scan through the list
to see if a name is already there.

\item {} 
We’ll write a faster implementation based on Python \sphinxstyleemphasis{sets}.

\item {} 
We’ll start with the basics of sets.

\end{itemize}


\section{Sets}
\label{\detokenize{lecture_notes/lec15_sets:sets}}\begin{itemize}
\item {} 
A Python set is an implementation of the mathematical notion of a
set:
\begin{itemize}
\item {} 
No order to the values (and therefore no indexing)

\item {} 
Contains no duplicates

\item {} 
Contains whatever type of values we wish; including values of
different types.

\end{itemize}

\item {} 
Python set methods are exactly what you would expect.
\begin{itemize}
\item {} 
Each has a function call syntax and many have operator syntax in
addition.

\end{itemize}

\end{itemize}


\section{Set Methods}
\label{\detokenize{lecture_notes/lec15_sets:set-methods}}\begin{itemize}
\item {} 
Initialization comes from a list, a range, or from just \sphinxcode{\sphinxupquote{set()}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1}
\PYG{g+go}{set()}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2}
\PYG{g+go}{\PYGZob{}0, 2, 4, 6, 8, 10\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{spam}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{256}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s3} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s3}
\PYG{g+go}{\PYGZob{}32, 64, 4, \PYGZsq{}spam\PYGZsq{}, 8, 256, \PYGZsq{}hello\PYGZsq{}\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
The actual methods are
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{s.add(x)}} — add an element if it is not already there

\item {} 
\sphinxcode{\sphinxupquote{s.clear()}} — clear out the set, making it empty

\item {} 
\sphinxcode{\sphinxupquote{s1.difference(s2)}} — create a new set with the values from
\sphinxcode{\sphinxupquote{s1}} that are not in \sphinxcode{\sphinxupquote{s2}}.
\begin{itemize}
\item {} 
Python also has an “operator syntax” for this:

\end{itemize}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s1} \PYG{o}{\PYGZhy{}} \PYG{n}{s2}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{s1.intersection(s2)}} — create a new set that contains only the
values that are in \sphinxstylestrong{both} sets. Operator syntax:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s1} \PYG{o}{\PYGZam{}} \PYG{n}{s2}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{s1.union(s2)}} — create a new set that contains values that are
in either set. Operator syntax:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s1} \PYG{o}{\textbar{}} \PYG{n}{s2}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{s1.issubset(s2)}} —- are all elements of \sphinxcode{\sphinxupquote{s1}} also in \sphinxcode{\sphinxupquote{s2}}?
Operator syntax:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{s2}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{s1.issuperset(s2)}} — are all elements of \sphinxcode{\sphinxupquote{s2}} also in \sphinxcode{\sphinxupquote{s1}}?
Operator syntax:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s1} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{s2}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{s1.symmetric\_difference(s2)}} — create a new set that contains
values that are in \sphinxcode{\sphinxupquote{s1}} or \sphinxcode{\sphinxupquote{s2}} but \sphinxstylestrong{not in both}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s1} \PYG{o}{\PYGZca{}} \PYG{n}{s2}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{x in s}} - evaluates to \sphinxcode{\sphinxupquote{True}} if the value associated with
\sphinxcode{\sphinxupquote{x}} is in set \sphinxcode{\sphinxupquote{s}}.

\end{itemize}

\item {} 
We will explore the intuitions behind these set operations by
considering
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{s1}} to be the set of actors in \sphinxstyleemphasis{comedies},

\item {} 
\sphinxcode{\sphinxupquote{s2}} to be the set of actors in \sphinxstyleemphasis{action movies}

\end{itemize}

and then consider who is in the sets

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s1} \PYG{o}{\PYGZhy{}} \PYG{n}{s2}

\PYG{n}{s1} \PYG{o}{\PYGZam{}} \PYG{n}{s2}

\PYG{n}{s1} \PYG{o}{\textbar{}} \PYG{n}{s2}

\PYG{n}{s1} \PYG{o}{\PYGZca{}} \PYG{n}{s2}
\end{sphinxVerbatim}

\end{itemize}


\section{Exercises}
\label{\detokenize{lecture_notes/lec15_sets:exercises}}\begin{enumerate}
\item {} 
Sets should be relatively intuitive, so rather than demo them in
class, we’ll work through these as an exercise:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1}


\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}


\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s2}


\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{\PYGZhy{}} \PYG{n}{s2}


\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{\PYGZam{}} \PYG{n}{s2}


\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{\textbar{}} \PYG{n}{s2}


\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{s2}


\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s3} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s3} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{s2}
\end{sphinxVerbatim}

\end{enumerate}


\section{Back to Our Problem}
\label{\detokenize{lecture_notes/lec15_sets:back-to-our-problem}}\begin{itemize}
\item {} 
We’ll modify our code to find the actors in the IMDB. The code is
actually very simple and only requires a few set operations.

\end{itemize}


\section{Side-by-Side Comparison of the Two Solutions}
\label{\detokenize{lecture_notes/lec15_sets:side-by-side-comparison-of-the-two-solutions}}\begin{itemize}
\item {} 
Neither the set nor the list is ordered. We can fix this at the end by
sorting.
\begin{itemize}
\item {} 
The list can be sorted directly.

\item {} 
The set must be converted to a list first. The function \sphinxcode{\sphinxupquote{sorted}}
does this for us.

\end{itemize}

\item {} 
What about speed? The set version is \sphinxstylestrong{MUCH FASTER} — to the point
that the list version is essentially useless on a large data set.
\begin{itemize}
\item {} 
We’ll use some timings to demonstrate this quantitatively

\item {} 
We’ll then explore why in the rest of this lecture.

\end{itemize}

\end{itemize}


\section{Comparison of Running Times for Our Two Solutions}
\label{\detokenize{lecture_notes/lec15_sets:comparison-of-running-times-for-our-two-solutions}}\begin{itemize}
\item {} 
List-based solution:
\begin{itemize}
\item {} 
Each time before a name is added, the code — through the method
\sphinxcode{\sphinxupquote{in}} — scans through the entire list to decide if it is there.

\item {} 
Thus, the work done is proportional to the size of the list.

\item {} 
The overall running time is therefore roughly proportional to the
\sphinxcode{\sphinxupquote{square}} of the number of entries in the list (and the file).

\item {} 
Letting the mathematical variable \(N\) represent the length
of the list, we write this more formally as \(O(N^2)\), or
“the order of N squared”

\end{itemize}

\item {} 
Set-based code
\begin{itemize}
\item {} 
For sets, Python uses a technique called \sphinxstyleemphasis{hashing} to restrict the
running time of the \sphinxcode{\sphinxupquote{add}} method so that it is \sphinxstyleemphasis{independent of
size of the set}.
\begin{itemize}
\item {} 
The details of hashing are covered in CSCI 1200, Data
Structures.

\end{itemize}

\item {} 
The overall running time is therefore roughly proportional to the
length of the set (and number of entries in the file).

\item {} 
We write this as \(O(N)\).

\end{itemize}

\item {} 
We will discuss this type of analysis more later in the semester.
\begin{itemize}
\item {} 
It is covered in much greater detail in Data Structures and again
in Intro. to Algorithms.

\end{itemize}

\end{itemize}


\section{Discussion}
\label{\detokenize{lecture_notes/lec15_sets:discussion}}\begin{itemize}
\item {} 
Python largely hides the details of the containers — set and list in
this case — and therefore it is hard to know which is more efficient
and why.

\item {} 
For programs applied to small problems involving small data sets,
efficiency rarely matters.

\item {} 
For longer programs and programs that work on larger data sets,
efficiency does matter, sometimes tremendously. What do we do?
\begin{itemize}
\item {} 
In some cases, we still use Python and choose the containers and
operations that make the code most efficient.

\item {} 
In others, we must switch to programming languages, such as C++,
that generate and use compiled code.

\end{itemize}

\end{itemize}


\section{Summary}
\label{\detokenize{lecture_notes/lec15_sets:summary}}\begin{itemize}
\item {} 
Sets in Python realize the notion of a mathematical set, with all the
associated operations.

\item {} 
Operations can be used as method calls or, in many cases, operators.

\item {} 
The combined core operations of finding if a value is in a set and
adding it to the set are \sphinxstylestrong{much faster when using a set} than the
corresponding operations using a list.

\item {} 
We will continue to see examples of programming with sets when we
work with dictionaries.

\end{itemize}


\section{Extra Practice Problems}
\label{\detokenize{lecture_notes/lec15_sets:extra-practice-problems}}\begin{enumerate}
\item {} 
Write Python code that implements the following set functions using a
combination of loops, the \sphinxcode{\sphinxupquote{in}} operator, and the \sphinxcode{\sphinxupquote{add}} function.
In each case, \sphinxcode{\sphinxupquote{s1}} and \sphinxcode{\sphinxupquote{s2}} are sets and the function call should
return a set.
\begin{enumerate}
\item {} 
\sphinxcode{\sphinxupquote{union(s1,s2)}}

\item {} 
\sphinxcode{\sphinxupquote{intersection(s1,s2)}}

\item {} 
\sphinxcode{\sphinxupquote{symmetric\_difference(s1,s2)}}

\end{enumerate}

\end{enumerate}


\chapter{Lecture 15 — Exercises}
\label{\detokenize{lecture_notes/lec15_sets_exercises/exercises:lecture-15-exercises}}\label{\detokenize{lecture_notes/lec15_sets_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for
automatic scoring.  A separate file must submitted for each problem.
Solutions must be submitted by 4 pm on Tuesday, March 20.
\begin{enumerate}
\item {} 
What is the output of the following Python code? Write the answer by
hand before you type it into the Python interpreter.  One thing
that will be hard to guess is the order of the sets, especially
when the set mixes integers and strings.  Therefore, you pretty
much have to run the code to make sure you have the order right.
(At the moment, our use of Submitty is not sophisticated enough to
allow random order.)  This means you get the points almost for
free, but you should make the effort to be sure you understand what
is happening.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s1} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{s2} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{s1}\PYG{o}{.}\PYG{n}{union}\PYG{p}{(}\PYG{n}{s2}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{s1}\PYG{p}{)}

\PYG{n}{s1}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{s1}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{s1}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{s3} \PYG{o}{=} \PYG{n}{s1} \PYG{o}{\textbar{}} \PYG{n}{s2}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{s3}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{s3} \PYG{o}{\PYGZhy{}} \PYG{n}{s1}\PYG{p}{)}
\end{sphinxVerbatim}

Note that this example does NOT cover all of the possible set
operations. You should generate and test your own examples to ensure
that you understand all of the basic set operations.

\item {} 
Write a Python program that asks the user for two strings:  (1) the
name of a file formatted in the same way as the IMDB data, and (2)
a string that is the start of a last name.  The program should
output the number of different last names that are in the file and
it should output the number of different names that start with the
string.  Your program \sphinxstyleemphasis{must} use a \sphinxcode{\sphinxupquote{set}} and you may / are
encouraged to start from
the code written during lecture.

We define a last name to be everything up to the first comma in the
name.  (Some names will not have commas in them, and be careful to
avoid adding empty last names to the set.)   For example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Downey} \PYG{n}{Jr}\PYG{o}{.}\PYG{p}{,} \PYG{n}{Robert} \PYG{o}{\textbar{}} \PYG{n}{Back} \PYG{n}{to} \PYG{n}{School} \PYG{o}{\textbar{}}      \PYG{l+m+mi}{1986}
\PYG{n}{Downey} \PYG{n}{Sr}\PYG{o}{.}\PYG{p}{,} \PYG{n}{Robert}   \PYG{o}{\textbar{}} \PYG{n}{Moment} \PYG{n}{to} \PYG{n}{Moment}  \PYG{o}{\textbar{}} \PYG{l+m+mi}{1975}
\PYG{n}{Downey}\PYG{p}{,} \PYG{n}{Elsie}    \PYG{o}{\textbar{}} \PYG{n}{Moment} \PYG{n}{to} \PYG{n}{Moment}     \PYG{o}{\textbar{}}  \PYG{l+m+mi}{1975}
\end{sphinxVerbatim}

would result in three different last names, \sphinxcode{\sphinxupquote{Downey Jr.}},
\sphinxcode{\sphinxupquote{Downey Sr.}} and \sphinxcode{\sphinxupquote{Downey}}.

Here is one example of running our solution:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Data} \PYG{n}{file} \PYG{n}{name}\PYG{p}{:} \PYG{n}{imdb}\PYG{o}{/}\PYG{n}{imdb\PYGZus{}data}\PYG{o}{.}\PYG{n}{txt}
\PYG{n}{Prefix}\PYG{p}{:} \PYG{n}{Down}
\PYG{l+m+mi}{48754} \PYG{n}{last} \PYG{n}{names}
\PYG{l+m+mi}{10} \PYG{n}{start} \PYG{k}{with} \PYG{n}{Down}
\end{sphinxVerbatim}

Before uploading your Python file to Submitty you should test using
the data files (or restricted versions of them!)  we provided for
Lecture 15 on the Piazza page.  On Submitty we will test with
different files and examples.

\end{enumerate}


\chapter{Lecture 16 — Dictionaries, Part 1}
\label{\detokenize{lecture_notes/lec16_dictionaries1:lecture-16-dictionaries-part-1}}\label{\detokenize{lecture_notes/lec16_dictionaries1::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec16_dictionaries1:overview}}\begin{itemize}
\item {} 
More on IMDB

\item {} 
Dictionaries and dictionary operations

\item {} 
Solutions to the problem of counting how many movies are associated with each individual

\item {} 
Other applications

\end{itemize}


\section{How Many Movies is Each Person Involved In?}
\label{\detokenize{lecture_notes/lec16_dictionaries1:how-many-movies-is-each-person-involved-in}}\begin{itemize}
\item {} 
Goals:
\begin{itemize}
\item {} 
Count movies for each person.

\item {} 
Who is the busiest?

\item {} 
What movies do two people have in common?

\end{itemize}

\item {} 
Best solved with the notion of a dictionary, but we’ll at least
consider how to use a list.

\end{itemize}


\section{List-Based Solution — Straightforward Version}
\label{\detokenize{lecture_notes/lec16_dictionaries1:list-based-solution-straightforward-version}}\begin{itemize}
\item {} 
Core data structure is a list of two-item lists, each giving a
person’s name and the count of movies.

\item {} 
For example, after reading the first seven lines of our shortened
\sphinxcode{\sphinxupquote{hanks.txt}} file, we would have the list

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hanks, Jim}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hanks, Colin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
  \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hanks, Bethan}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hanks, Tom}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
Just like our solution from the sets lectures, we can start from the
following code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{imdb\PYGZus{}file} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter the name of the IMDB file ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{count\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{imdb\PYGZus{}file}\PYG{p}{,} \PYG{n}{encoding} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ISO\PYGZhy{}8859\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{words} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\textbar{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{name} \PYG{o}{=} \PYG{n}{words}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Like our list solution for finding all IMDB people, this solution is
VERY slow — once again \(O(N^2)\) (“order of N squared”).

\end{itemize}


\section{List-Based Solution — Faster Version Based on Sorting}
\label{\detokenize{lecture_notes/lec16_dictionaries1:list-based-solution-faster-version-based-on-sorting}}\begin{itemize}
\item {} 
There is an alternate solution that would work for the number of unique names solution from
lecture 15 as well. It is based on sorting.

\item {} 
Append each name to the end of the list \sphinxstylestrong{without} checking if it is
already there.

\item {} 
After reading all of the movies, sort the entire resulting list
\begin{itemize}
\item {} 
As a result, all instances of each name will now be next to each
other.

\end{itemize}

\item {} 
Go back through the list, counting the occurrence of each name

\item {} 
This solution will be \sphinxstylestrong{much} faster than the first, but it is also
more involved to write than the one we are about to write using
dictionaries

\end{itemize}


\section{Introduction to Dictionaries}
\label{\detokenize{lecture_notes/lec16_dictionaries1:introduction-to-dictionaries}}\begin{itemize}
\item {} 
Association between “keys” (like words in an English dictionary) and
“values” (like definitions in an English dictionary). The values can
be \sphinxstylestrong{anything}.

\item {} 
Examples:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heights} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heights} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}    \PYG{c+c1}{\PYGZsh{} either of these works}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heights}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{belgian horse}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{162.6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heights}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{indian elephant}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{280.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heights}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tiger}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{91.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heights}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lion}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{97.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heights}
\PYG{g+go}{\PYGZob{}\PYGZsq{}belgian horse\PYGZsq{}: 162.6, \PYGZsq{}tiger\PYGZsq{}: 91.0, \PYGZsq{}lion\PYGZsq{}: 97.0, \PYGZsq{}indian elephant\PYGZsq{}: 280.0\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tiger}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{heights}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{giraffe}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{heights}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{91.0} \PYG{o+ow}{in} \PYG{n}{heights}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{heights}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}belgian horse\PYGZsq{}, \PYGZsq{}tiger\PYGZsq{}, \PYGZsq{}lion\PYGZsq{}, \PYGZsq{}indian elephant\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{heights}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}belgian horse\PYGZsq{}, \PYGZsq{}indian elephant\PYGZsq{}, \PYGZsq{}lion\PYGZsq{}, \PYGZsq{}tiger\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heights}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{dict\PYGZus{}values([162.6, 91.0, 97.0, 280.0])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{heights}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[97.0, 162.6, 91.0, 280.0]}
\end{sphinxVerbatim}

\item {} 
Details:
\begin{itemize}
\item {} 
Two initializations; either would work.

\item {} 
Syntax is very much like the subscripting syntax for lists, except
dictionary subscripting/indexing uses keys instead of integers!

\item {} 
The keys, in this example, are animal species (or subspecies)
names; the values are floats.

\item {} 
The \sphinxcode{\sphinxupquote{in}} method tests only for the presence of the key, like
looking up a word in the dictionary without checking its
definition.

\item {} 
The keys are NOT ordered.

\end{itemize}

\item {} 
Just as in sets, the implementation uses \sphinxstyleemphasis{hashing} of keys.
\begin{itemize}
\item {} 
Conceptually, sets are dictionaries without values.

\end{itemize}

\end{itemize}


\section{Lecture Exercise 1}
\label{\detokenize{lecture_notes/lec16_dictionaries1:lecture-exercise-1}}
You will have five minutes to work on the first lecture exercise.


\section{Back to Our IMDB Problem}
\label{\detokenize{lecture_notes/lec16_dictionaries1:back-to-our-imdb-problem}}\begin{itemize}
\item {} 
Even though our coverage of dictionaries has been brief, we already
have enough tools to solve our problem of counting movies.

\item {} 
Once again we’ll use the following as a starting point

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{imdb\PYGZus{}file} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter the name of the IMDB file ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{counts} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{imdb\PYGZus{}file}\PYG{p}{,} \PYG{n}{encoding} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ISO\PYGZhy{}8859\PYGZhy{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{words} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\textbar{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{name} \PYG{o}{=} \PYG{n}{words}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
The solution we give in class will output the counts for the first
100 individuals in alphabetical order.  It will be up to you as an
exercise to find the most frequently occuring individual.

\item {} 
We will impose an ordering on the output by sorting the keys.

\item {} 
We’ll test first on our smaller data set and then again later on our
larger ones.

\end{itemize}


\section{Key Types}
\label{\detokenize{lecture_notes/lec16_dictionaries1:key-types}}\begin{itemize}
\item {} 
Thus far, the \sphinxstyleemphasis{keys} in our dictionary have been strings.

\item {} 
Keys can be any “hashable” type — string, int, float, booleans, tuples.
\begin{itemize}
\item {} 
Lists, sets and other dictionaries can not be keys.

\end{itemize}

\item {} 
Strings are by far the most common key type

\item {} 
We will see an example of integers as the key type by the end of
the Lecture 17 (next set of) notes.

\item {} 
Float and boolean are general poor choices. Can you think why?

\end{itemize}


\section{Value Types}
\label{\detokenize{lecture_notes/lec16_dictionaries1:value-types}}\begin{itemize}
\item {} 
So far, the \sphinxstyleemphasis{values} in our dictionaries have been integers and
floats.

\item {} 
But, any type can be the values
\begin{itemize}
\item {} 
boolean

\item {} 
int

\item {} 
float

\item {} 
string

\item {} 
list

\item {} 
tuple

\item {} 
set

\item {} 
other dictionaries

\end{itemize}

\item {} 
Here is an example using our IMDB code and a set:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{people} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{people}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hanks, Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{people}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hanks, Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Big}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{people}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hanks, Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Splash}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{people}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hanks, Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Forest Gump}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{people}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hanks, Tom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}Forest Gump\PYGZsq{}, \PYGZsq{}Big\PYGZsq{}, \PYGZsq{}Splash\PYGZsq{}\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
Here is another example where we store the continent and the
population for a country instead of just the population:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{countries} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{countries}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{countries}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Algeria}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=}  \PYG{p}{(}\PYG{l+m+mi}{37100000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Africa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{countries}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Canada}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{34945200}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{North America}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
\PYG{n}{countries}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Uganda}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{32939800}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Africa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{countries}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Morocco}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{32696600}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Africa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{countries}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sudan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{30894000}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Africa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We access the values in the entries using \sphinxstyleemphasis{two consecutive
subscripts}. For example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Canada}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The population of }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{ is }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{countries}\PYG{p}{[}\PYG{n}{name}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{It is in the continent of}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{countries}\PYG{p}{[}\PYG{n}{name}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Removing Values: Sets and Dictionaries}
\label{\detokenize{lecture_notes/lec16_dictionaries1:removing-values-sets-and-dictionaries}}\begin{itemize}
\item {} 
For a set:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{discard}} removes the specified element, and does nothing if it
is not there

\item {} 
\sphinxcode{\sphinxupquote{remove}} removes the specified element, but fails (throwing an
exception) if it is not there

\end{itemize}

\item {} 
For a dictionary, it is the \sphinxcode{\sphinxupquote{del}} function.

\item {} 
For both sets and dictionaries, the \sphinxcode{\sphinxupquote{clear}} method empties the
container.

\item {} 
We will look at toy examples in class

\end{itemize}


\section{Other Dictionary Methods}
\label{\detokenize{lecture_notes/lec16_dictionaries1:other-dictionary-methods}}\begin{itemize}
\item {} 
The following dictionary methods are useful, but not so much as the
ones we’ve discussed.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{get}}

\item {} 
\sphinxcode{\sphinxupquote{pop}}

\item {} 
\sphinxcode{\sphinxupquote{popitem}}

\item {} 
\sphinxcode{\sphinxupquote{update}}

\end{itemize}

\item {} 
Use the \sphinxcode{\sphinxupquote{help}} function in Python to figure out how to use them and
to find other dictionary methods.

\end{itemize}


\section{Summary of Dictionaries}
\label{\detokenize{lecture_notes/lec16_dictionaries1:summary-of-dictionaries}}\begin{itemize}
\item {} 
Associate “keys” with “values”

\item {} 
Feels like indexing, except we are using keys instead of integer
indices.

\item {} 
Makes counting and a number of other operations simple and fast.

\item {} 
Keys can be any “hashable” value, usually strings, sometimes
integers.

\item {} 
Values can any type whatsoever.

\end{itemize}


\section{Additional Practice}
\label{\detokenize{lecture_notes/lec16_dictionaries1:additional-practice}}\begin{enumerate}
\item {} 
Write a function that takes the IMDB dictionary — which associates
strings representing names with integers representing the count of
movies — and an integer representing a \sphinxcode{\sphinxupquote{min\_count}}, and removes all
individuals from the dictionary involved in fewer than \sphinxcode{\sphinxupquote{min\_count}}
movies.

\end{enumerate}


\chapter{Lecture 16 — Exercises}
\label{\detokenize{lecture_notes/lec16_dictionaries1_exercises/exercises:lecture-16-exercises}}\label{\detokenize{lecture_notes/lec16_dictionaries1_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for
automatic scoring.  A separate file must submitted for each problem.
Solutions must be submitted by 4 pm on Tuesday, March 21.
\begin{enumerate}
\item {} 
Write a Python program that forms a dictionary called \sphinxcode{\sphinxupquote{countries}}
that associates the population with each of the following
countries (in millions):
\begin{itemize}
\item {} 
Algeria 37.1

\item {} 
Canada 3.49

\item {} 
Uganda 32.9

\item {} 
Morocco 32.7

\item {} 
Sudan 30.9

\item {} 
Canada 34.9   \# a correction to the error above.

\end{itemize}

and then prints the length of the \sphinxcode{\sphinxupquote{countries}} dictionary, the
sorted list of the keys in \sphinxcode{\sphinxupquote{countries}} and a sorted list of the
values in \sphinxcode{\sphinxupquote{countries}}.  There should be six assignment statements
in your program (seven if you include initializing the dictionary)
and three lines of output from your program.
Please initialize your dictionary using \sphinxcode{\sphinxupquote{dict()}} rather than \sphinxcode{\sphinxupquote{\{\}}}

\item {} 
Our solution to the IMDB problem thus far has not actually told us
who is the busiest individual in the Internet movie database.
Your job in this part is to complete this task.  Starting from the
code produced in class, which will be immediately posted on the
course website (in the \sphinxstyleemphasis{Code written in class} area), write a
program that finds and prints the name of the individual who
appears the most times in the IMDB file you are given.  Also, count
and output the number of individuals who appear only 1 time in the
IMDB.

For example if the answer were \sphinxcode{\sphinxupquote{Thumb, Toni}} and this
person had appeared 100 times, and if 2,000 people had only
appeared once, then your output should be

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Enter} \PYG{n}{the} \PYG{n}{name} \PYG{n}{of} \PYG{n}{the} \PYG{n}{IMDB} \PYG{n}{file} \PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{imdb\PYGZus{}data}\PYG{o}{.}\PYG{n}{txt}
\PYG{n}{Thumb}\PYG{p}{,} \PYG{n}{Toni} \PYG{n}{appears} \PYG{n}{most} \PYG{n}{often}\PYG{p}{:} \PYG{l+m+mi}{100} \PYG{n}{times}
\PYG{l+m+mi}{2000} \PYG{n}{people} \PYG{n}{appear} \PYG{n}{once}
\end{sphinxVerbatim}

We strongly suggest that you test your solution on the
\sphinxcode{\sphinxupquote{hanks.txt}} dataset first!  We will test on multiple files.  You
do not need to worry about the possibility of a tie for the most
commonly occuring name.  Please initialize your dictionary using
\sphinxcode{\sphinxupquote{dict()}} rather than \sphinxcode{\sphinxupquote{\{\}}}

\end{enumerate}


\chapter{Lecture 17 — Dictionaries, Part 2}
\label{\detokenize{lecture_notes/lec17_dictionaries2:lecture-17-dictionaries-part-2}}\label{\detokenize{lecture_notes/lec17_dictionaries2::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec17_dictionaries2:overview}}\begin{itemize}
\item {} 
Recap

\item {} 
More IMDB examples:
\begin{itemize}
\item {} 
Dictionaries of string/set pairs

\item {} 
Converting dictionaries with one key to another

\item {} 
Combining information from multiple dictionaries

\end{itemize}

\item {} 
A different view of dictionaries: storing attribute/value pairs.

\item {} 
Accessing APIs and getting data back as a dictionary.

\end{itemize}


\section{Recap of dictionaries}
\label{\detokenize{lecture_notes/lec17_dictionaries2:recap-of-dictionaries}}\begin{itemize}
\item {} 
On the surface, dictionaries look like lists, except, you can have
anything for indices (keys), not just numbers starting with 0.

\item {} 
The following two store the same information:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{listoption} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dictoption} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Note that this is a new way for us to initialize a dictionary.

\item {} 
You would access them in the same way:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{listoption}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}b\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dictoption}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}b\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
You would update them in the same way:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{listoption}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dictoption}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\item {} 
But you can’t extend them in the same way.  For example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{listoption}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

is illegal, but:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dictoption}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

is perfectly fine.  Be sure you can explain why.

\item {} 
Of course the power of a dictionary is that keys can be anything, or at least anything
\sphinxstyleemphasis{hashable}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gru}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Margo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gru}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{3}
\end{sphinxVerbatim}

\item {} 
This dictionary has strings as keys and integers as values.
The values can really be anything:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d2} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gru}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n+nb}{set}\PYG{p}{(} \PYG{p}{[}\PYG{l+m+mi}{123}\PYG{p}{,}\PYG{l+m+mi}{456}\PYG{p}{]} \PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Margo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n+nb}{set}\PYG{p}{(} \PYG{p}{[}\PYG{l+m+mi}{456}\PYG{p}{]} \PYG{p}{)} \PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d2}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gru}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{\PYGZob{}456, 123\PYGZcb{}}
\end{sphinxVerbatim}

\item {} 
Note that since keys can be anything, we need to know how to print or iterate through the
values in a dictionary.  This is actually quite trivial using a dictionary:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d2}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{dict\PYGZus{}keys([\PYGZsq{}Gru\PYGZsq{}, \PYGZsq{}Margo\PYGZsq{}])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{d2}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}Gru\PYGZsq{}, \PYGZsq{}Margo\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{d2}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{}  or, for key in d2.keys():}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{d2}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{Gru \PYGZob{}[123, 456]\PYGZcb{}}
\PYG{g+go}{Margo \PYGZob{}[456]\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}


\section{Copying and Aliasing Dictionaries}
\label{\detokenize{lecture_notes/lec17_dictionaries2:copying-and-aliasing-dictionaries}}\begin{itemize}
\item {} 
We’ll take a few minutes in class for you to try to predict the
output of the following:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{d}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hi}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{L}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{n}{d}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bye}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{L}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{d}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{d}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hello}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{del} \PYG{n}{d}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
The result may surprise you, but it reflects the difference between
making an alias to an object and making a full copy of an object.
\begin{itemize}
\item {} 
An alias is also sometimes known as a \sphinxstyleemphasis{shallow copy}

\item {} 
A full copy is also sometimes known as a \sphinxstyleemphasis{deep copy}

\end{itemize}

\item {} 
Assignment between lists, between sets, and between dictionaries all
involve aliasing / shallow copying!

\item {} 
At this point we will take a few minutes for you to work on the
first lecture exercise.

\end{itemize}


\section{Back to IMDB: Dictionaries Whose Values Are Sets}
\label{\detokenize{lecture_notes/lec17_dictionaries2:back-to-imdb-dictionaries-whose-values-are-sets}}\begin{itemize}
\item {} 
In our IMDB data, an individual may be listed more than once for
each movie.  For example, Tom Hanks is listed six times for \sphinxstyleemphasis{Polar
Express}

\item {} 
In order to determine who was involved in the most different
movies, we need to keep a set of movies for each individual instead
of a count.

\item {} 
We will modify our solution to the IMDB example to find out who was
involved in the most different movies.
\begin{itemize}
\item {} 
The solution will be posted on the course website.

\end{itemize}

\end{itemize}


\section{Converting to Other Dictionaries:  The N Busiest Individuals}
\label{\detokenize{lecture_notes/lec17_dictionaries2:converting-to-other-dictionaries-the-n-busiest-individuals}}\begin{itemize}
\item {} 
Suppose we want to find the top 10 or 25 busiest individuals in the
IMDB, based on the number of different movies they are involved in.

\item {} 
Now we need a different dictionary:
\begin{itemize}
\item {} 
Keys are integers representing the number of movies

\item {} 
Values are lists of actors.
\begin{itemize}
\item {} 
Why don’t we need sets here?

\end{itemize}

\end{itemize}

\item {} 
We will show how to extend our code to build this dictionary from
our original dictionary.

\item {} 
Next, we will need to access the keys from this dictionary in
reverse order and print out names of the individuals, stopping when
we’ve printed the top \sphinxcode{\sphinxupquote{N}} busiest (allowing more in the case of
ties).

\end{itemize}


\section{More That We Can Do With the IMDB}
\label{\detokenize{lecture_notes/lec17_dictionaries2:more-that-we-can-do-with-the-imdb}}\begin{itemize}
\item {} 
We now have an actors dictionary whose keys are actor names and
whose values are sets of movies.

\item {} 
We can also construct a different dictionary whose keys are movies
and whose values are sets of actors.

\item {} 
Using this we can find all sorts of information:
\begin{itemize}
\item {} 
What movie involved the most people?

\item {} 
How many different people have been in movies that included
Meryl Streep?

\item {} 
Solve the “degrees of Kevin Bacon” problem:
\begin{enumerate}
\item {} 
Who has been in a movie with Kevin Bacon?  These people are
degree 1.

\item {} 
Who is not a degree 1 individual and has been in a movie with
a person who was in a movie with Kevin Bacon?  These people
are degree 2 individuals.

\item {} 
Who is not a degree 1 or 2 individual, and has been in a
movie with a degree 2 individual (in a movie with a person
who has been in a movie with a person who was in a movie with
Kevin Bacon)?  These people are degree 3 individuals.

\item {} 
Etc.

\end{enumerate}

\end{itemize}

\end{itemize}


\section{Attribute / Value Pairs}
\label{\detokenize{lecture_notes/lec17_dictionaries2:attribute-value-pairs}}\begin{itemize}
\item {} 
We can use dictionaries to construct even more complicated data
structures: dictionaries as values, lists of dictionaries, etc.

\item {} 
Consider the problem of representing all the houses a real estate
company is trying to sell.

\item {} 
We could keep a list with information about each property, but a list
of what?

\item {} 
We will look at describing each house as a dictionary, with the keys
being the “attributes”, and the values being, well, the values of the
attributes.

\item {} 
Examples include the listing reference number, the address, the
number of bedrooms, the price, whether or not it has a pool, the
style of the house, the age, etc.
\begin{itemize}
\item {} 
Some properties will not be known and therefore they will not be
represented in the dictionary.

\end{itemize}

\item {} 
We will work through a made-up example in class, producing a list of
dictionaries. This list will be called \sphinxcode{\sphinxupquote{houses}}.

\item {} 
As an exercise you can think about write coding that finds all
houses in our house list that have at least 4 bedrooms (attribute
is \sphinxcode{\sphinxupquote{bedrooms}}, value is an integer), a pool (attribute is
\sphinxcode{\sphinxupquote{pool}}, value a string describing if the pool is above ground or
below), for a price below \$300,000 (atttribute is \sphinxcode{\sphinxupquote{price}}, value
is an int).

\item {} 
Overall, this a simple Python implementation of the storage and
access of information in a \sphinxstyleemphasis{database}.

\end{itemize}


\section{Accessing APIs}
\label{\detokenize{lecture_notes/lec17_dictionaries2:accessing-apis}}\begin{itemize}
\item {} 
Many APIs (Application Programming Interfaces) accessible on the
internet return values that are \sphinxstylestrong{JSON} (Java Script Object
Notation) strings.  These are easily loaded into Python objects,
often involving dictionaries.

\item {} 
The best way to understand the dictionary structure returned by an API
is to seek documentation. If that fails, you can print the top
level keys and values to explore.

\item {} 
Public APIs, which do not not require authentication, are accessed
as follows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{urllib}\PYG{n+nn}{.}\PYG{n+nn}{request}
\PYG{k+kn}{import} \PYG{n+nn}{json}

\PYG{n}{url} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{enter your public url here}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{urllib}\PYG{o}{.}\PYG{n}{request}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{url}\PYG{p}{)}
\PYG{n}{rawcontent} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{content} \PYG{o}{=} \PYG{n}{json}\PYG{o}{.}\PYG{n}{loads}\PYG{p}{(}\PYG{n}{rawcontent}\PYG{o}{.}\PYG{n}{decode}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{utf\PYGZhy{}8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
An example of a public API (used in our image lab):
\begin{itemize}
\item {} 
\sphinxstylestrong{nominatim} gives you a bounding box of geolocation for a given
location. Let’s see this for ‘Troy, NY’:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{url} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http://nominatim.openstreetmap.org/}\PYG{l+s+s2}{\PYGZdq{}}\PYGZbs{}
      \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{search?q=}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZam{}format=json\PYGZam{}polygon\PYGZus{}geojson=1\PYGZam{}addressdetails=0}\PYG{l+s+s2}{\PYGZdq{}}\PYGZbs{}
      \PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Troy,NY}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
Many sources require authentication with an API key through the
\sphinxcode{\sphinxupquote{oauth2}} authentication module. But, the overall method of access
remains the same after authentication.

\item {} 
Once we understand the structure, we can write code to extract the
information we want.

\end{itemize}


\section{Final Example}
\label{\detokenize{lecture_notes/lec17_dictionaries2:final-example}}\begin{enumerate}
\item {} 
Given the following dictionary for hobbies for people:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hobby} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gru}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hiking}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cooking}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Edith}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hiking}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Board Games}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

create a new dictionary that lists people for each hobby:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hiking}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gru}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Edith}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cooking}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gru}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Board Games}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Edith}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{enumerate}


\section{Summary}
\label{\detokenize{lecture_notes/lec17_dictionaries2:summary}}\begin{itemize}
\item {} 
Dictionaries of sets.

\item {} 
Dictionaries where the keys are numbers.

\item {} 
A variety of examples to extract information from the IMDB data set.

\item {} 
Dictionaries as database — storing attribute / value pairs.

\item {} 
Accessing information from public APIs

\end{itemize}


\section{Additional Dictionary Practice Problems}
\label{\detokenize{lecture_notes/lec17_dictionaries2:additional-dictionary-practice-problems}}\begin{enumerate}
\item {} 
Create a dictionary to store the favorite colors of the following
individuals
\begin{itemize}
\item {} 
Thomas prefers red

\item {} 
Ashok prefs green

\item {} 
Sandy prefers red

\item {} 
Alison prefers orange

\item {} 
Fei prefers green

\item {} 
Natasha prefs blue

\end{itemize}

Then add some others of your own. Now, write code to change Fei’s
preference to green and to remove Sandy’s preference from the
dictionary.

\item {} 
Using the dictionary from the first problem, write code to find which
color is most commonly preferred. Use a second dictionary, one that
associates strings (representing the colors) with the counts. Output
the most common color. If there are ties, output all tied colors.

\item {} 
Complete the fast, list solution to the movie counting problem based
on sorting, as outlined at the start of the lecture notes.

\item {} 
Write a program that uses a dictionary that associates integers
(the key) and sets strings (the values) to find the number of
movies in each year of the IMDB. Start from any of the IMDB examples.
Write additional code
that uses the \sphinxcode{\sphinxupquote{years\_and\_movies}} dictionary to find the year that
has the most movies.

\item {} 
Use a dictionary to determine which last names are most common in the
IMDB data we have provided. Count individual people not the movies
they appear in. For example, \sphinxcode{\sphinxupquote{'Hanks, Tom'}} counts as one instance
of the name \sphinxcode{\sphinxupquote{'Hanks"}} despite the fact that he is in many movies.
Assume that the last name ends with the first \sphinxcode{\sphinxupquote{','}} in the actual
name. Start this problem by thinking about what the dictionary keys
and values should be.

\item {} 
Which two individuals have the most movies in common? To solve this
you will need to start from the dictionary that associates each
individual with the set of movies s/he is involved in. Then you will
need double for loops.  At first glance this appears that it might
be very, very slow, but it can be made much faster by intelligently
terminating loops.  To illustrate, if you find a pair of
individuals with k movies in common then you never have to even
consider an individual involved in fewer than k movies!

\end{enumerate}


\chapter{Lecture 17 — Exercises}
\label{\detokenize{lecture_notes/lec17_dictionaries2_exercises/exercises:lecture-17-exercises}}\label{\detokenize{lecture_notes/lec17_dictionaries2_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for
automatic scoring.  A separate file must submitted for each problem.
Solutions must be submitted by 4 pm on Friday, March 30.
\begin{enumerate}
\item {} 
What is the output of the following code?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d1} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{l1} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7} \PYG{p}{]}
\PYG{n}{d1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{car}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{l1}
\PYG{n}{d1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{l1}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{l1}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(} \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]} \PYG{p}{)}
\PYG{n}{d1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{truck}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{d1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{d1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{truck}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{list:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{l1}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{d1}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{: }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{v}\PYG{p}{,} \PYG{n}{d1}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]} \PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Write a Python program that finds the name of the movie in our
Internet Movie Database that involved the most \sphinxstyleemphasis{unique} individuals. Print
the name of the movie on one line and the number of individuals on
the next line.  You do not need to consider the possibility of
ties and you should assume all actors and movies have the correct
capitalization.  Finally, print the number of movies involving only one
individual (yes, there are such movies).  For example, if the name
of the movie is \sphinxstyleemphasis{Ben Hur} with 2,342 individuals, and 165 movies
have only one individual then the output from your program will
look like:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Enter} \PYG{n}{the} \PYG{n}{name} \PYG{n}{of} \PYG{n}{the} \PYG{n}{IMDB} \PYG{n}{file} \PYG{o}{==}\PYG{o}{\PYGZgt{}} \PYG{n}{imdb\PYGZus{}data}\PYG{o}{.}\PYG{n}{txt}
\PYG{l+m+mi}{2342}
\PYG{n}{Ben} \PYG{n}{Hur}
\PYG{l+m+mi}{165}
\end{sphinxVerbatim}

Note that you only need to create one dictionary for this
exercise.  Start by planning the organization of this dictionary
and thinking through how you are going to use it. As with Lecture Exercises
16, make sure you use \sphinxstyleemphasis{dict()} to initialize your empty dictionary.

\end{enumerate}


\chapter{Lecture 18 — Classes, Part 1}
\label{\detokenize{lecture_notes/lec18_classes1:lecture-18-classes-part-1}}\label{\detokenize{lecture_notes/lec18_classes1::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec18_classes1:overview}}\begin{itemize}
\item {} 
Define our own types and associated functions

\item {} 
Encapsulate data and functionality

\item {} 
Raise the “level of abstraction” in our code

\item {} 
Make code easier to write and test

\item {} 
Reuse code

\end{itemize}


\section{Potential Examples}
\label{\detokenize{lecture_notes/lec18_classes1:potential-examples}}
In each of these, think about what data you might need to store to
represent the “object” and what functionality you might need to apply to
the data.
\begin{itemize}
\item {} 
Date

\item {} 
Time

\item {} 
Point

\item {} 
Rectangle

\item {} 
Student

\item {} 
Animal

\item {} 
Molecule

\end{itemize}


\section{An Example from Earlier in the Semester}
\label{\detokenize{lecture_notes/lec18_classes1:an-example-from-earlier-in-the-semester}}\begin{itemize}
\item {} 
Think about how difficult it was to keep track of the information
about each restaurant in the Yelp data.

\item {} 
You had to:
\begin{itemize}
\item {} 
Remember the indices of (a) the restaurant name, (b) the latitude
and longitude, (c) the type of restaurant, (d) the address, etc.

\item {} 
Form a separate list inside the list for the ratings.

\item {} 
Write additional functions to exploit this information

\end{itemize}

\item {} 
If we used a class to represent each restaurant:
\begin{itemize}
\item {} 
All of the information about the restaurant would be stored and
accessed as named attributes

\item {} 
Information about the restaurants would be accessed through
functions that we write for the class.

\end{itemize}

\end{itemize}


\section{Point2d Class}
\label{\detokenize{lecture_notes/lec18_classes1:point2d-class}}\begin{itemize}
\item {} 
Simplest step is to just tell Python that \sphinxcode{\sphinxupquote{Point2d}} will exist as a
class, deferring the addition of information until later.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Point2d}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}
\end{sphinxVerbatim}

\item {} 
The Python reserved word \sphinxcode{\sphinxupquote{pass}} says that this is the end of the
class definition.
\begin{itemize}
\item {} 
We will not need this later when we put information into the
class.

\end{itemize}

\end{itemize}


\section{Attributes}
\label{\detokenize{lecture_notes/lec18_classes1:attributes}}\begin{itemize}
\item {} 
Classes do not get interesting until we put something in them.

\item {} 
The first thing we want is variables so that we can put data into a
class.
\begin{itemize}
\item {} 
In Python these variables are often called \sphinxstyleemphasis{attributes}.

\item {} 
Other languages call them \sphinxstyleemphasis{member variables}.

\end{itemize}

\item {} 
We will see three different ways to specify attributes.

\end{itemize}


\section{Assigning Attributes to Each Instance}
\label{\detokenize{lecture_notes/lec18_classes1:assigning-attributes-to-each-instance}}\begin{itemize}
\item {} 
Points have an \sphinxcode{\sphinxupquote{x}} and a \sphinxcode{\sphinxupquote{y}} location, so we can write, for
example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k}{import} \PYG{n}{sqrt}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{Point2d}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{p}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{p}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{dist\PYGZus{}from\PYGZus{}origin} \PYG{o}{=} \PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{p}\PYG{o}{.}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{p}\PYG{o}{.}\PYG{n}{y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We have to do this for each class instance.

\item {} 
This is prone to mistakes:
\begin{itemize}
\item {} 
Could forget to assign the attributes

\item {} 
Could accidentally use different names for what is intended to be
the same attribute.

\end{itemize}

\item {} 
Example of an error

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{q} \PYG{o}{=} \PYG{n}{Point2d}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{q}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}
\PYG{n}{dist\PYGZus{}from\PYGZus{}origin} \PYG{o}{=} \PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{q}\PYG{o}{.}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{q}\PYG{o}{.}\PYG{n}{y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} q.y does not exist}
\end{sphinxVerbatim}

\end{itemize}


\section{Defining the Attributes Inside the Class}
\label{\detokenize{lecture_notes/lec18_classes1:defining-the-attributes-inside-the-class}}\begin{itemize}
\item {} 
The simplest way to make sure that all variables that are instances
of a class have the appropriate attributes is to define them inside
the class.

\item {} 
For example, we could redefine our class as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Point2d}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\item {} 
All instances of \sphinxcode{\sphinxupquote{Point2d}} now have two attributes, \sphinxcode{\sphinxupquote{x}} and
\sphinxcode{\sphinxupquote{y}}, and they are each initialized to 0.

\item {} 
We no longer need the \sphinxcode{\sphinxupquote{pass}} because there is now something in the
class.

\end{itemize}


\section{Defining the Attributes Through An Initializer / Constructor}
\label{\detokenize{lecture_notes/lec18_classes1:defining-the-attributes-through-an-initializer-constructor}}\begin{itemize}
\item {} 
We still need to initialize \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}} to values other than
\sphinxcode{\sphinxupquote{0}}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{Point2d}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{p}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{p}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\item {} 
What we’d really like to do is initialize them at the time we
actually create the \sphinxcode{\sphinxupquote{Point2d}} object:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{Point2d}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We do this through a special function called an \sphinxstyleemphasis{initializer} in
Python and a \sphinxstyleemphasis{constructor} in some other programming languages.

\item {} 
Inside the class this looks like

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Point2d}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(} \PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{y0} \PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{x0}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{y0}
\end{sphinxVerbatim}

\item {} 
Our code to create the point now becomes

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{Point2d}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Notes:
\begin{itemize}
\item {} 
Python uses names that start and end with two \sphinxcode{\sphinxupquote{'\_'}} to indicate
functions with special meanings.  More on this later in the lecture.

\item {} 
The name \sphinxcode{\sphinxupquote{self}} is special notation to indicate that the object
itself is passed to the function.

\end{itemize}

\item {} 
If we’d like to initialize the point to \((0,0)\) without passing
these values to the constructor every time then we can specify
default arguments

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Point2d}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(} \PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x0}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{y0}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{x0}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{y0}
\end{sphinxVerbatim}

allowing the initalization

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{Point2d}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Methods — Functions Associated with the Class}
\label{\detokenize{lecture_notes/lec18_classes1:methods-functions-associated-with-the-class}}\begin{itemize}
\item {} 
We create functions that operate on the class objects inside the
class definition:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{k}{class} \PYG{n+nc}{Point2d}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(} \PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{,} \PYG{n}{y0} \PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{x0}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{y0}

    \PYG{k}{def} \PYG{n+nf}{magnitude}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{o}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{o}\PYG{o}{.}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{o}\PYG{o}{.}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{p}{)}
\end{sphinxVerbatim}

these are called \sphinxstyleemphasis{methods}

\item {} 
This is used as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{Point2d}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{q} \PYG{o}{=} \PYG{n}{Point2d}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{leng} \PYG{o}{=} \PYG{n}{q}\PYG{o}{.}\PYG{n}{magnitude}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Magnitude }\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{leng} \PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Distance is }\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(} \PYG{n}{p}\PYG{o}{.}\PYG{n}{dist}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
The method \sphinxcode{\sphinxupquote{magnitude}} takes a single argument, which is the
\sphinxcode{\sphinxupquote{Point2d}} object called \sphinxcode{\sphinxupquote{self}}.  Let’s examine this:
\begin{itemize}
\item {} 
The call \sphinxcode{\sphinxupquote{q.magnitude()}} appears to have no arguments, but
when Python sees this, it turns it into its equivalent:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Point2d}\PYG{o}{.}\PYG{n}{magnitude}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
\end{sphinxVerbatim}

which is completely legal Python syntax.

\item {} 
The name \sphinxcode{\sphinxupquote{self}} is not technically special in Python, but it
is used by convention to refer to the object that the method is
“called upon”.  This is  \sphinxtitleref{q{}`} in the call \sphinxcode{\sphinxupquote{q.magnitude()}}

\end{itemize}

\item {} 
The method \sphinxcode{\sphinxupquote{dist}} takes two \sphinxcode{\sphinxupquote{Point2d}} objects as
arguments.  The example call

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p}\PYG{o}{.}\PYG{n}{dist}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
\end{sphinxVerbatim}

becomes

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Point2d}\PYG{o}{.}\PYG{n}{dist}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{q}\PYG{p}{)}
\end{sphinxVerbatim}

so now argument \sphinxcode{\sphinxupquote{p}} maps to parameter \sphinxcode{\sphinxupquote{self}} and argument \sphinxcode{\sphinxupquote{q}}
maps to parameters \sphinxcode{\sphinxupquote{o}}

\end{itemize}


\section{Lecture Exercises, Part 1}
\label{\detokenize{lecture_notes/lec18_classes1:lecture-exercises-part-1}}
Our lecture exercises for today will involve adding to the \sphinxcode{\sphinxupquote{Point2d}}
class and testing it.  Make sure you have downloaded the
\sphinxcode{\sphinxupquote{Point2d.py}} file from the Piazza site.

We will allow some time to work on the first lecture exercise.


\section{Operators and Other Special Functions}
\label{\detokenize{lecture_notes/lec18_classes1:operators-and-other-special-functions}}\begin{itemize}
\item {} 
We’d like to write code that uses our new objects in the most
intuitive way possible.

\item {} 
For our point class, this involves use of operators such as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{Point2d}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{q} \PYG{o}{=} \PYG{n}{Point2d}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{r} \PYG{o}{=} \PYG{n}{p}\PYG{o}{+}\PYG{n}{q}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{n}{q}
\PYG{n}{t} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{s}
\end{sphinxVerbatim}

\item {} 
Notice how in each case, we work with the \sphinxcode{\sphinxupquote{Point2d}} variables
(objects) just like we do with int and float variable (objects).

\item {} 
We implement these by writing the special functions \sphinxcode{\sphinxupquote{\_\_add\_\_}},
\sphinxcode{\sphinxupquote{\_\_sub\_\_}}, and \sphinxcode{\sphinxupquote{\_\_neg\_\_}}

\item {} 
For example, inside the \sphinxcode{\sphinxupquote{Point2d}} class we might have

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{other}\PYG{p}{)}\PYG{p}{:}
     \PYG{k}{return} \PYG{n}{Point2d}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{n}{other}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{y}\PYG{o}{+}\PYG{n}{other}\PYG{o}{.}\PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

Very important:  this creates a new \sphinxcode{\sphinxupquote{Point2d}} object.

\item {} 
When Python sees \sphinxcode{\sphinxupquote{p+q}}, it turns it into the function call

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Point2d}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{q}\PYG{p}{)}
\end{sphinxVerbatim}

which is exactly the syntax of the function definition we created.

\item {} 
We have already seen this with operators on integers and strings.
As examples,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{l+m+mi}{6}
\end{sphinxVerbatim}

is equivalent to

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}
\end{sphinxVerbatim}

and

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{)}
\end{sphinxVerbatim}

is equivalent to

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Implicit in this discussion is the notion that \sphinxcode{\sphinxupquote{int}} is in fact a
class in Python.  The same is true of \sphinxcode{\sphinxupquote{str}} and \sphinxcode{\sphinxupquote{float}} and
\sphinxcode{\sphinxupquote{list}}.

\item {} 
Note that we can also define boolean operators such as \sphinxcode{\sphinxupquote{==}} and \sphinxcode{\sphinxupquote{!=}}
through the special functions \sphinxcode{\sphinxupquote{\_\_eq\_\_}} and \sphinxcode{\sphinxupquote{\_\_neq\_\_}}

\end{itemize}


\section{Classes and Modules}
\label{\detokenize{lecture_notes/lec18_classes1:classes-and-modules}}\begin{itemize}
\item {} 
Each class should generally be put into its own module, or several
closely-related classes should be combined in a single module.
\begin{itemize}
\item {} 
We are already doing this with \sphinxcode{\sphinxupquote{Point2d}}.

\end{itemize}

\item {} 
Doing so is good practice for languages like C++ and Java, where
classes are placed in separate files.

\item {} 
Testing code can be included in the module or placed in a separate
module.

\item {} 
We will demonstrate this in class and post the result on the course
website.

\end{itemize}


\section{More Lecture Exercises}
\label{\detokenize{lecture_notes/lec18_classes1:more-lecture-exercises}}
At this point we will stop and take a bit of time to work on the next
part of the lecture exercises.


\section{When to Modify, When to Create New Object}
\label{\detokenize{lecture_notes/lec18_classes1:when-to-modify-when-to-create-new-object}}\begin{itemize}
\item {} 
Some methods, such as \sphinxcode{\sphinxupquote{scale}}, modify a single \sphinxcode{\sphinxupquote{Point2d}} object

\item {} 
Other methods, such as our operators, create new \sphinxcode{\sphinxupquote{Point2d}} objects
without modifying existing ones.

\item {} 
The choice between this is made on a method-by-method basis by
thinking about the meaning — the \sphinxstyleemphasis{semantics} — of the behavior of the
method.

\end{itemize}


\section{Programming Conventions}
\label{\detokenize{lecture_notes/lec18_classes1:programming-conventions}}\begin{itemize}
\item {} 
Don’t create attributes outside the class.

\item {} 
Don’t directly access or change attributes except through class
methods.
\begin{itemize}
\item {} 
Languages like C++ and Java have constructions that enforce this.

\item {} 
In languages like Python it is not a hard-and-fast rule.

\end{itemize}

\item {} 
Class design is often most effective by thinking about the required
methods rather than the required attributes.
\begin{itemize}
\item {} 
As an example, we rarely think about how the Python \sphinxcode{\sphinxupquote{list}} and
\sphinxcode{\sphinxupquote{dict}} classes are implemented.

\end{itemize}

\end{itemize}


\section{Time Example}
\label{\detokenize{lecture_notes/lec18_classes1:time-example}}\begin{itemize}
\item {} 
In the remainder of the lecture, we will work through an extended
example of a \sphinxcode{\sphinxupquote{Time}} class

\item {} 
By this, we mean the time of day, measured in hours, minutes and
seconds.

\item {} 
We’ll brainstorm some of the methods we might need to have.

\item {} 
We’ll then consider several different ways to represent the time
internally:
\begin{itemize}
\item {} 
Hours, minutes and seconds

\item {} 
Seconds only

\item {} 
Military time

\end{itemize}

\item {} 
Despite potential internal differences, the methods — or at least the
way we call them — will remain the same
\begin{itemize}
\item {} 
This is an example of the notion of \sphinxstyleemphasis{encapsulation}, which we will
discuss more in Lecture 19.

\end{itemize}

\item {} 
At the end of lecture, the resulting code will be posted and
tests will be generated to complete the class definition.

\end{itemize}


\section{Summary}
\label{\detokenize{lecture_notes/lec18_classes1:summary}}\begin{itemize}
\item {} 
Define new types in Python by creating classes

\item {} 
Classes consist of \sphinxstyleemphasis{attributes} and \sphinxstyleemphasis{methods}

\item {} 
Attributes should be defined and initialized through the special
method call \sphinxcode{\sphinxupquote{\_\_init\_\_}}. This is a \sphinxstyleemphasis{constructor}

\item {} 
Other special methods allow us to create operators for our classes.

\item {} 
We looked at a \sphinxstyleemphasis{Point2d} and \sphinxstyleemphasis{Time} example.

\end{itemize}


\chapter{Lecture 18 — Exercises}
\label{\detokenize{lecture_notes/lec18_classes1_exercises/exercises:lecture-18-exercises}}\label{\detokenize{lecture_notes/lec18_classes1_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for
automatic scoring.  A separate file must submitted for each problem.
Solutions must be submitted by 4 pm on Tuesday, April 4.
\begin{enumerate}
\item {} 
Starting from the \sphinxcode{\sphinxupquote{Point2d.py}} file you download from the
Resources page of the Piazza site, please do the following:
\begin{enumerate}
\item {} 
Write a new \sphinxcode{\sphinxupquote{Point2d}} method called \sphinxcode{\sphinxupquote{scale}} that takes as an
input argument a \sphinxcode{\sphinxupquote{Point2d}} object (\sphinxcode{\sphinxupquote{self}}) and a numerical
value (int or float) and multiples both the \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}}
attributes by this value.

\item {} 
Write a new \sphinxcode{\sphinxupquote{Point2d}} method called \sphinxcode{\sphinxupquote{dominates}} that two
takes two \sphinxcode{\sphinxupquote{Point2d}} objects and returns \sphinxcode{\sphinxupquote{True}} if and only
if the x coordinate of the first object is greater than that of
the second object and the y coordinate of the first object is
greater than that of the second object.

\item {} 
The code to test these functions is commented out in the main
code area.  Please remove this commenting, test on Piazza, and
submit your resulting \sphinxcode{\sphinxupquote{Point2d.py}} file.  Call it \sphinxcode{\sphinxupquote{Point2d\_q1.py}}

\end{enumerate}

\item {} 
Copy your resulting file from the first question to a new file,
perhaps called \sphinxcode{\sphinxupquote{Point2d\_q2.py}}.
\begin{enumerate}
\item {} 
Write and test the implementation of the method \sphinxcode{\sphinxupquote{\_\_str\_\_}}
which returns a string created from the values of a \sphinxcode{\sphinxupquote{Point2d}}
object.  For our purposes this is mostly used to create a string
that can be printed.   Make sure you have this working before
you proceed to the other parts of this exercise because they
depend on it.

\item {} 
Write the implementation of the subtraction method \sphinxcode{\sphinxupquote{\_\_sub\_\_}}
for the \sphinxcode{\sphinxupquote{Point2d}} object.  Uncomment the code in the main area
and test this in Wing IDE.

\item {} 
Write the implementation of the method \sphinxcode{\sphinxupquote{\_\_mul\_\_}} which is
like the \sphinxcode{\sphinxupquote{scale}} function you wrote for part 1, but it creates
a new \sphinxcode{\sphinxupquote{Point2d}} object.

\item {} 
Write the implementation of the method \sphinxcode{\sphinxupquote{\_\_eq\_\_}} which
returns \sphinxcode{\sphinxupquote{True}} if and only if the two \sphinxcode{\sphinxupquote{Point2d}} objects have
exactly the same \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}} values.

\end{enumerate}

For each of these you should look at the commented out main code in
the \sphinxcode{\sphinxupquote{Point2d.py}} file you were provided to see how these
methods should be used.  Uncomment this code, test your methods,
and upload to Submitty when you are done.

\end{enumerate}


\chapter{Lecture 19 — Classes, Part 2}
\label{\detokenize{lecture_notes/lec19_classes2:lecture-19-classes-part-2}}\label{\detokenize{lecture_notes/lec19_classes2::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec19_classes2:overview}}\begin{itemize}
\item {} 
Review of classes

\item {} 
Revisiting our Yelp data:  a \sphinxcode{\sphinxupquote{Restaurant}} class.

\item {} 
Techniques that we will see:
\begin{itemize}
\item {} 
Calling class methods from within the class

\item {} 
Class objects storing other objects, such as lists

\item {} 
Lists of class objects

\end{itemize}

\end{itemize}


\section{Review of Classes}
\label{\detokenize{lecture_notes/lec19_classes2:review-of-classes}}
We will use our \sphinxcode{\sphinxupquote{Point2d}} class solution from Lecture 18 to review
the following:
\begin{itemize}
\item {} 
Attributes:
\begin{itemize}
\item {} 
These store the data associated with each class instance.

\item {} 
They are usually defined inside the class to create a common set
of attributes across all class instances.

\end{itemize}

\item {} 
Initialization: function \sphinxcode{\sphinxupquote{\_\_init\_\_}} called when the object is
created.
\begin{itemize}
\item {} 
Should assign initial values to all attributes

\end{itemize}

\item {} 
Methods
\begin{itemize}
\item {} 
Each includes the object, often referred to as \sphinxcode{\sphinxupquote{self}}, as the
first argument.

\item {} 
Some change the object, some create new objects

\end{itemize}

\item {} 
Special methods start and end with two underscores. Python interprets their
use in a variety of distinct ways:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\_\_str\_\_}} is the string conversion function

\item {} 
\sphinxcode{\sphinxupquote{\_\_add\_\_}}, \sphinxcode{\sphinxupquote{\_\_sub\_\_}}, etc. become operators

\end{itemize}

\item {} 
Each of these special methods builds on the “more primitive”
methods

\end{itemize}


\section{Larger Example — Restaurant Class}
\label{\detokenize{lecture_notes/lec19_classes2:larger-example-restaurant-class}}
Recall Lab 5 on the Yelp data:
\begin{itemize}
\item {} 
Read and parse input lines that look like:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{Greek} \PYG{n}{House}\PYG{o}{\textbar{}}\PYG{l+m+mf}{42.73}\PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{73.69}\PYG{o}{\textbar{}}\PYG{l+m+mi}{27} \PYG{l+m+mi}{3}\PYG{n}{rd} \PYG{n}{St}\PYG{o}{+}\PYG{n}{Troy}\PYG{p}{,} \PYG{n}{NY} \PYG{l+m+mi}{12180}\PYG{o}{\textbar{}}\PYGZbs{}
   \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{www}\PYG{o}{.}\PYG{n}{yelp}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{biz}\PYG{o}{/}\PYG{n}{the}\PYG{o}{\PYGZhy{}}\PYG{n}{greek}\PYG{o}{\PYGZhy{}}\PYG{n}{house}\PYG{o}{\PYGZhy{}}\PYG{n}{troy}\PYG{o}{\textbar{}}\PYG{n}{Greek}\PYG{o}{\textbar{}}\PYG{l+m+mi}{1}\PYG{o}{\textbar{}}\PYG{l+m+mi}{5}\PYG{o}{\textbar{}}\PYG{l+m+mi}{4}\PYG{o}{\textbar{}}\PYG{l+m+mi}{5}\PYG{o}{\textbar{}}\PYG{l+m+mi}{4}\PYG{o}{\textbar{}}\PYG{l+m+mi}{4}\PYG{o}{\textbar{}}\PYG{l+m+mi}{5}\PYG{o}{\textbar{}}\PYG{l+m+mi}{5}\PYG{o}{\textbar{}}\PYG{l+m+mi}{5}\PYG{o}{\textbar{}}\PYG{l+m+mi}{5}\PYG{o}{\textbar{}}\PYG{l+m+mi}{5}\PYG{o}{\textbar{}}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\item {} 
Find restaurants and print out information based on a user selection

\item {} 
Original implementation based on a list was awkward:
\begin{itemize}
\item {} 
We had to remember the role of each index of the list — 0 was the
name, 1 was the latitude, etc.

\end{itemize}

\item {} 
New implementation here is based on a class

\end{itemize}


\section{Start to a Solution, the Main Code}
\label{\detokenize{lecture_notes/lec19_classes2:start-to-a-solution-the-main-code}}
Let’s look at \sphinxcode{\sphinxupquote{lec19\_restaurants\_exercise.py}}, downloadable as part
of the Lecture\_19 zip file:
\begin{itemize}
\item {} 
This is the code that \sphinxstyleemphasis{uses} the \sphinxcode{\sphinxupquote{Restaurant}} class.
\begin{itemize}
\item {} 
We start by considering how the class will be used rather than
how we write it.

\end{itemize}

\item {} 
Main function to initialize a restaurant is called
\sphinxcode{\sphinxupquote{convert\_input\_to\_restaurant}}
\begin{itemize}
\item {} 
Parses a restaurant line

\item {} 
Creates and returns a \sphinxcode{\sphinxupquote{Restaurant}} object

\end{itemize}

\item {} 
Function \sphinxcode{\sphinxupquote{build\_restaurant\_list}}
\begin{itemize}
\item {} 
Opens the input file

\item {} 
Reads each line

\item {} 
Calls \sphinxcode{\sphinxupquote{convert\_input\_to\_restaurant}}, and appends the resulting
restaurant to the back of a list

\end{itemize}

\item {} 
Main code:
\begin{itemize}
\item {} 
Builds the restaurant list

\item {} 
Prints the first three restaurants in the list

\item {} 
Includes commented-out code that
\begin{itemize}
\item {} 
Gets the name of a city

\item {} 
Finds the restaurant with the highest average rating

\end{itemize}

We will complete this code soon.

\end{itemize}

\end{itemize}


\section{Functionality Needed in the Restaurant Class}
\label{\detokenize{lecture_notes/lec19_classes2:functionality-needed-in-the-restaurant-class}}\begin{itemize}
\item {} 
Some functionality is determined by reading the code we have
already written
\begin{itemize}
\item {} 
Includes both methods and attributes

\end{itemize}

\item {} 
Add other functionality by considering the methods that must be in
the \sphinxcode{\sphinxupquote{Restaurant}} class, including the parameters that must be
passed to each method.

\item {} 
Add attributes last…

\end{itemize}


\section{Turning to the Actual Restaurant Class}
\label{\detokenize{lecture_notes/lec19_classes2:turning-to-the-actual-restaurant-class}}
Look at \sphinxcode{\sphinxupquote{Restaurant.py}} which was distributed with the Lecture\_19
files.
\begin{itemize}
\item {} 
The \sphinxcode{\sphinxupquote{\_\_init\_\_}} function specifies the attributes.
\begin{itemize}
\item {} 
Other attributes could be added, such as the average rating, but
instead these are computed as needed by methods.

\item {} 
Importantly, each class object stores a list of ratings,
illustrating the fact that classes can store data structures such
as lists, sets, and dictionaries.

\end{itemize}

\item {} 
The \sphinxcode{\sphinxupquote{Restaurant}} class has more complicated attributes than our
previous objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Point2d}} object,

\item {} 
A list for the address entries

\item {} 
A list of scores

\end{itemize}

\item {} 
There is nothing special about working with these attributes other
than they “feel” more complicated.
\begin{itemize}
\item {} 
Just apply what you know in using them

\item {} 
Our lecture exercises will help

\end{itemize}

\end{itemize}


\section{In-Class Example}
\label{\detokenize{lecture_notes/lec19_classes2:in-class-example}}
Together we will add the following two methods \sphinxcode{\sphinxupquote{Restaurant}} to get
our demonstration example to work:
\begin{enumerate}
\item {} 
The \sphinxcode{\sphinxupquote{is\_in\_city}} method

\item {} 
The \sphinxcode{\sphinxupquote{average\_review}} method

\end{enumerate}


\section{Discussion}
\label{\detokenize{lecture_notes/lec19_classes2:discussion}}\begin{itemize}
\item {} 
What is not in the \sphinxcode{\sphinxupquote{Restaurant}} class?
\begin{itemize}
\item {} 
No input or line parsing. Usually, we don’t want the class tied to
the particular form of the input.

\item {} 
As an alternative, we could add a method for each of several
different forms of input.

\end{itemize}

\item {} 
Often it is hard to make the decision about what should be inside and
what should be outside the class.
\begin{itemize}
\item {} 
One example the method we wrote to test if
restaurant is in a particular city.  As an alternative we could
have written a
different method that returns that name of the city and make the
comparison outside the class.

\end{itemize}

\item {} 
We could add an \sphinxcode{\sphinxupquote{Address}} class:
\begin{itemize}
\item {} 
Reuse for objects other than restaurants

\item {} 
Not needed in this (relatively) short example.

\item {} 
More flexible than our use of a list of strings from an address
line.

\end{itemize}

\end{itemize}


\section{Summary}
\label{\detokenize{lecture_notes/lec19_classes2:summary}}\begin{itemize}
\item {} 
Review of the main components of a Python class:
\begin{itemize}
\item {} 
Attributes

\item {} 
Methods

\item {} 
Special methods with names starting and ending with \sphinxcode{\sphinxupquote{\_\_}}
\begin{itemize}
\item {} 
Initializer method is most important

\end{itemize}

\end{itemize}

\item {} 
Important uses of Python classes that we have seen today:
\begin{itemize}
\item {} 
Classes containing other objects as attributes

\item {} 
Lists of class objects.

\end{itemize}

\item {} 
Design of Python classes
\begin{itemize}
\item {} 
Start by outlining how they are to be used

\item {} 
Leads to design of methods

\item {} 
Specification of attributes and implementation of methods comes
last

\end{itemize}

\end{itemize}


\chapter{Lecture 19 — Exercises}
\label{\detokenize{lecture_notes/lec19_classes2_exercises/exercises:lecture-19-exercises}}\label{\detokenize{lecture_notes/lec19_classes2_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for
automatic scoring.  A separate file must submitted for each problem.
Solutions must be submitted by 4 pm on Friday, April 7.
\begin{enumerate}
\item {} 
The \sphinxcode{\sphinxupquote{Restaurant.py}} file you were provided includes a main code
area with code to test functions that have not yet been written
(see the methods with \sphinxcode{\sphinxupquote{pass}} as their only statements). These
are the \sphinxcode{\sphinxupquote{min\_review}}, the \sphinxcode{\sphinxupquote{max\_review}}, the \sphinxcode{\sphinxupquote{latitude}} and
the \sphinxcode{\sphinxupquote{longitude}}.  Please implement these functions, test them, and
submit the resulting \sphinxcode{\sphinxupquote{Restaurant.py}}.

\item {} 
Copy the code in \sphinxcode{\sphinxupquote{lec19\_restaurant\_exercise.py}} into a file
called \sphinxcode{\sphinxupquote{lec19\_american\_in\_troy.py}}.  Rewrite the main code in
this new file to list the names of all Restaurants in
\sphinxstyleemphasis{Troy} that have \sphinxstyleemphasis{American} in their category and that have an average
rating of \sphinxstylestrong{more than} 3.0.  The \sphinxstylestrong{only output} should be the alphabetical
list of restaurant names, one per line of
output.  The trick is that you are \sphinxstyleemphasis{not allowed to change} the
\sphinxcode{\sphinxupquote{Restaurant}} class at all.  This will require that you
access and use both one or two methods from \sphinxcode{\sphinxupquote{Restaurant}} and some
of its attributes directly.  Upload your
\sphinxcode{\sphinxupquote{lec19\_american\_in\_troy.py}} to Submitty when you are done.
Submitty will use our \sphinxcode{\sphinxupquote{Restaurant.py}} file to test.

\end{enumerate}


\chapter{Lecture 20 — Searching}
\label{\detokenize{lecture_notes/lec20_searching:lecture-20-searching}}\label{\detokenize{lecture_notes/lec20_searching::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec20_searching:overview}}\begin{itemize}
\item {} 
Notion of an algorithm

\item {} 
Problems:
\begin{itemize}
\item {} 
Finding the two smallest values in a list

\item {} 
Finding the index of a particular value in a list

\item {} 
Finding the index of a particular value in a \sphinxstylestrong{sorted} list

\item {} 
Sorting a list (Lecture 21)

\end{itemize}

\item {} 
Analyzing our solutions:
\begin{itemize}
\item {} 
Mathematically

\item {} 
Experimental timing

\end{itemize}

\end{itemize}

Material for Lectures 20 and 21 is in Chapters 12 and 13 of the text.


\section{Algorithm}
\label{\detokenize{lecture_notes/lec20_searching:algorithm}}\begin{itemize}
\item {} 
Precise description of the steps necessary to solve a computing
problem

\item {} 
Description is intended for people to read and understand

\item {} 
Gradual refinement:
\begin{itemize}
\item {} 
Starts with English sentences

\item {} 
Gradually, the sentences are made more detailed and more like
programming statements

\item {} 
Allows us to lay out the basic steps of the program before getting
to the details.

\end{itemize}

\item {} 
A program is an \sphinxstyleemphasis{implementation} of one or more algorithms.

\end{itemize}


\section{Multiple Algorithms}
\label{\detokenize{lecture_notes/lec20_searching:multiple-algorithms}}\begin{itemize}
\item {} 
Often there are many different algorithms that can solve a problem.

\item {} 
They differ in:
\begin{itemize}
\item {} 
Ease of understanding

\item {} 
Ease of implementation

\item {} 
Efficiency

\end{itemize}

\item {} 
All three considerations are important and their relative weight
depends on the context.

\end{itemize}


\section{Problem 1: Finding the Two Smallest Values in a List}
\label{\detokenize{lecture_notes/lec20_searching:problem-1-finding-the-two-smallest-values-in-a-list}}\begin{itemize}
\item {} 
Given a list of integers, floats, or any other values that can be
compared with a less than operation, find the two smallest values in
the list AND their indices in the list

\item {} 
We need to be careful with this problem formulation: are duplicates
allowed? does it matter?

\end{itemize}


\section{Brainstorming Session}
\label{\detokenize{lecture_notes/lec20_searching:brainstorming-session}}\begin{enumerate}
\item {} 
Outline two or more approaches to finding the indices of the two
smallest values in a list.

\item {} 
Think through the advantages and disadvantages of each approach.

\item {} 
Write a more detailed description of the solutions.

\item {} 
How might your approaches change if we just have to find the values
and not the indices?

\end{enumerate}


\section{Evaluating Our Solutions Analytically}
\label{\detokenize{lecture_notes/lec20_searching:evaluating-our-solutions-analytically}}
We’ve already covered this briefly in Lecture 15.
\begin{itemize}
\item {} 
Count the number of steps as a function of the size of the list.
\begin{itemize}
\item {} 
Usually we use \(N\) as a variable to indicate this size.

\end{itemize}

\item {} 
Informally, if the number of operations is (roughly) proportional to
\(N\) we write \(O(N)\) (read as “order of N”)

\item {} 
If the number of operations is proportional to \(N log N\) we
write \(O(N log N)\).
\begin{itemize}
\item {} 
Importantly, the best sorting algorithms, including the one
implemented in Python for lists, are \(O(N log N)\).

\end{itemize}

\item {} 
We will informally apply this analysis to our solution approaches.

\end{itemize}


\section{Evaluating Our Solutions Experimentally}
\label{\detokenize{lecture_notes/lec20_searching:evaluating-our-solutions-experimentally}}\begin{itemize}
\item {} 
Needs:
\begin{itemize}
\item {} 
generate example data, and

\item {} 
time our algorithm implementations.

\end{itemize}

\item {} 
Experimental data can be generated using the \sphinxcode{\sphinxupquote{random}} module. We
will make use of
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{randrange}}

\item {} 
\sphinxcode{\sphinxupquote{shuffle}}

\end{itemize}

\item {} 
Timing uses the \sphinxcode{\sphinxupquote{time}} module and its \sphinxcode{\sphinxupquote{time}} function, which
returns the number of seconds (as a float) since an arbitrary start
time called an “epoch”.
\begin{itemize}
\item {} 
We will compute the difference between a start time and an end
time as our timing measurement.

\end{itemize}

\end{itemize}


\section{Completing the Solutions}
\label{\detokenize{lecture_notes/lec20_searching:completing-the-solutions}}\begin{itemize}
\item {} 
We will implement two of the algorithms we came up with to find the
indices of the two smallest values in the list:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{k+kn}{import} \PYG{n+nn}{time}

\PYG{k}{def} \PYG{n+nf}{index\PYGZus{}two\PYGZus{}v1}\PYG{p}{(} \PYG{n}{values} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}  \PYG{c+c1}{\PYGZsh{} not implemented yet}




\PYG{k}{def} \PYG{n+nf}{index\PYGZus{}two\PYGZus{}v2}\PYG{p}{(} \PYG{n}{values} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass} \PYG{c+c1}{\PYGZsh{} not implemented yet}






\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter the number of values to test ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{values} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{random}\PYG{o}{.}\PYG{n}{shuffle}\PYG{p}{(} \PYG{n}{values} \PYG{p}{)}

    \PYG{n}{s1} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{(}\PYG{n}{i0}\PYG{p}{,}\PYG{n}{i1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{index\PYGZus{}two\PYGZus{}v1}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}
    \PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{s1}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ver 1:  indices (}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{,}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{); time }\PYG{l+s+si}{\PYGZob{}:.3f\PYGZcb{}}\PYG{l+s+s2}{ seconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{i0}\PYG{p}{,}\PYG{n}{i1}\PYG{p}{,}\PYG{n}{t1}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{s2} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{(}\PYG{n}{j0}\PYG{p}{,}\PYG{n}{j1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{index\PYGZus{}two\PYGZus{}v2}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}
    \PYG{n}{t2} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{s2}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ver 2:  indices (}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{,}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{); time }\PYG{l+s+si}{\PYGZob{}:.3f\PYGZcb{}}\PYG{l+s+s2}{ seconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{j0}\PYG{p}{,}\PYG{n}{j1}\PYG{p}{,}\PYG{n}{t2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}

We will experiment with these implementations.


\section{Searching for a Value}
\label{\detokenize{lecture_notes/lec20_searching:searching-for-a-value}}\begin{itemize}
\item {} 
Problem: given a list of values, \sphinxcode{\sphinxupquote{L}}, and given a single value,
\sphinxcode{\sphinxupquote{x}}, find the (first) index of \sphinxcode{\sphinxupquote{x}} in \sphinxcode{\sphinxupquote{L}} or determine that
\sphinxcode{\sphinxupquote{x}} is not in \sphinxcode{\sphinxupquote{L}}.

\item {} 
Basic algorithm is straightforward, and requires \(O(N)\) steps

\item {} 
We can solve this in Python using a combination of \sphinxcode{\sphinxupquote{in}} and
\sphinxcode{\sphinxupquote{index}}, or by writing our own loop.
\begin{itemize}
\item {} 
The text book discusses a number of variations on the algorithm.

\end{itemize}

\item {} 
We will implement our own variation as an exercise.

\end{itemize}


\section{Binary Search}
\label{\detokenize{lecture_notes/lec20_searching:binary-search}}\begin{itemize}
\item {} 
If the list is \sphinxstylestrong{ordered}, do we have to search it by looking at
location 0, then 1, then 2, then 3, …?

\item {} 
What if we looked at the middle location first?
\begin{itemize}
\item {} 
If the value of \sphinxcode{\sphinxupquote{x}} is greater than that value, we know that the
first location for \sphinxcode{\sphinxupquote{x}} is in the \sphinxstylestrong{upper half of the list}.

\item {} 
Otherwise, the first location for \sphinxcode{\sphinxupquote{x}} is in the \sphinxstylestrong{lower half}
of the list

\end{itemize}

\item {} 
In other words, by making one comparison, we have eliminated half the
list in our search!

\item {} 
We can repeat this process of “halving” the list until we reach just
one location.

\end{itemize}


\section{Algorithm and Implementation}
\label{\detokenize{lecture_notes/lec20_searching:algorithm-and-implementation}}\begin{itemize}
\item {} 
We need to keep track of two indices:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{low}}: all values in the list at locations 0..\sphinxcode{\sphinxupquote{low}}-1 are
less than \sphinxcode{\sphinxupquote{x}}

\item {} 
\sphinxcode{\sphinxupquote{high}}: all values in the list at locations \sphinxcode{\sphinxupquote{high}} ..\sphinxcode{\sphinxupquote{N}}
are greater than or equal to \sphinxcode{\sphinxupquote{x}}. Write \sphinxcode{\sphinxupquote{N}} as the length of
the list.

\end{itemize}

\item {} 
Initialize \sphinxcode{\sphinxupquote{low = 0}} and \sphinxcode{\sphinxupquote{high = N}}.

\item {} 
In each iteration of a while loop
\begin{itemize}
\item {} 
Set \sphinxcode{\sphinxupquote{mid}} to be the average of \sphinxcode{\sphinxupquote{low}} and \sphinxcode{\sphinxupquote{high}}.

\item {} 
Update the value of \sphinxcode{\sphinxupquote{low}} or \sphinxcode{\sphinxupquote{high}} based on comparing \sphinxcode{\sphinxupquote{x}}
to \sphinxcode{\sphinxupquote{L{[}mid{]}}}.

\end{itemize}

\item {} 
Here is the actual code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{binary\PYGZus{}search}\PYG{p}{(} \PYG{n}{x}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{low} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{high} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}
    \PYG{k}{while} \PYG{n}{low} \PYG{o}{!=} \PYG{n}{high}\PYG{p}{:}
        \PYG{n}{mid} \PYG{o}{=} \PYG{p}{(}\PYG{n}{low}\PYG{o}{+}\PYG{n}{high}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}
        \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{n}{L}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{low} \PYG{o}{=} \PYG{n}{mid}\PYG{o}{+}\PYG{l+m+mi}{1}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{high} \PYG{o}{=} \PYG{n}{mid}
    \PYG{k}{return} \PYG{n}{low}
\end{sphinxVerbatim}

\end{itemize}


\section{Practice}
\label{\detokenize{lecture_notes/lec20_searching:practice}}\begin{enumerate}
\item {} 
Using

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{1.3}\PYG{p}{,} \PYG{l+m+mf}{7.9}\PYG{p}{,} \PYG{l+m+mf}{11.2}\PYG{p}{,} \PYG{l+m+mf}{15.3}\PYG{p}{,} \PYG{l+m+mf}{18.5}\PYG{p}{,} \PYG{l+m+mf}{18.9}\PYG{p}{,} \PYG{l+m+mf}{19.7} \PYG{p}{]}
\end{sphinxVerbatim}

what are the values of \sphinxcode{\sphinxupquote{low}}, \sphinxcode{\sphinxupquote{high}} and \sphinxcode{\sphinxupquote{mid}} each time
through the while loop for the calls

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{binary\PYGZus{}search}\PYG{p}{(} \PYG{l+m+mf}{11.2}\PYG{p}{,} \PYG{n}{L} \PYG{p}{)}



\PYG{n}{binary\PYGZus{}search}\PYG{p}{(} \PYG{l+m+mf}{19.1}\PYG{p}{,} \PYG{n}{L} \PYG{p}{)}



\PYG{n}{binary\PYGZus{}search}\PYG{p}{(} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}




\PYG{n}{binary\PYGZus{}search}\PYG{p}{(} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
How many times will the loop execute for \(N = 1,000\) or
\(N = 1,000,000\)? (You will not be able to come up with an exact number,
but you should be able to come close.) How does this compare to the
linear search?

\item {} 
Would the code still work if we changed the \sphinxcode{\sphinxupquote{\textgreater{}}} to the \sphinxcode{\sphinxupquote{\textgreater{}=}}? Why?

\item {} 
Modify the code to return a tuple that includes both the index where
\sphinxcode{\sphinxupquote{x}} is or should be inserted \sphinxcode{\sphinxupquote{and}} a boolean that indicates
whether or not \sphinxcode{\sphinxupquote{x}} is in the list.

\end{enumerate}

We will also perform experimental timing runs if we have time at the end
of class.


\section{Summary}
\label{\detokenize{lecture_notes/lec20_searching:summary}}\begin{itemize}
\item {} 
Algorithm vs. implementation

\item {} 
Criteria for choosing an algorithm: speed, clarity, ease of
implementation

\item {} 
Timing/speed evaluations can be either analytical or experimental.

\item {} 
Searching for indices of two smallest values

\item {} 
Linear search

\item {} 
Binary search of a list that is ordered.

\end{itemize}


\chapter{Lecture 20 — Exercises}
\label{\detokenize{lecture_notes/lec20_searching_exercises/exercises:lecture-20-exercises}}\label{\detokenize{lecture_notes/lec20_searching_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for
automatic scoring.  A separate file must submitted for each problem.
Solutions must be submitted by 4 pm on Tuesday, April 11.

For both of these exercises download the file \sphinxcode{\sphinxupquote{lec20\_ex.zip}} from
the course Piazza Resource page.  It includes a data file and
\sphinxcode{\sphinxupquote{lec20\_ex\_start.py}}.  You start from the latter for both exercises.
You will notice that the main code in this file requests the name of a
data file from the user, opens and reads the file to form a list of
values, and then in a loop requests several different values to search
for, outputting the result of the function call for each.
\begin{enumerate}
\item {} 
Write a Python function called \sphinxcode{\sphinxupquote{linear\_search}} that is given two
arguments:  a value \sphinxcode{\sphinxupquote{x}} and a list \sphinxcode{\sphinxupquote{L}}.  The function must
return the list index of the first location of \sphinxcode{\sphinxupquote{x}} in \sphinxcode{\sphinxupquote{L}}.  If
\sphinxcode{\sphinxupquote{x}} is not in \sphinxcode{\sphinxupquote{L}} the function must return -1.  You may use any
Python \sphinxcode{\sphinxupquote{list}} functions you wish.

\item {} 
What if the list is already sorted? Write a modifed version of
\sphinxcode{\sphinxupquote{linear\_search}} that returns the index of the first instance of
\sphinxcode{\sphinxupquote{x}} or the index where \sphinxcode{\sphinxupquote{x}} should be inserted if it is not in
\sphinxcode{\sphinxupquote{L}} For example, in the list

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{1.3}\PYG{p}{,} \PYG{l+m+mf}{7.9}\PYG{p}{,} \PYG{l+m+mf}{11.2}\PYG{p}{,} \PYG{l+m+mf}{15.3}\PYG{p}{,} \PYG{l+m+mf}{18.5}\PYG{p}{,} \PYG{l+m+mf}{18.9}\PYG{p}{,} \PYG{l+m+mf}{19.7} \PYG{p}{]}
\end{sphinxVerbatim}

the call

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{linear\PYGZus{}search}\PYG{p}{(}\PYG{l+m+mf}{11.9}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}
\end{sphinxVerbatim}

should return 3, while the call

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{linear\PYGZus{}search}\PYG{p}{(} \PYG{l+m+mf}{20.5}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}
\end{sphinxVerbatim}

should return 7.  You must not use binary search (even though that
would be faster — this is an exercise) and you must use either a
\sphinxcode{\sphinxupquote{for}} or a \sphinxcode{\sphinxupquote{while}} loop.

\end{enumerate}


\chapter{Lecture 21 — Sorting}
\label{\detokenize{lecture_notes/lec21_sorting:lecture-21-sorting}}\label{\detokenize{lecture_notes/lec21_sorting::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec21_sorting:overview}}\begin{itemize}
\item {} 
Sorting is a fundamental operation

\item {} 
Provides good practice in implementing and testing small functions

\item {} 
Leads to a better understanding of algorithm efficiency

\item {} 
Allows us to consider the fundamental notion of a merge of two sorted
sequences.

\item {} 
During testing, we will see an example of the important notion of
passing functions as arguments.

\end{itemize}


\section{Algorithms to Study}
\label{\detokenize{lecture_notes/lec21_sorting:algorithms-to-study}}\begin{itemize}
\item {} 
Insertion sort

\item {} 
Merge sort
\begin{itemize}
\item {} 
This is our primary focus.

\end{itemize}

\item {} 
Python’s built in sort

\end{itemize}


\section{Insertion Sort}
\label{\detokenize{lecture_notes/lec21_sorting:insertion-sort}}\begin{itemize}
\item {} 
Idea:
\begin{itemize}
\item {} 
If we already have a sorted list and we want to insert a new
value, we can shift values one location higher until we find the
proper location for the new value

\item {} 
Insert the new value

\item {} 
Start with a just a list of length 1 and repeat until all values
have been inserted

\end{itemize}

\item {} 
Algorithm

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{each} \PYG{n}{index} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n+nb}{list}\PYG{p}{,} \PYG{n}{starting} \PYG{n}{at} \PYG{l+m+mi}{1} \PYG{n}{do}
    \PYG{n}{Save} \PYG{n}{the} \PYG{n}{value} \PYG{n}{stored} \PYG{n}{at} \PYG{n}{location} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{variable} \PYG{n}{x}
    \PYG{n}{Initialize} \PYG{n}{j} \PYG{n}{at} \PYG{n}{location} \PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
    \PYG{k}{while} \PYG{n}{j} \PYG{o+ow}{is} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{negative} \PYG{o+ow}{and} \PYG{n}{the} \PYG{n}{location} \PYG{n}{to} \PYG{n}{insert} \PYG{n}{x} \PYG{n}{has} \PYG{o+ow}{not} \PYG{n}{been} \PYG{n}{found} \PYG{n}{do}
        \PYG{n}{Shift} \PYG{n}{the} \PYG{n}{value} \PYG{n}{at} \PYG{n}{location} \PYG{n}{j} \PYG{n}{up} \PYG{n}{to} \PYG{n}{location} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}
        \PYG{n}{Decrement} \PYG{n}{j}
    \PYG{n}{Insert} \PYG{n}{the} \PYG{n}{value} \PYG{n}{stored} \PYG{o+ow}{in} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{location} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\item {} 
Code (in-class exercise):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ins\PYGZus{}sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{:}
\end{sphinxVerbatim}

\end{itemize}


\section{Steps to Testing}
\label{\detokenize{lecture_notes/lec21_sorting:steps-to-testing}}\begin{enumerate}
\item {} 
Re-read and mentally simulate

\item {} 
Insert print statements and/or view with debugger to see what it is
actually doing.

\item {} 
Run on “test cases” that capture challenging conditions:
\begin{itemize}
\item {} 
Empty list

\item {} 
Singleton list

\item {} 
List of repeated values

\item {} 
List where the largest value is at the beginning or the smallest
value is at the end.

\end{itemize}

\end{enumerate}


\section{Rough Analysis of Time Required}
\label{\detokenize{lecture_notes/lec21_sorting:rough-analysis-of-time-required}}\begin{itemize}
\item {} 
For any particular value of \sphinxcode{\sphinxupquote{i}} in the outer \sphinxcode{\sphinxupquote{for}} loop, there
can be up to \sphinxcode{\sphinxupquote{i-1}} comparisons/shifts.
\begin{itemize}
\item {} 
When \sphinxcode{\sphinxupquote{i==1}} this is not much, but

\item {} 
When \sphinxcode{\sphinxupquote{i==N-1}}, this is a lot.

\end{itemize}

\item {} 
Adding across the different values of \sphinxcode{\sphinxupquote{i}}, this results in at most
(roughly) \(N^2/2\) comparisons.

\item {} 
We write this as \(O(N^2)\) because (informally) the number of
comparisons done is proportional to \(N^2\).

\end{itemize}


\section{Experimental Analysis}
\label{\detokenize{lecture_notes/lec21_sorting:experimental-analysis}}\begin{itemize}
\item {} 
The code \sphinxcode{\sphinxupquote{lec21\_test\_sort.py}} posted on the Piazza site, and attached to
the end of these notes, will be used to do timing experiments on all
the sorts we write.

\item {} 
Makes use of the \sphinxcode{\sphinxupquote{random}} module

\item {} 
Includes two main functions:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{run\_and\_time}}

\item {} 
\sphinxcode{\sphinxupquote{generate\_local\_perm}}

\end{itemize}

We will discuss each of these in turn.

\item {} 
The sorting functions themselves are functions in the module \sphinxcode{\sphinxupquote{sort}}

\item {} 
Notice that the sorting function is \sphinxstyleemphasis{passed as an argument} to
\sphinxcode{\sphinxupquote{run\_and\_time}}:
\begin{itemize}
\item {} 
First time that we have passed a function as an argument to
another function!

\end{itemize}

\item {} 
We will start with experiments to analyze selection sort (see
textbook) and insertion sort.

\end{itemize}


\section{Breaking the N-Squared Barrier}
\label{\detokenize{lecture_notes/lec21_sorting:breaking-the-n-squared-barrier}}\begin{itemize}
\item {} 
The fundamental problem with both selection sort (discussed in the
textbook, but not in these notes) and insertion sort:
\begin{itemize}
\item {} 
We need to do up to \(N\) comparisons by scanning through the
list to find the proper location of the next value in the sorted
list.

\item {} 
For insertion sort, we could use binary search to find the
insertion location, but we would still have up to \(N\) shifts
of values.

\end{itemize}

\item {} 
Do better than selection sort and insertion sort by using algorithms
that don’t scan the entire list to assign one value.

\item {} 
Examples
\begin{itemize}
\item {} 
Quick sort

\item {} 
Heap sort

\item {} 
Merge sort

\end{itemize}

\item {} 
We’ll study merge sort, in part because it is the easiest of these to
understand and in part because of the importance of the idea of a
merge.

\end{itemize}


\section{Merging Two Sorted Lists}
\label{\detokenize{lecture_notes/lec21_sorting:merging-two-sorted-lists}}\begin{itemize}
\item {} 
Given two lists that are each already sorted, our problem is to
generate a new sorted list containing all of the items from both
lists.

\item {} 
For example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L1} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{25} \PYG{p}{]}
\PYG{n}{L2} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{16} \PYG{p}{]}
\end{sphinxVerbatim}

must be merged into a new list containing

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{25} \PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
Idea:
\begin{itemize}
\item {} 
Since both lists are sorted, the first item in the new list must
be the first item in one of the lists!

\item {} 
If we “remove” the smallest item (3 in \sphinxcode{\sphinxupquote{L1}} in this case), the
next item will again be the first non-copied item in one of the
two lists!

\item {} 
We repeat this process until one of the lists has no more items to
copy.

\item {} 
Then, copy the remainder of the other list to the back of our new
list.

\end{itemize}

\item {} 
We don’t actually remove the items from \sphinxcode{\sphinxupquote{L1}} or \sphinxcode{\sphinxupquote{L2}}. Instead we
keep an index to the next location of \sphinxcode{\sphinxupquote{L1}} and \sphinxcode{\sphinxupquote{L2}} that has not
yet been copied.

\item {} 
We’ll write the code in class, starting from here

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{merge}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{,} \PYG{n}{L2}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{i1} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{i2} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}












    \PYG{k}{return} \PYG{n}{L}
\end{sphinxVerbatim}

\item {} 
Studying the solution:
\begin{enumerate}
\item {} 
Write the values of the index variables, \sphinxcode{\sphinxupquote{i1}} and \sphinxcode{\sphinxupquote{i2}}, each
time through the loop for lists \sphinxcode{\sphinxupquote{L1}} and \sphinxcode{\sphinxupquote{L2}} above.

\item {} 
What are the values of \sphinxcode{\sphinxupquote{i1}} and \sphinxcode{\sphinxupquote{i2}} when the loop terminates?

\end{enumerate}

\end{itemize}


\section{Merge Sort}
\label{\detokenize{lecture_notes/lec21_sorting:merge-sort}}\begin{itemize}
\item {} 
Key observation: all lists of length 1 are sorted

\item {} 
Therefore, for a list of length \(N\) that is to be sorted:
\begin{itemize}
\item {} 
Create \(N\) lists of length 1 from the values in the list

\item {} 
Start to merge these “singleton” lists in pairs to create longer,
sorted lists.

\item {} 
Repeat on pairs of longer lists in succession

\end{itemize}

\item {} 
Requires
\begin{itemize}
\item {} 
Keeping a list of sorted sublists, initialized with each singleton
list

\item {} 
Rather than deleting the sorted sublists, just keep track of which
we need to work on.

\end{itemize}

\item {} 
Code (in class):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{merge\PYGZus{}sort}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{return}
\end{sphinxVerbatim}

\end{itemize}


\section{Analysis of Merge Sort}
\label{\detokenize{lecture_notes/lec21_sorting:analysis-of-merge-sort}}\begin{itemize}
\item {} 
Check for correctness

\item {} 
We’ll give an informal analysis explaining why there are only
\(O(N \log N)\) comparisons.

\item {} 
Experimental timings

\item {} 
Can you think of ways to improve our implementation of the merge sort
idea?

\end{itemize}


\section{Final Comparison Across All Sorts}
\label{\detokenize{lecture_notes/lec21_sorting:final-comparison-across-all-sorts}}\begin{itemize}
\item {} 
Selection sort and insertion sort are dramatically slower than merge
sort, which in turn is dramatically slower than Python’s built-in
sort, a highly optimized, C language implementation of merge sort.

\item {} 
Shows
\begin{itemize}
\item {} 
the difference between \(O(N^2)\) sorting and
\(O(N log N)\) sorting, and

\item {} 
the difference between a straight-forward Python implementation
and a careful, optimized implementation of the same algorithm.

\end{itemize}

Both of these are important!

\item {} 
Final question: what happens when values are “almost” sorted?
\begin{itemize}
\item {} 
Experimentally, we can explore this using the
\sphinxcode{\sphinxupquote{generate\_local\_perm}} function in \sphinxcode{\sphinxupquote{test\_sort.py}}.

\item {} 
Insertion sort becomes much faster, far outstripping selection
sort. Why?

\end{itemize}

\end{itemize}


\section{Practice Questions}
\label{\detokenize{lecture_notes/lec21_sorting:practice-questions}}\begin{enumerate}
\item {} 
For our insertion sort code, show the contents of the following list
after each iteration of the outer \sphinxcode{\sphinxupquote{for}} loop

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{v} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{18}\PYG{p}{,} \PYG{l+m+mi}{9} \PYG{p}{]}
\end{sphinxVerbatim}

While you can and should use the implementation to test your answers,
you should start by manually generating the answers on your own.

\item {} 
Show the contents of the \sphinxcode{\sphinxupquote{lists}} list at the end of the
\sphinxcode{\sphinxupquote{merge\_sort}} implementation developed in class when it is called
with

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{v} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{29}\PYG{p}{,} \PYG{l+m+mi}{66}\PYG{p}{,} \PYG{l+m+mi}{31}\PYG{p}{,} \PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{33} \PYG{p}{]}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
Consider the following function

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{extract}\PYG{p}{(} \PYG{n}{comp}\PYG{p}{,} \PYG{n}{v} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{comp}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{x} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

Note that \sphinxcode{\sphinxupquote{comp}} is a function that has been passed to \sphinxcode{\sphinxupquote{extract}}.
\begin{enumerate}
\item {} 
Write a function called \sphinxcode{\sphinxupquote{compare\_lower(a,b)}} such that if \sphinxcode{\sphinxupquote{L}}
is a list then the call

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{extract}\PYG{p}{(}\PYG{n}{compare\PYGZus{}lower}\PYG{p}{,}\PYG{n}{L}\PYG{p}{)}
\end{sphinxVerbatim}

returns the smallest value in \sphinxcode{\sphinxupquote{L}}.

\item {} 
Write a function called \sphinxcode{\sphinxupquote{compare\_upper(a,b)}} such that if \sphinxcode{\sphinxupquote{L}}
is a list then the call

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{extract}\PYG{p}{(}\PYG{n}{compare\PYGZus{}upper}\PYG{p}{,}\PYG{n}{L}\PYG{p}{)}
\end{sphinxVerbatim}

returns the largest value in \sphinxcode{\sphinxupquote{L}}.

\end{enumerate}

\item {} 
Write a version of \sphinxcode{\sphinxupquote{merge}} that does all of the work inside the
\sphinxcode{\sphinxupquote{while}} loop and does not use the \sphinxcode{\sphinxupquote{extend}}. This is a good test
of your logic skills.

\item {} 
Based on your previous solution write a function to merge three
sorted lists. This is an even greater challenge to your logic skills.

\end{enumerate}

Note that when it comes to the Final, you will not be required to have
memorized the code of the sorting functions, but you should know the
algorithms!

Sort Testing Code

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{Testing code for Computer Science 1, Lecture 21 on sorting. This}
\PYG{l+s+sd}{assumes that the sort functions are all in file lec21\PYGZus{}sorts.py, each taking}
\PYG{l+s+sd}{one list as its only argument, and that their names are sel\PYGZus{}sort}
\PYG{l+s+sd}{ins\PYGZus{}sort merge\PYGZus{}sort}

\PYG{l+s+sd}{All tests are based on random permutations of integers.}

\PYG{l+s+sd}{. In most of our tests, these permutations are completely random,}
\PYG{l+s+sd}{  meaning that a value is equally likely to end up anywhere in the}
\PYG{l+s+sd}{  list.}

\PYG{l+s+sd}{. In the final test we will explore the implications of working}
\PYG{l+s+sd}{  with lists that are \PYGZdq{}almost sorted\PYGZdq{} by only moving values a small}
\PYG{l+s+sd}{  distance from the correct location.  You can see that insertion sort}
\PYG{l+s+sd}{  is very fast in this case by removing the \PYGZsh{} char in front of}
\PYG{l+s+sd}{  generate\PYGZus{}local\PYGZus{}perm}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{k+kn}{import} \PYG{n+nn}{lec21\PYGZus{}sorts} \PYG{k}{as} \PYG{n+nn}{sorts}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{k+kn}{import} \PYG{n+nn}{random}


\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}and\PYGZus{}time}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{sort\PYGZus{}fcn}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{known\PYGZus{}v}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Run the function passed as sort\PYGZus{}fcn, timing its performance and}
\PYG{l+s+sd}{    double\PYGZhy{}checking if it correct.  The correctness check is probably}
\PYG{l+s+sd}{    not necessary.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Testing }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{name}\PYG{p}{)}
    \PYG{n}{t0} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{sort\PYGZus{}fcn}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Time: }\PYG{l+s+si}{\PYGZob{}:.4f\PYGZcb{}}\PYG{l+s+s2}{ seconds}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{t1}\PYG{o}{\PYGZhy{}}\PYG{n}{t0}\PYG{p}{)}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}Is correct?\PYGZdq{}, v==known\PYGZus{}v}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{generate\PYGZus{}local\PYGZus{}perm}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{max\PYGZus{}shift}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    This function modifies a list so values are only a small amount}
\PYG{l+s+sd}{    out of order.  Each one  Generate a local permutation by randomly moving each}
\PYG{l+s+sd}{    value up to max\PYGZus{}shift locations in the list.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{min\PYGZus{}i} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{max\PYGZus{}shift}\PYG{p}{)}
        \PYG{n}{max\PYGZus{}i} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{n}{max\PYGZus{}shift}\PYG{p}{)}
        \PYG{n}{new\PYGZus{}i} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(} \PYG{n}{min\PYGZus{}i}\PYG{p}{,} \PYG{n}{max\PYGZus{}i} \PYG{p}{)}
        \PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{n}{new\PYGZus{}i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{n}{new\PYGZus{}i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}


\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{raw\PYGZus{}input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter the number of values ==\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Running on }\PYG{l+s+si}{\PYGZob{}:d\PYGZcb{}}\PYG{l+s+s2}{ values}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{v} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{v1} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
    \PYG{n}{random}\PYG{o}{.}\PYG{n}{shuffle}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} generate\PYGZus{}local\PYGZus{}perm(v1, 10)}
    \PYG{n}{v2} \PYG{o}{=} \PYG{n}{v1}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
    \PYG{n}{v3} \PYG{o}{=} \PYG{n}{v1}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
    \PYG{n}{v4} \PYG{o}{=} \PYG{n}{v1}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}

    \PYG{n}{run\PYGZus{}and\PYGZus{}time}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{merge sort}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sorts}\PYG{o}{.}\PYG{n}{merge\PYGZus{}sort}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{,} \PYG{n}{v} \PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} passing functions as an arg to a fcn}
    \PYG{n}{run\PYGZus{}and\PYGZus{}time}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{python sort}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{list}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{,} \PYG{n}{v4}\PYG{p}{,} \PYG{n}{v} \PYG{p}{)}
    \PYG{n}{run\PYGZus{}and\PYGZus{}time}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{selection sort}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sorts}\PYG{o}{.}\PYG{n}{sel\PYGZus{}sort}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{,} \PYG{n}{v} \PYG{p}{)}
    \PYG{n}{run\PYGZus{}and\PYGZus{}time}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{insertion sort}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sorts}\PYG{o}{.}\PYG{n}{ins\PYGZus{}sort}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v} \PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Lecture 21 — Exercises}
\label{\detokenize{lecture_notes/lec21_sorting_exercises/exercises:lecture-21-exercises}}\label{\detokenize{lecture_notes/lec21_sorting_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for
automatic scoring.  A separate file must submitted for each problem.
Solutions must be submitted by 4 pm on Tuesday, December 5.  Download
the file \sphinxcode{\sphinxupquote{insert\_sort\_and\_merge.zip}} from the course Piazza site.
\begin{enumerate}
\item {} 
The file \sphinxcode{\sphinxupquote{insert\_sort.py}} contains an implementation of the
insertion sort algorithm.  It includes \sphinxcode{\sphinxupquote{print}} function calls.
What are the outputs of these statement?  Submit a text file
showing the output.

\item {} 
The file \sphinxcode{\sphinxupquote{merge.py}} contains an implementation of the
\sphinxcode{\sphinxupquote{merge}} function that is the heart of merge sort.  We only
consider \sphinxcode{\sphinxupquote{merge}} here and not the full sort.  Modify the merge
function so that if the same value appears in both lists then only
one copy of the value is in the final merged list.  You may assume
that each contains no duplicates.  Work within the context of the
merge function itself, meaning that you should not use a set and
you should not use an extra list.  You need to only change a few
lines of code.

For example, if the two lists are

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L1} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{18}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{25} \PYG{p}{]}
\PYG{n}{L2} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{18}\PYG{p}{,} \PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{25} \PYG{p}{]}
\end{sphinxVerbatim}

Then the result \sphinxcode{\sphinxupquote{merge(L1,L2)}} should be the list

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{18}\PYG{p}{,} \PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{25} \PYG{p}{]}
\end{sphinxVerbatim}

Do not change the name of the function and do not change the name
of the file.  On Submitty we will run code that imports
\sphinxcode{\sphinxupquote{merge.py}} and calls the function \sphinxcode{\sphinxupquote{merge}} passing two lists as
arguments.

\end{enumerate}


\chapter{Lecture 22 — TKInter}
\label{\detokenize{lecture_notes/lec22_tkinter:lecture-22-tkinter}}\label{\detokenize{lecture_notes/lec22_tkinter::doc}}

\section{Last Four Lectures}
\label{\detokenize{lecture_notes/lec22_tkinter:last-four-lectures}}
Selection of advanced topics:
\begin{itemize}
\item {} 
Lecture 22:  Graphical user interfaces

\item {} 
Lecture 23:  Recursion

\item {} 
Lecture 24:  Functional programming

\item {} 
Lecture 25:  Course summary; intro to C++

\end{itemize}


\section{Overview of Today’s Lecture}
\label{\detokenize{lecture_notes/lec22_tkinter:overview-of-today-s-lecture}}\begin{itemize}
\item {} 
We will learn about event driven programming

\item {} 
We will discuss graphical user interfaces (GUI)

\item {} 
We will see how to use TkInter implementation for Python
to develop GUIs

\end{itemize}


\section{Graphical User Interface}
\label{\detokenize{lecture_notes/lec22_tkinter:graphical-user-interface}}\begin{itemize}
\item {} 
All our programs so far had a terminal based input/output through
Wing. This is the simplest type of user interface: enter some text
and get some output.

\item {} 
In real life, we rarely use such programs. All Web interfaces and
mobile apps involve elements like buttons, text input fields, radio
buttons.

This type of a user interface is called a  \sphinxstylestrong{graphical user interface}
or GUI.

\item {} 
Designing a GUI is not a simple matter. It requires one to
understand effective communication of information through visual
interfaces. It is highly recommend you take a class on Visual
Communication or Human Computer Interaction to learn more about
these.

\item {} 
Many GUI packages will have some default settings that are meant to
help you design interfaces that are at least not awful! So, make sure
you do not override them until you know what you are doing.

\end{itemize}


\section{Event Driven Programming}
\label{\detokenize{lecture_notes/lec22_tkinter:event-driven-programming}}\begin{itemize}
\item {} 
A graphical user interface is designed to do something in response
to an event.

\item {} 
Example events are:
\begin{itemize}
\item {} 
Button push (most popular so far)

\item {} 
Selection from a list of options

\item {} 
Mouse movement

\end{itemize}

\item {} 
The interface usually runs within a main window (often called
root) and listens continuously for events it knows how to process.
\begin{itemize}
\item {} 
Hence, a GUI is always in an infinite loop.

\item {} 
When an event happens, it executes the function corresponding to
the event and continues to listen.

\item {} 
To finish the GUI loop, often an explicit termination command
has to happen.

\end{itemize}

\item {} 
TkInter is a Python module implementing the Tk toolkit for building
graphical user interfaces. Other languages also have Tk
implementations.

\item {} 
\sphinxstylestrong{Note:} The most important distinction between regular and event
based programming is that the action corresponding to an event gets
executed in parallel with the rest of the program, it does not
block the execution of functions in response to other events.

\end{itemize}


\section{TkInter First Program}
\label{\detokenize{lecture_notes/lec22_tkinter:tkinter-first-program}}\begin{itemize}
\item {} 
Let’s see a very basic program.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{tkinter} \PYG{k}{import} \PYG{o}{*} \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} (1)}

\PYG{n}{root} \PYG{o}{=} \PYG{n}{Tk}\PYG{p}{(}\PYG{p}{)}           \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} (2)}
\PYG{n}{root}\PYG{o}{.}\PYG{n}{mainloop}\PYG{p}{(}\PYG{p}{)}       \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} (3)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}        \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} (4)}
\end{sphinxVerbatim}
\begin{enumerate}
\item {} 
It is common to import everything from Tkinter to make it
easy to write GUI programs. Compare this with the following
program that does the same exact thing but requires using
Tkinter for all calls to the module.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{tkinter}
\PYG{n}{root} \PYG{o}{=} \PYG{n}{tkinter}\PYG{o}{.}\PYG{n}{Tk}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{root}\PYG{o}{.}\PYG{n}{mainloop}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We create the main window that the whole application will
run in. This main window has many properties already: it can be
resized and moved like any window on your computer.

\item {} 
We tell the main window to run in an infinite loop, until it is
explicitly terminated. In this case, you need to explicitly
click on the upper left corner to close this application. This
generates a “destroy” event, which terminates the main window.

\item {} 
To understand the infinite loop notice that \sphinxcode{\sphinxupquote{print "Hello"}}
command is not executed until the window terminates and the
main loop ends.

\end{enumerate}

\end{itemize}


\section{Widgets and Containers}
\label{\detokenize{lecture_notes/lec22_tkinter:widgets-and-containers}}\begin{itemize}
\item {} 
GUIs involve two main types of objects: widgets and containers

\item {} 
Widgets are objects that have a function and are visible. These
are the main elements of an interface. We will see the following
main widgets:
\begin{itemize}
\item {} 
Buttons: can do something when clicked

\item {} 
Canvas: you can draw shapes or put shape in them

\end{itemize}

\item {} 
There are many other widgets like radio boxes, check boxes, menu of
items, etc. You can learn these as we get comfortable with these two.

\item {} 
Containers are invisible, but they allow us to group widgets and
arrange them in visual groups. We will see only one type of container
in this lecture:
\begin{itemize}
\item {} 
Frames: can contain any of the widgets of the above type

\end{itemize}

\item {} 
Containers’ size will grow and shrink to fit the objects contained
within. Containers can contain other containers as well.

\end{itemize}


\section{Example use of containers and buttons}
\label{\detokenize{lecture_notes/lec22_tkinter:example-use-of-containers-and-buttons}}\begin{itemize}
\item {} 
Let’s create a first program to create four buttons, put two
pairs in one frame, the second pairs in another frame, and then
arrange these two frames on top of each other.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{tkinter} \PYG{k}{import} \PYG{o}{*}

\PYG{n}{root} \PYG{o}{=} \PYG{n}{Tk}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{main\PYGZus{}frame} \PYG{o}{=} \PYG{n}{Frame}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
\PYG{n}{main\PYGZus{}frame}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{top\PYGZus{}frame} \PYG{o}{=} \PYG{n}{Frame}\PYG{p}{(}\PYG{n}{main\PYGZus{}frame}\PYG{p}{)}
\PYG{n}{top\PYGZus{}frame}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{TOP}\PYG{p}{)}

\PYG{n}{bottom\PYGZus{}frame} \PYG{o}{=} \PYG{n}{Frame}\PYG{p}{(}\PYG{n}{main\PYGZus{}frame}\PYG{p}{)}
\PYG{n}{bottom\PYGZus{}frame}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{BOTTOM}\PYG{p}{)}

\PYG{n}{button1} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n}{top\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Top 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{button1}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{LEFT}\PYG{p}{)}
\PYG{n}{button2} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n}{top\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Top 2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{button2}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{RIGHT}\PYG{p}{)}

\PYG{n}{button3} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n}{bottom\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bottom 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{button3}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{LEFT}\PYG{p}{)}
\PYG{n}{button4} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n}{bottom\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bottom 2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{button4}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{RIGHT}\PYG{p}{)}

\PYG{n}{root}\PYG{o}{.}\PYG{n}{mainloop}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
In the above example, the two frames for containing buttons are
organized inside another frame.

\item {} 
The organization between widgets is achieved by a strict hierarchy.
Each widget or container has a parent:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
GUI Element
&\sphinxstyletheadfamily 
Parent
\\
\hline
root
&
None
\\
\hline
main\_frame
&
root
\\
\hline
top\_frame
&
main\_frame
\\
\hline
bottom\_frame
&
main\_frame
\\
\hline
button1
&
top\_frame
\\
\hline
button2
&
top\_frame
\\
\hline
button3
&
bottom\_frame
\\
\hline
button4
&
bottom\_frame
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\item {} 
Whenever you create a frame, button, canvas, the first argument is the
parent element.
\begin{itemize}
\item {} 
Parent element tells us the placement of the widget, e.g. \sphinxcode{\sphinxupquote{button1}} is
placed to the left of \sphinxcode{\sphinxupquote{top\_frame}} and \sphinxcode{\sphinxupquote{top\_frame}} is to the top of
\sphinxcode{\sphinxupquote{main\_frame}} and \sphinxcode{\sphinxupquote{main\_frame}} is within the main window of \sphinxcode{\sphinxupquote{root}}.

\item {} 
Parent container’s size is determined as a function of the sizes of
its children. If nothing was put in a container, its size may be zero.

\end{itemize}

\item {} 
Pack will make the interface element a part of the GUI, creating them is not
enough. You must attach them to the interface with packing.

\item {} 
By changing the arguments to \sphinxcode{\sphinxupquote{pack()}} we can alter the
placement of the buttons and the frames.

\end{itemize}


\section{Running tkinter programs using classes}
\label{\detokenize{lecture_notes/lec22_tkinter:running-tkinter-programs-using-classes}}\begin{itemize}
\item {} 
Already our programs are becoming long and so far they don’t really
do anything yet!  What we really want is to have programs
accomplish tasks when a button is pressed (for example).

\item {} 
As it is generally tricky to pass variables between different
Tkinter events, we often use classes to implement the main Tk
applications.

The member attributes will help us pass values between
events.

\item {} 
We will first rewrite the above program using classes as shown
below.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{tkinter} \PYG{k}{import} \PYG{o}{*}

\PYG{k}{class} \PYG{n+nc}{MyApp}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{parent}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame} \PYG{o}{=} \PYG{n}{Frame}\PYG{p}{(}\PYG{n}{parent}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{top\PYGZus{}frame} \PYG{o}{=} \PYG{n}{Frame}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{top\PYGZus{}frame}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{TOP}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{bottom\PYGZus{}frame} \PYG{o}{=} \PYG{n}{Frame}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{bottom\PYGZus{}frame}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{BOTTOM}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button1} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{top\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Top 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button1}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{LEFT}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button2} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{top\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Top 2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button2}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{RIGHT}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button3} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{bottom\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bottom 1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button3}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{LEFT}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button4} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{bottom\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bottom 2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button4}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{RIGHT}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{root} \PYG{o}{=} \PYG{n}{Tk}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{myapp} \PYG{o}{=} \PYG{n}{MyApp}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
    \PYG{n}{root}\PYG{o}{.}\PYG{n}{mainloop}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
This is the main idea: Any object outside of root is defined within
a class, using root as the parent.

\item {} 
We can now add functionality to this class that will modify the
widgets.

\end{itemize}


\section{Button Click}
\label{\detokenize{lecture_notes/lec22_tkinter:button-click}}\begin{itemize}
\item {} 
You track many events in a GUI, but we will not see
them (such as when a specific mouse button, left or right, is
clicked, when it is released, when the cursor is moved, when
something is typed on the keyboard, etc.)

(Note: The distinction between the
widget that is the GUI button, and the physical button on your
mouse.)

\item {} 
Command attribute of \sphinxtitleref{Button} allows you to associate a function name
with a button click (in GUI terms this is a combination of two
events: left button click and its release).

See the following example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{bottom\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Quit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{command}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{terminate\PYGZus{}program}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
The button we generate in this example has a function binding: when it
is clicked, it will call the function called \sphinxtitleref{self.terminate\_program}.

\end{itemize}


\section{Example Program with a Button Click}
\label{\detokenize{lecture_notes/lec22_tkinter:example-program-with-a-button-click}}\begin{itemize}
\item {} 
This simple program terminates the program by completely destroying the
root window.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{tkinter} \PYG{k}{import} \PYG{o}{*}

\PYG{k}{class} \PYG{n+nc}{MyApp}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{parent}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parent} \PYG{o}{=} \PYG{n}{parent}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame} \PYG{o}{=} \PYG{n}{Frame}\PYG{p}{(}\PYG{n}{parent}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Quit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{command}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{terminate\PYGZus{}program}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button}\PYG{o}{.}\PYG{n}{configure}\PYG{p}{(}\PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{n}{padx}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4m}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{pady}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4m}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{terminate\PYGZus{}program}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parent}\PYG{o}{.}\PYG{n}{destroy}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{root} \PYG{o}{=} \PYG{n}{Tk}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{myapp} \PYG{o}{=} \PYG{n}{MyApp}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
    \PYG{n}{root}\PYG{o}{.}\PYG{n}{mainloop}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Here we see the use of classes for two important functions:
\begin{itemize}
\item {} 
Keeping track of the root as the parent of all the GUI elements.

\item {} 
Defining a function that can access the parent object attached to \sphinxtitleref{self} and destroy
it by ending the application.

\end{itemize}

\item {} 
We also saw that you can control the size of the button by configuring its width. Padding
on x and y allows us to control how the button is placed inside the frame.

\end{itemize}


\section{Canvas Widget}
\label{\detokenize{lecture_notes/lec22_tkinter:canvas-widget}}\begin{itemize}
\item {} 
This is the last widget we will see today. Canvas is a blank area. You can continuously
draw things in it or put text in it. Here are some basic operations.

\item {} 
Create canvas:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{canvas} \PYG{o}{=} \PYG{n}{Canvas}\PYG{p}{(}\PYG{n}{parent}\PYG{p}{,} \PYG{n}{height}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{canvas}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Draw something in a canvas (an oval within the given box coordinates):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{canvas}\PYG{o}{.}\PYG{n}{create\PYGZus{}oval}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Remember, like Image objects, (0,0) represents the top left corner.

\item {} 
When you draw multiple things in a canvas, it may not immediately
show what you draw and a small delay may be noticed. You can force
the canvas to show you what you draw with:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{canvas}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
You can also draw lines, rectangles and text. See more on:

\sphinxurl{http://effbot.org/tkinterbook/canvas.htm}

\end{itemize}


\section{Timing of GUI Events}
\label{\detokenize{lecture_notes/lec22_tkinter:timing-of-gui-events}}\begin{itemize}
\item {} 
Remember, GUI events are triggered when you click a button (or other
events you watch in more sophisticated systems).

\item {} 
They execute in parallel. If the processing of an event takes some
time, it may overlap with another event.

\item {} 
Sometimes drawing events are too fast for the eye to see the progress.
You can incorporate some delays to make this more pleasing to the eye.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{canvas}\PYG{o}{.}\PYG{n}{after}\PYG{p}{(}\PYG{n}{waittime}\PYG{p}{)}
\end{sphinxVerbatim}

which will add a small delay \sphinxtitleref{waittime} to the program.

\item {} 
Note that \sphinxtitleref{after} and \sphinxtitleref{update} functions apply to many other GUI elements.
Mastering them will help you get the exact timing effect from your interface.

\end{itemize}


\section{Final Program}
\label{\detokenize{lecture_notes/lec22_tkinter:final-program}}\begin{itemize}
\item {} 
Here is a final program to put together a lot of the things we learned. It
features a private class method (\sphinxtitleref{new\_button}) that is only accessible
to the \sphinxtitleref{\_\_init\_\_} function. It shows how functions can be used to automate
repetitive tasks.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{tkinter} \PYG{k}{import} \PYG{o}{*}

\PYG{k}{class} \PYG{n+nc}{MyApp}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{parent}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{} This method is internal to the initializer method}
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{} and is used for creating buttons. It shortens the program code}
        \PYG{k}{def} \PYG{n+nf}{new\PYGZus{}button}\PYG{p}{(}\PYG{n}{parent}\PYG{p}{,} \PYG{n}{cmd}\PYG{p}{,} \PYG{n}{buttontext}\PYG{p}{,} \PYG{n}{packlocation}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{button} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n}{parent}\PYG{p}{,} \PYG{n}{command}\PYG{o}{=}\PYG{n}{cmd}\PYG{p}{)}
            \PYG{n}{button}\PYG{o}{.}\PYG{n}{configure}\PYG{p}{(}\PYG{n}{text}\PYG{o}{=}\PYG{n}{buttontext}\PYG{p}{)}
            \PYG{n}{button}\PYG{o}{.}\PYG{n}{configure}\PYG{p}{(}\PYG{n}{width}\PYG{o}{=}\PYG{n}{button\PYGZus{}width}\PYG{p}{,}
                  \PYG{n}{padx}\PYG{o}{=}\PYG{n}{button\PYGZus{}padx}\PYG{p}{,} \PYG{n}{pady}\PYG{o}{=}\PYG{n}{button\PYGZus{}pady} \PYG{p}{)}
            \PYG{n}{button}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{packlocation}\PYG{p}{)}
            \PYG{k}{return} \PYG{n}{button}

        \PYG{c+c1}{\PYGZsh{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} constants for controlling layout \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
        \PYG{n}{button\PYGZus{}width} \PYG{o}{=} \PYG{l+m+mi}{10}
        \PYG{n}{button\PYGZus{}padx} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2m}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{button\PYGZus{}pady} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1m}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{buttons\PYGZus{}frame\PYGZus{}padx} \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3m}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{buttons\PYGZus{}frame\PYGZus{}pady} \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2m}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{buttons\PYGZus{}frame\PYGZus{}ipadx} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3m}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{buttons\PYGZus{}frame\PYGZus{}ipady} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1m}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} end constants \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

        \PYG{c+c1}{\PYGZsh{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}variables for controlling the function\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{canvas\PYGZus{}dimension} \PYG{o}{=} \PYG{l+m+mi}{600} \PYG{c+c1}{\PYGZsh{}\PYGZsh{}Canvas will be a square}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{wait\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{8}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{repetitions} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{c+c1}{\PYGZsh{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}end of variables\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{myParent} \PYG{o}{=} \PYG{n}{parent}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame} \PYG{o}{=} \PYG{n}{Frame}\PYG{p}{(}\PYG{n}{parent}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame}\PYG{o}{.}\PYG{n}{pack} \PYG{p}{(}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{}\PYGZsh{} Two frames inside the main frame, one for the canvas}
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{} on top and the second one for buttons in the bottom}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{draw\PYGZus{}frame} \PYG{o}{=} \PYG{n}{Frame}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{draw\PYGZus{}frame}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{TOP}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{info\PYGZus{}canvas} \PYG{o}{=} \PYG{n}{Canvas}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{draw\PYGZus{}frame}\PYG{p}{,} \PYG{n}{height}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,}
                                   \PYG{n}{width}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{canvas\PYGZus{}dimension}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{info\PYGZus{}canvas}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{TOP}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{text\PYGZus{}area} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{info\PYGZus{}canvas}\PYG{o}{.}\PYG{n}{create\PYGZus{}text}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{anchor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nw}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{info\PYGZus{}canvas}\PYG{o}{.}\PYG{n}{itemconfigure}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{text\PYGZus{}area}\PYG{p}{,}\PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}circles = }\PYG{l+s+si}{\PYGZob{}:d\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{repetitions}\PYG{p}{)}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}canvas} \PYG{o}{=} \PYG{n}{Canvas}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{draw\PYGZus{}frame}\PYG{p}{,} \PYGZbs{}
                                  \PYG{n}{height}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{canvas\PYGZus{}dimension}\PYG{p}{,}
                                  \PYG{n}{width}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{canvas\PYGZus{}dimension}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}canvas}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button\PYGZus{}frame} \PYG{o}{=} \PYG{n}{Frame}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button\PYGZus{}frame}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{n}{side}\PYG{o}{=}\PYG{n}{BOTTOM}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{draw\PYGZus{}button} \PYG{o}{=} \PYG{n}{new\PYGZus{}button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button\PYGZus{}frame}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Draw}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{LEFT}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{clear\PYGZus{}button} \PYG{o}{=} \PYG{n}{new\PYGZus{}button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button\PYGZus{}frame}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Clear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{LEFT}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{increase\PYGZus{}button} \PYG{o}{=} \PYG{n}{new\PYGZus{}button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button\PYGZus{}frame}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{increase}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Increase}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{LEFT}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{reduce\PYGZus{}button} \PYG{o}{=} \PYG{n}{new\PYGZus{}button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button\PYGZus{}frame}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{reduce}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Reduce}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{LEFT}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{quit\PYGZus{}button} \PYG{o}{=} \PYG{n}{new\PYGZus{}button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button\PYGZus{}frame}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{quit}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Quit}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{RIGHT}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{clear}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}canvas}\PYG{o}{.}\PYG{n}{delete}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{all}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{reduce}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{repetitions} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{repetitions} \PYG{o}{/}\PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{put\PYGZus{}info}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{increase}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{repetitions} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{200}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{repetitions} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{put\PYGZus{}info}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{put\PYGZus{}info}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{} Change the text field in the canvas}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{info\PYGZus{}canvas}\PYG{o}{.}\PYG{n}{itemconfigure}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{text\PYGZus{}area}\PYG{p}{,}\PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}circles = }\PYG{l+s+si}{\PYGZob{}:d\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{repetitions}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{draw}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{boundary\PYGZus{}offset} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n}{max\PYGZus{}radius} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{canvas\PYGZus{}dimension} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{boundary\PYGZus{}offset}\PYG{p}{)} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}
        \PYG{n}{xc} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{canvas\PYGZus{}dimension}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{boundary\PYGZus{}offset}
        \PYG{n}{r} \PYG{o}{=} \PYG{n}{max\PYGZus{}radius}\PYG{o}{/}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{repetitions}
        \PYG{n}{inc} \PYG{o}{=} \PYG{n}{r}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{repetitions}\PYG{p}{)}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}canvas}\PYG{o}{.}\PYG{n}{create\PYGZus{}oval}\PYG{p}{(}\PYG{p}{(}\PYG{n}{xc}\PYG{o}{\PYGZhy{}}\PYG{n}{r}\PYG{p}{,} \PYG{n}{xc}\PYG{o}{\PYGZhy{}}\PYG{n}{r}\PYG{p}{,} \PYG{n}{xc}\PYG{o}{+}\PYG{n}{r}\PYG{p}{,} \PYG{n}{xc}\PYG{o}{+}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{r} \PYG{o}{+}\PYG{o}{=} \PYG{n}{inc}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}canvas}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Actually refresh the drawing on the canvas.}
            \PYG{c+c1}{\PYGZsh{} Pause execution.  This allows the eye to catch up}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}canvas}\PYG{o}{.}\PYG{n}{after}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{wait\PYGZus{}time}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{quit}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{myParent}\PYG{o}{.}\PYG{n}{destroy}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{root} \PYG{o}{=} \PYG{n}{Tk}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{root}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Drawing a circle}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}\PYGZsh{}Give a title to the program}
    \PYG{n}{myapp} \PYG{o}{=} \PYG{n}{MyApp}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
    \PYG{n}{root}\PYG{o}{.}\PYG{n}{mainloop}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Summary}
\label{\detokenize{lecture_notes/lec22_tkinter:summary}}\begin{itemize}
\item {} 
Graphical user interfaces are event driven. You need to write functions
to initialize the interface and change the interface when events happen.

\item {} 
The most common events are button clicks, but many others are possible.

\item {} 
Most GUI elements are visible and are called widgets.

\item {} 
Widgets are placed in invisible containers like frames to group them together.

\item {} 
Many containers have built-in methods for placing multiple widgets in a way
that is pleasing to the eye.

\item {} 
When building an interface, some of the challenges involve making the interface
easy and intuitive to use. Many communications classes concentrate on these
issues.

\end{itemize}


\chapter{Lecture 22 — Exercises}
\label{\detokenize{lecture_notes/lec22_tkinter_exercises/exercises:lecture-22-exercises}}\label{\detokenize{lecture_notes/lec22_tkinter_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for
automatic scoring.  A separate file must submitted for each problem.
Solutions must be submitted by 4 pm on Friday, December 1.
\begin{enumerate}
\item {} 
What is printed out when the following code is run? Assume
that the user clicks on the “Launch” button and nothing else.  Put
your answer into a text file and submit it as the answer to
part 1.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{tkinter} \PYG{k}{import} \PYG{o}{*}

\PYG{k}{class} \PYG{n+nc}{MyApp}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{parent}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Initialized!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parent} \PYG{o}{=} \PYG{n}{parent}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame} \PYG{o}{=} \PYG{n}{Frame}\PYG{p}{(}\PYG{n}{parent}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button1} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Launch}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{command}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{terminate\PYGZus{}program}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button1}\PYG{o}{.}\PYG{n}{configure}\PYG{p}{(}\PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{n}{padx}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4m}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{pady}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4m}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button1}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button2} \PYG{o}{=} \PYG{n}{Button}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{main\PYGZus{}frame}\PYG{p}{,} \PYG{n}{text}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{C}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{command}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{c}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button2}\PYG{o}{.}\PYG{n}{configure}\PYG{p}{(}\PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{n}{padx}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4m}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{pady}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4m}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{button2}\PYG{o}{.}\PYG{n}{pack}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{rocket} \PYG{o}{=} \PYG{l+m+mi}{2}

    \PYG{k}{def} \PYG{n+nf}{d}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{rocket} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}

    \PYG{k}{def} \PYG{n+nf}{c}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Launching ... counting}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{rocket}\PYG{p}{)}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{...}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{rocket}\PYG{p}{)}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{rocket} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{...Liftoff!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{flush}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{terminate\PYGZus{}program}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{c}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Terminated}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parent}\PYG{o}{.}\PYG{n}{destroy}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{root} \PYG{o}{=} \PYG{n}{Tk}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Countdown ready}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{myapp} \PYG{o}{=} \PYG{n}{MyApp}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
    \PYG{n}{myapp}\PYG{o}{.}\PYG{n}{d}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{root}\PYG{o}{.}\PYG{n}{mainloop}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{myapp}\PYG{o}{.}\PYG{n}{d}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{myapp}\PYG{o}{.}\PYG{n}{rocket}\PYG{p}{)}
    \PYG{n}{myapp}\PYG{o}{.}\PYG{n}{c}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Done}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Revisiting the same code, what is printed if the code is run a second time
and the user clicks the “C” button and
nothing else? Put your answer into a text file and submit it as the answer to
part 2.

\end{enumerate}


\chapter{Lecture 23 — Recursion}
\label{\detokenize{lecture_notes/lec23_recursion:lecture-23-recursion}}\label{\detokenize{lecture_notes/lec23_recursion::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/lec23_recursion:overview}}\begin{itemize}
\item {} 
When a function calls itself, it is known as a recursive function.

\item {} 
Use of the function call stack allows Python to handle recursive
functions correctly.

\item {} 
Examples include factorial, Fibonacci, greatest common divisor,
flattening a list of lists, and  mergesort.

\item {} 
We’ll think about how to hand-simulate a recursive function as well
as rules for writing recursive functions.

\end{itemize}


\section{Our First Example}
\label{\detokenize{lecture_notes/lec23_recursion:our-first-example}}\begin{itemize}
\item {} 
Consider the following Python function.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{blast}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
        \PYG{n}{blast}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Blast off!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
What is the the output from the call?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{blast}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Python’s Call Stack Mechanism}
\label{\detokenize{lecture_notes/lec23_recursion:pythons-call-stack-mechanism}}
The following mechanism helps us understand what is happening:
\begin{itemize}
\item {} 
Each time the code makes a function call, Python puts information on
the “call stack”, including
\begin{itemize}
\item {} 
All values of parameters and local variables

\item {} 
The location in the code where the function call is being made.

\end{itemize}

\item {} 
Python then makes the function call, switching execution to the start
of the called function.

\item {} 
This function in turn can make additional (potentially recursive)
function calls, adding information to the top of the stack each time.

\item {} 
When a function ends, Python looks at the top of the stack, and
\begin{itemize}
\item {} 
restores the values of the local variables and parameters of the
most recent calling function,

\item {} 
removes this information from the top of the stack,

\item {} 
inserts the returned value of the called function (if any) in the
appropriate location of the calling function’s code, and

\item {} 
continues execution from the location where the call was made.

\end{itemize}

\end{itemize}


\section{Practice Problems to Illustrate This}
\label{\detokenize{lecture_notes/lec23_recursion:practice-problems-to-illustrate-this}}
What are the outputs of the following?

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rp1}\PYG{p}{(} \PYG{n}{L}\PYG{p}{,} \PYG{n}{i} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{rp1}\PYG{p}{(} \PYG{n}{L}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{rp2}\PYG{p}{(} \PYG{n}{L}\PYG{p}{,} \PYG{n}{i} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rp2}\PYG{p}{(} \PYG{n}{L}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{L} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{11} \PYG{p}{]}
\PYG{n}{rp1}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{rp2}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

Note that the entirety of list \sphinxcode{\sphinxupquote{L}} is not copied to the top of the
stack. Instead, a reference (an alias) to \sphinxcode{\sphinxupquote{L}} is placed on the stack.


\section{Factorial}
\label{\detokenize{lecture_notes/lec23_recursion:factorial}}\begin{itemize}
\item {} 
The factorial function is
\begin{equation*}
\begin{split}n! = n (n-1) (n-2) \cdots 1\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}0! = 1\end{split}
\end{equation*}
\item {} 
This is an imprecise definition because the … is not
formally defined.

\item {} 
Writing this recursively helps to clear it up:
\begin{equation*}
\begin{split}n! = n \cdot (n-1)!\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}0! = 1\end{split}
\end{equation*}
The factorial is now defined in terms of itself, but on a smaller
number!

\item {} 
Note how this definition now has a recursive part and a non-recursive
part:
\begin{itemize}
\item {} 
The non-recursive part is called the \sphinxstyleemphasis{base case}. There must be
\sphinxstyleemphasis{at least} one base case in every recursive function definition.

\end{itemize}

\end{itemize}


\section{Exploring Factorial}
\label{\detokenize{lecture_notes/lec23_recursion:exploring-factorial}}
We will:
\begin{itemize}
\item {} 
Write a recursive Python function to implement \(n!\).

\item {} 
Hand-simulate the call stack for \(n=4\).

\end{itemize}

We’ll add output code to the implementation to help visualize the
recursive calls in a different way.


\section{Guidelines for Writing Recursive Functions}
\label{\detokenize{lecture_notes/lec23_recursion:guidelines-for-writing-recursive-functions}}\begin{enumerate}
\item {} 
Define the problem you are trying to solve in terms of smaller /
simpler instances of the problem. This includes
\begin{enumerate}
\item {} 
What needs to happen before making a recursive call?

\item {} 
What recursive call(s) must be made?

\item {} 
What needs to happen to combine or generate results after the
recursive call (or calls) ends?

\end{enumerate}

\item {} 
Define the base case or cases.

\item {} 
Make sure the code is proceeding toward the base case in every step.

\end{enumerate}


\section{Fibonacci}
\label{\detokenize{lecture_notes/lec23_recursion:fibonacci}}\begin{itemize}
\item {} 
The Fibonacci sequence starts with the values 0 and 1.

\item {} 
Each new value in the sequence is obtained by adding the two previous
values, producing
\begin{equation*}
\begin{split}0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \ldots\end{split}
\end{equation*}
\item {} 
Recursively, the \(n^\text{th}\) value, \(f_n\), of the
sequence is defined as
\begin{equation*}
\begin{split}f_n = f_{n-1} + f_{n-2}\end{split}
\end{equation*}
\item {} 
This leads naturally to a recursive function…

\end{itemize}


\section{Dangers of Recursion}
\label{\detokenize{lecture_notes/lec23_recursion:dangers-of-recursion}}\begin{itemize}
\item {} 
Some recursive function implementations contain wasteful repeated
computation.

\item {} 
Recursive function calls — like any function calls — typically
involve hidden overhead costs.

\item {} 
Often, therefore, a recursive function can (and should) be replaced
with a non-recursive, \sphinxstyleemphasis{iterative} function that is significantly more
efficient.

\item {} 
This is easy to do for both Factorial and Fibonacci, as we will see
in class.

\end{itemize}


\section{Why, Then, Do We Study Recursion?}
\label{\detokenize{lecture_notes/lec23_recursion:why-then-do-we-study-recursion}}\begin{itemize}
\item {} 
Many of our definitions and even, our logical structures (such as
lists), are formalized using recursion.

\item {} 
Sometimes recursive functions are the first ones we come up with and
the easiest to write (at least after you are comfortable with
recursion).
\begin{itemize}
\item {} 
Only later do we write non-recursive versions.

\end{itemize}

\item {} 
Sometimes on harder problems it is difficult to even write non-recursive
functions!  The list flattening problem below is one such example.

\end{itemize}


\section{Advanced Examples}
\label{\detokenize{lecture_notes/lec23_recursion:advanced-examples}}
We’ll spend the rest of class on three more advanced examples:
\begin{enumerate}
\item {} 
Recursive geometric shapes:  the Sierpinski triangle

\item {} 
Flattening a nested list

\item {} 
A recursive version of merge sort

\end{enumerate}


\section{Recursive Geometric Shapes}
\label{\detokenize{lecture_notes/lec23_recursion:recursive-geometric-shapes}}\begin{itemize}
\item {} 
Fractals are often defined using recursion. How do we draw a
Sierpinski triangle like the one shown below?

\noindent\sphinxincludegraphics{{sierpinski}.jpg}

\item {} 
We will look at this example in class and attempt to define the
recursion.

\item {} 
To aid us, we’ll look at a Tkinter Python program that implements
the drawing of the Sierpinski triangle.

\end{itemize}


\section{Flattening a Nested List}
\label{\detokenize{lecture_notes/lec23_recursion:flattening-a-nested-list}}\begin{itemize}
\item {} 
Suppose we want to take a list such as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{v} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{]} \PYG{p}{]}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

and “flatten” it, converting it to just a list of values with no sublists.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{v} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{12} \PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
This is challenging because we don’t know when we write a function
to solve this problem how “deep” the nesting of
sublists goes.  The solution should handle arbitrary depths:
\begin{itemize}
\item {} 
Many, many data structures (containers) in computer
science have this type of nested / recursive structure:  an entry
in a list may be another list….

\end{itemize}

\item {} 
To solve this problem we will also need to know how to recognize
when an entry in a list is another list.  For this we need to use
the \sphinxcode{\sphinxupquote{type}} function in Python.  The following example should make
this clear:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{12}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{list}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{list}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{int}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\item {} 
Now we are ready to solve the “flattening” problem.  We’ll look at
two different approaches.  In both, the key will be to distinguish
between handling elements that are lists (and therefore must be
flattened recursively) and elements that are not lists.  We’ll
start from…

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{flatten}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}\PYG{p}{:}







\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{v} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{]} \PYG{p}{]}\PYG{p}{]}\PYG{p}{]}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{flatten}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Final Example: Merge Sort}
\label{\detokenize{lecture_notes/lec23_recursion:final-example-merge-sort}}\begin{itemize}
\item {} 
The fundamental idea of merge sort is recursive:
\begin{itemize}
\item {} 
Any list of length 1 is sorted

\item {} 
Otherwise:
\begin{itemize}
\item {} 
Split the list in half

\item {} 
Recursively sort each half

\item {} 
Merge the resulting sorted halves

\end{itemize}

\end{itemize}

\item {} 
We repeat our use of the \sphinxcode{\sphinxupquote{merge}} function from Lecture 20:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{merge}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{,}\PYG{n}{L2}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{i1} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{i2} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{while} \PYG{n}{i1}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{i2}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L2}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{L1}\PYG{p}{[}\PYG{n}{i1}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{L2}\PYG{p}{[}\PYG{n}{i2}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{L}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{[}\PYG{n}{i1}\PYG{p}{]}\PYG{p}{)}
            \PYG{n}{i1} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{L}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{L2}\PYG{p}{[}\PYG{n}{i2}\PYG{p}{]}\PYG{p}{)}
            \PYG{n}{i2} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{L}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{[}\PYG{n}{i1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{L}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{n}{L2}\PYG{p}{[}\PYG{n}{i2}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{L}
\end{sphinxVerbatim}

\item {} 
Using this, we will write the main \sphinxcode{\sphinxupquote{merge\_sort}} function in class.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{merge\PYGZus{}sort}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}\PYG{p}{:}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The solution will be posted on-line.

\item {} 
We will also see how a minor mistake can cause the recursion to
go into an infinite loop.

\end{itemize}

\item {} 
Comparing what we write to our earlier non-recursive version of merge
sort shows that the primary job of the recursion is to organize the
merging process!

\end{itemize}


\section{Summary}
\label{\detokenize{lecture_notes/lec23_recursion:summary}}\begin{itemize}
\item {} 
Functions that call themselves are known as “recursive functions”

\item {} 
Use of a function call stack allows Python to handle recursive
functions correctly.

\item {} 
Many structures and functions important to computer science are
defined recursively.

\item {} 
Fundamentally, recurision is about defining a problem solution as a
function of the solution to a simpler/shorter/smaller version of the
problem.

\item {} 
A basis case (or cases) is (are) always needed to make a recursion
function succeed.

\item {} 
Infinite recursion is avoided by ensuring that progress is made toward
the basis case or cases in every recursive call.

\item {} 
While many recursive functions are easily rewritten to remove the
recursion, some advanced problems are difficult to solve without
recursion.

\end{itemize}


\section{Additional Practice Exercises}
\label{\detokenize{lecture_notes/lec23_recursion:additional-practice-exercises}}\begin{enumerate}
\item {} 
Euclid’s algorithm for finding the greatest common divisor is one of
the oldest known algorithms. If \(a\) and \(b\) are positive
integers, with \(a \geq b\), then let \(r\) be the remainder
of dividing \(a\) by \(b\). If \(r == 0\), then \(b\)
is the GCD of the two integers. Otherwise, the GCD of \(a\) and
\(b\) equals the GCD of \(b\) and \(r\). Here is the
Python code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gcd}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{:}
        \PYG{n}{a}\PYG{p}{,}\PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,}\PYG{n}{a}

    \PYG{n}{r} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{n}{b}
    \PYG{k}{if} \PYG{n}{r}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{b}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{gcd}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,}\PYG{n}{r}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\item {} 
What is the output of

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{gcd}\PYG{p}{(}\PYG{l+m+mi}{36}\PYG{p}{,}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{gcd}\PYG{p}{(}\PYG{l+m+mi}{84}\PYG{p}{,}\PYG{l+m+mi}{65}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{gcd}\PYG{p}{(}\PYG{l+m+mi}{84}\PYG{p}{,}\PYG{l+m+mi}{66}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
Why do we know that \sphinxcode{\sphinxupquote{gcd}} is proceeding toward the base case (as
required by our “rules” of writing recursive functions)?

\end{enumerate}

\item {} 
Specify the recursive calls and return values from our \sphinxcode{\sphinxupquote{merge\_sort}}
implementation for the list

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{81}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{91}\PYG{p}{,} \PYG{l+m+mi}{12} \PYG{p}{]}
\end{sphinxVerbatim}

\end{enumerate}


\chapter{Lecture 23 — Exercises}
\label{\detokenize{lecture_notes/lec23_recursion_exercises/exercises:lecture-23-exercises}}\label{\detokenize{lecture_notes/lec23_recursion_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for automatic
scoring.  A separate file must submitted for each problem.  Start by
downloading \sphinxstyleemphasis{lec23\_ex.zip} from the Piazza site.  Solutions
must be submitted by 4 pm on Tuesday, April 24.
\begin{enumerate}
\item {} 
The following code recursively calculates the maximum value in a
list.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{recursive\PYGZus{}max\PYGZus{}impl}\PYG{p}{(} \PYG{n}{L}\PYG{p}{,} \PYG{n}{i} \PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    The actual recursive function.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{recursive\PYGZus{}max\PYGZus{}impl}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{recursive\PYGZus{}max}\PYG{p}{(} \PYG{n}{L} \PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    The driver for the recursive function.  This handles the special}
\PYG{l+s+sd}{    case of an empty list and otherwise makes the initial call to the}
\PYG{l+s+sd}{    recursive function.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{99999}    \PYG{c+c1}{\PYGZsh{} By convention}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{recursive\PYGZus{}max\PYGZus{}impl}\PYG{p}{(} \PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{L1} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{5} \PYG{p}{]}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{recursive\PYGZus{}max}\PYG{p}{(} \PYG{n}{L1} \PYG{p}{)}\PYG{p}{)}
    \PYG{n}{L2} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mf}{23.1}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{]}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{recursive\PYGZus{}max}\PYG{p}{(} \PYG{n}{L2}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{L2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(} \PYG{l+m+mi}{55} \PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{recursive\PYGZus{}max}\PYG{p}{(} \PYG{n}{L2} \PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Using this as a guide, write a recursive function to add the values
in a list.  You should have to change very little code.  Implement
your code in the provided file \sphinxcode{\sphinxupquote{prob1.py}}

\item {} 
Implement a recursive solution to the Fibonacci number function
definition given during lecture.  Implement your code in the
provided file \sphinxcode{\sphinxupquote{prob2.py}}.

\item {} 
Looking carefully at the Fibonacci definition shows that
calculating Fibonacci number \(f_{n-1}\) requires calculating Fibonacci
number \(f_{n-2}\), which is also required for calculating Fibonacci number
\(f_n\).  This means there is redundant computation.  This redundancy gets
worse for numbers \(f_{n-3}\), \(f_{n-4}\), etc.

Fortunately, the Fibonacci sequence is relatively easy to compute
non-recursively.  That is your problem here.  The trick is to build
up the solution using a for loop that calculates \(f_2\), then \(f_3\),
then \(f_4\), etc. Implement your solution in \sphinxcode{\sphinxupquote{prob3.py}}.

Out of curiosity, you could run your solutions to the previous two
problems on large values of n and time the difference.

\end{enumerate}


\chapter{Lecture 24 — Advanced Python Topics and Functional Programming}
\label{\detokenize{lecture_notes/lec24_functional:lecture-24-advanced-python-topics-and-functional-programming}}\label{\detokenize{lecture_notes/lec24_functional::doc}}

\section{Problems We’d Like to Solve}
\label{\detokenize{lecture_notes/lec24_functional:problems-we-d-like-to-solve}}
Some of these are toy problems, but they illustrate use of tools we’d
like to develop and use:
\begin{enumerate}
\item {} 
How many values are in a list of lists?

\item {} 
What is the maximum distance from the origin of the points in a list?

\item {} 
What is the sum of squares of the first n integers?

\item {} 
Can you sum the positive values in a list?

\item {} 
Can you sort a list of points by y value (2nd coordinate) and then
by x value?

\end{enumerate}


\section{Solution Techniques}
\label{\detokenize{lecture_notes/lec24_functional:solution-techniques}}\begin{itemize}
\item {} 
We can solve most of these with a \sphinxcode{\sphinxupquote{for}} loop, but they can be
solved even more effectively / efficiently / compactly using
advanced Python methods.

\item {} 
Leads to notions of:

\end{itemize}
\begin{itemize}
\item {} 
map and filter

\item {} 
functions as parameters

\item {} 
lambda functions

\item {} 
stable sort

\item {} 
list comprehensions

\end{itemize}
\begin{itemize}
\item {} 
Most are examples of \sphinxstyleemphasis{functional programmming}

\end{itemize}


\section{Map: Apply a function to each element of a list}
\label{\detokenize{lecture_notes/lec24_functional:map-apply-a-function-to-each-element-of-a-list}}\begin{itemize}
\item {} 
Suppose we want to count the number of values in a list of lists.
We can use \sphinxcode{\sphinxupquote{map}} to apply the \sphinxcode{\sphinxupquote{len}} function to each sublist.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v} \PYG{o}{=} \PYG{p}{[} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{17}\PYG{p}{,}\PYG{l+m+mi}{19}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{29}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{31}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{]} \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(} \PYG{n+nb}{len}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)}
\PYG{g+go}{[4, 4, 2, 2]}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{map}} is an \sphinxstyleemphasis{iterator} class:
\begin{itemize}
\item {} 
It produces values in a sequence, one after another, by applying
the function (1st argument) to the values of the second argument.

\item {} 
Technically, an iterator class is one that has the \sphinxcode{\sphinxupquote{\_\_next\_\_}}
method implemented (correctly).

\item {} 
Using \sphinxcode{\sphinxupquote{list}} gives us the list of lengths of the sublists
explicitly.

\end{itemize}

\item {} 
To complete the solution we need to just apply sum:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{12}
\end{sphinxVerbatim}

Notice that this does not explicitly form an intermediate list.

\end{itemize}


\section{Passing Functions as Parameters}
\label{\detokenize{lecture_notes/lec24_functional:passing-functions-as-parameters}}\begin{itemize}
\item {} 
The above example passes the \sphinxcode{\sphinxupquote{len}} function as an argument!
\begin{itemize}
\item {} 
We also passed functions as arguments to our callbacks in our GUI
programs

\end{itemize}

\item {} 
This illustrates the concept that Python treats function as
“first-class” objects - in other words functions can be used just
like variables and other data.
\begin{itemize}
\item {} 
What’s passed as an argument to \sphinxcode{\sphinxupquote{map()}} is the location of
the function code.

\end{itemize}

\item {} 
Now suppose we want to find the maximum distance of a list of points
from the origin.  Here we’ll have to write a function

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dist2D}\PYG{p}{(} \PYG{n}{p} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}

\PYG{n}{pts} \PYG{o}{=} \PYG{p}{[} \PYG{p}{(}\PYG{l+m+mf}{4.5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{6.8}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{1.4}\PYG{p}{,} \PYG{l+m+mf}{2.9}\PYG{p}{)} \PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{max}\PYG{p}{(} \PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{dist2D}\PYG{p}{,}\PYG{n}{pts}\PYG{p}{)} \PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\section{Lambda functions:  Anonymous functions}
\label{\detokenize{lecture_notes/lec24_functional:lambda-functions-anonymous-functions}}\begin{itemize}
\item {} 
We can avoid the need to write a separate function here by writing an
\sphinxstyleemphasis{anonymous} function called a \sphinxstyleemphasis{lambda} function.

\item {} 
Our first example is just squaring the values of a list

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4} \PYG{p}{]} \PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[ 1, 4, 9, 16 ]}
\end{sphinxVerbatim}

\item {} 
Now, we can sum the squares from 1 to n

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sum}\PYG{p}{(} \PYG{n+nb}{map}\PYG{p}{(} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
We can also implement the \sphinxcode{\sphinxupquote{dist2D}} function anonymously:

\end{itemize}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{max}\PYG{p}{(} \PYG{n+nb}{map}\PYG{p}{(} \PYG{k}{lambda} \PYG{n}{p}\PYG{p}{:} \PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{pts}\PYG{p}{)} \PYG{p}{)}
\PYG{g+go}{7.432361670424818}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
Notice that we did not need to explicitly form a list in each of
the preceeding examples.  This leads to substantial savings when
the list is large!

\item {} 
Aside: the notion of a lambda function goes all the way back to
the origin of computer science

\end{itemize}


\section{In-Class Practice Problem:}
\label{\detokenize{lecture_notes/lec24_functional:in-class-practice-problem}}\begin{enumerate}
\item {} 
Starting with the following list of x,y point coordinate types, we
will use \sphinxcode{\sphinxupquote{map()}}, a lambda function, and \sphinxcode{\sphinxupquote{max()}} to find the
maximum x coordinate (the 0-th coordinate) in a list of points.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pts} \PYG{o}{=} \PYG{p}{[} \PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{7.5}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mf}{4.4}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{]}
\end{sphinxVerbatim}

\end{enumerate}


\section{Filter:  Extract / eliminate values from a list}
\label{\detokenize{lecture_notes/lec24_functional:filter-extract-eliminate-values-from-a-list}}\begin{itemize}
\item {} 
Consider a different problem:  how to eliminate all of the negative
values from a list.  Based on what we know so far, this requires a
for loop with append.

\item {} 
We can simplify this using the built-in Python construct
called \sphinxcode{\sphinxupquote{filter}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{filter}\PYG{p}{(} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[1, 9, 10]}
\end{sphinxVerbatim}

\item {} 
Here,
\begin{itemize}
\item {} 
The lambda function must produce a boolean value and if that
value is \sphinxcode{\sphinxupquote{True}} the list item is kept; otherwise it is
eliminated.

\item {} 
The result of \sphinxcode{\sphinxupquote{filter}} is an iterator object, just like the
result of \sphinxcode{\sphinxupquote{map}} is.  We convert to a list in order to display
the answer.

\end{itemize}

\item {} 
If we want to sum up the non-negative values, then we don’t need to
explicitly generate a list:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n+nb}{filter}\PYG{p}{(} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{20}
\end{sphinxVerbatim}

\end{itemize}


\section{Lecture Exercises, Problems 1 and 2:}
\label{\detokenize{lecture_notes/lec24_functional:lecture-exercises-problems-1-and-2}}\begin{itemize}
\item {} 
At this point students will be given the chance to work on the
first two lecture exercises.

\end{itemize}


\section{Passing Functions to Sort}
\label{\detokenize{lecture_notes/lec24_functional:passing-functions-to-sort}}\begin{itemize}
\item {} 
Consider the problem of sorting a list of (x,y) points by their y
values first and their x values for tied y values, both in
decreasing order.  For example, given

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pts} \PYG{o}{=} \PYG{p}{[} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
          \PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{p}{]}
\end{sphinxVerbatim}

we’d like the sorted order to be

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
     \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
The Python sort function

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} } \PYG{n+nb}{sorted}\PYG{p}{(} \PYG{n}{pts}\PYG{p}{,} \PYG{n}{reverse}\PYG{o}{=}\PYG{k+kc}{True} \PYG{p}{)}
\PYG{g+go}{[(14, 10), (12, 10), (12, 3), (12, 1), (8, 12), (6, 5), \PYGZbs{}}
\PYG{g+go}{    (5, 3), (2, 5)]}
\end{sphinxVerbatim}

gives the ordering by x value and then by y value. This is not what
we want.

\item {} 
The first step to a solution is to provide a \sphinxstyleemphasis{key} function to
\sphinxcode{\sphinxupquote{sorted()}} to pull out the information (the y value in this
case) from each tuple to use as the basis for sorting:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sorted}\PYG{p}{(} \PYG{n}{pts}\PYG{p}{,} \PYG{n}{key} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{p}\PYG{p}{:} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{reverse}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{[(8, 12), (14, 10), (12, 10), (2, 5), (6, 5), (12, 3), \PYGZbs{}}
\PYG{g+go}{    (5, 3), (12, 1)]}
\end{sphinxVerbatim}

This is close but not quite right because the two points with y=5
are out of order.

\item {} 
The trick is to sort by x first and then sort by y!

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{by\PYGZus{}x} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{pts}\PYG{p}{,}\PYG{n}{reverse}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{by\PYGZus{}x}
\PYG{g+go}{[(14, 10), (12, 10), (12, 3), (12, 1), (8, 12), (6, 5), \PYGZbs{}}
\PYG{g+go}{   (5, 3), (2, 5)]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sorted}\PYG{p}{(} \PYG{n}{by\PYGZus{}x}\PYG{p}{,} \PYG{n}{key} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{p}\PYG{p}{:} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{reverse}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{[(8, 12), (14, 10), (12, 10), (6, 5), (2, 5), (12, 3), \PYGZbs{}}
\PYG{g+go}{   (5, 3), (12, 1)]}
\end{sphinxVerbatim}

\item {} 
This works because \sphinxcode{\sphinxupquote{sorted()}} uses what’s known as a \sphinxstyleemphasis{stable
sort}:  when two values are “tied” according the
sorting criteria (y value in the second sort) their relative
ordering (by x value from the first sort) in the final list is preserved.
\begin{itemize}
\item {} 
Therefore, (6,5) comes earlier than (2,5), while (12,3) comes
earlier than (5,3)

\end{itemize}

\item {} 
A number of variations on sorting use this “stable sort” property,
but not all fast sorting algorithms are stable.

\item {} 
Of course, we can also extend our lambda to reverse the tuple provided to sort()

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n+nb}{sorted}\PYG{p}{(} \PYG{n}{pts}\PYG{p}{,} \PYG{n}{key} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{p}\PYG{p}{:} \PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{reverse}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
   \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{itemize}


\section{Practice Problem}
\label{\detokenize{lecture_notes/lec24_functional:practice-problem}}\begin{enumerate}
\item {} 
Use \sphinxcode{\sphinxupquote{filter}} to eliminate all words that are shorter than 4
letters from a list of words

\end{enumerate}


\section{List Comprehensions}
\label{\detokenize{lecture_notes/lec24_functional:list-comprehensions}}\begin{itemize}
\item {} 
Instead of \sphinxcode{\sphinxupquote{map}} and \sphinxcode{\sphinxupquote{filter}} some people prefer another example
of functional programming in Python called \sphinxstyleemphasis{list comprehensions}

\item {} 
Here is an example to generate a list of the squares of the first n integers:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{8}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[} \PYG{n}{i}\PYG{o}{*}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{]}
\PYG{g+go}{[1, 4, 9, 16, 25, 36, 49, 64]}
\end{sphinxVerbatim}

\item {} 
The form of this is an expression followed by a \sphinxcode{\sphinxupquote{for}} loop
statement.

\item {} 
We can get the effect of \sphinxcode{\sphinxupquote{filter}} by adding a conditional at the
end:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[} \PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{v} \PYG{k}{if} \PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0} \PYG{p}{]}
\PYG{g+go}{[1, 9, 10]}
\end{sphinxVerbatim}

\item {} 
Here, the values are only generated in the resultant list when the
\sphinxcode{\sphinxupquote{if}} condition passes.

\item {} 
We can combine these as well.  As a slightly silly example, we can
eliminate the negative values and square the positive values

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[} \PYG{n}{x}\PYG{o}{*}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{v} \PYG{k}{if} \PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0} \PYG{p}{]}
\PYG{g+go}{[1, 81, 100]}
\end{sphinxVerbatim}

\item {} 
We can get even more sophisticated by nesting \sphinxcode{\sphinxupquote{for}} loops. Here is
an example where we generate all pairs of numbers between 1 and 4,
except for the pairs where the numbers are equal

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[} \PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j} \PYG{p}{]}
\PYG{g+go}{[(1, 2), (1, 3), (1, 4), (2, 1), (2, 3), (2, 4), (3, 1), (3, 2),}
\PYG{g+go}{    (3, 4), (4, 1), (4, 2), (4, 3)]}
\end{sphinxVerbatim}

\end{itemize}


\section{Exercises}
\label{\detokenize{lecture_notes/lec24_functional:exercises}}\begin{enumerate}
\item {} 
Write a list comprehension statement to generate a list of all
pairs of odd positive integer values less than 10 where the first value is
less than the second value.

\end{enumerate}


\section{Summary and Discussion}
\label{\detokenize{lecture_notes/lec24_functional:summary-and-discussion}}\begin{itemize}
\item {} 
We’ve explored programming that is more compact and at a higher
level of abstraction.  It can be used to effectively interact with
data.

\item {} 
\sphinxcode{\sphinxupquote{map}} and \sphinxcode{\sphinxupquote{filter}} each take a function and a sequence (an
“iterable”) as arguments and produce an iterator as a result:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{map}} produces the result of applying the function to each element
of the iterable

\item {} 
\sphinxcode{\sphinxupquote{filter}} produces each element of the iterable for which the
function returns \sphinxcode{\sphinxupquote{True}}

\end{itemize}

\item {} 
Both \sphinxcode{\sphinxupquote{map}} and \sphinxcode{\sphinxupquote{filter}} are made more compact by using
\sphinxcode{\sphinxupquote{lambda}} functions

\item {} 
\sphinxcode{\sphinxupquote{lambda}} functions can also be used to change the result of
sorting

\item {} 
A \sphinxstyleemphasis{stable sort} preserves the relative order of “tied” values

\item {} 
\sphinxstyleemphasis{List comprehensions} can be used in place of \sphinxcode{\sphinxupquote{map}} and
\sphinxcode{\sphinxupquote{filter}}:
\begin{itemize}
\item {} 
Some people prefer list comprehensions  because they often do not
require lambda functions, but…

\item {} 
List comprehensions explicitly construct the list of results rather than
generating them one-by-one, which is what \sphinxcode{\sphinxupquote{map}} and \sphinxcode{\sphinxupquote{filter}}
do.  This makes them less efficient for large data sets.

\end{itemize}

\item {} 
These are all examples of \sphinxstyleemphasis{functional programming}.

\item {} 
We’ve also used the other major programming paradigms this semester
\begin{itemize}
\item {} 
\sphinxstyleemphasis{imperative programming}

\item {} 
\sphinxstyleemphasis{object oriented programming}

\end{itemize}

\item {} 
Many modern languages like Python provide tools that allow
programming using a combination of paradigms

\end{itemize}


\chapter{Lecture 24 — Exercises}
\label{\detokenize{lecture_notes/lec24_functional_exercises/exercises:lecture-24-exercises}}\label{\detokenize{lecture_notes/lec24_functional_exercises/exercises::doc}}
Solutions to the problems below must be sent to Submitty for
automatic scoring.   A separate file must submitted for each problem.
Start with the files available on the Piazza resource page as
\sphinxstyleemphasis{lec24\_ex\_files.zip}.  Solutions must be submitted by 4 pm on Friday,
April 27. \sphinxstylestrong{Each problem requires that you write / modify exactly one
line of code!}
\begin{enumerate}
\item {} 
Modify the code in \sphinxcode{\sphinxupquote{prob1.py}} to generate a new list where all
values are replaced by their absolute values. You must use \sphinxcode{\sphinxupquote{map}},
but there is no need for a lambda function.

\item {} 
Modify the code in \sphinxcode{\sphinxupquote{prob2.py}} to determine the minimum x value of
all points that are in the first quadrant (x and y values both
positive).  This will require you to use \sphinxcode{\sphinxupquote{map}}, \sphinxcode{\sphinxupquote{filter}} and
\sphinxcode{\sphinxupquote{min}}.  You can write this in a single line, but for clarity you
are welcome to write it on two or three.  Do not create a new
list.

\item {} 
Modify the code in \sphinxcode{\sphinxupquote{prob3.py}} to sort the points in a list by
their distance from the origin (i.e. by the magnitude of the
points).  This will require use of a \sphinxcode{\sphinxupquote{lambda}} function.

\item {} 
Modify the code in \sphinxcode{\sphinxupquote{prob4.py}} to use a list comprehension
statement to convert a list of Fahrenheit temperatures to Celsius,
while eliminating those that are below freezing.

\end{enumerate}

\sphinxstylestrong{Congratulations:}  You are finished with the CS 1 lecture exercises!!


\chapter{Transition to the next class - Data Structures}
\label{\detokenize{lecture_notes/transition:transition-to-the-next-class-data-structures}}\label{\detokenize{lecture_notes/transition::doc}}

\section{Overview}
\label{\detokenize{lecture_notes/transition:overview}}
If you are continuing on your journey in Computer Science, here are
some suggestions for you.
\begin{itemize}
\item {} 
The next class in the sequence will introduce you to completely new
concepts, building on the concepts learnt in this class.

\item {} 
Make sure you are very comfortable with the concepts we learnt
here. Review labs and homeworks, make sure you can solve them
pretty easily.

\item {} 
Install a working environment in C++, which is the language you
will be using in the next class.

\item {} 
Review C++ syntax before you take your next class. Make sure you
develop:
\begin{itemize}
\item {} 
Skills to solve the CS-1 level problems in C++.

\item {} 
Skills to debug C++ programs.

\end{itemize}

Students who wrote basic C++ programs over the break did well in
Data Structures. It also helps solidify your algorithmic problem
solving skills.

\item {} 
You can also review the first few labs in Data Structures if you
wish and work on those in advance:

\sphinxurl{http://www.cs.rpi.edu/academics/courses/fall17/csci1200/calendar.php}

\end{itemize}

In this document, there are some suggestions to help you get ready for
your next class.


\section{Learning C++}
\label{\detokenize{lecture_notes/transition:learning-c}}
You are not learning C++ from scratch. Many basic constructs are very
similar in C++, but there are differences too. Here are some sources
that were highly recommended:
\begin{itemize}
\item {} 
Tutorial on C++:

\sphinxurl{http://www.cplusplus.com/doc/tutorial/}

\item {} 
See also this for a quick overview of syntax:

\sphinxurl{http://www.cs.rpi.edu/academics/courses/fall17/csci1200/other\_information.php}

\item {} 
Another good site for video tutorials:

\sphinxurl{https://www.thenewboston.com/index.php}

\end{itemize}

Go through the tutorial and the videos. Make sure to write many
programs.


\section{Differences between Python and C++}
\label{\detokenize{lecture_notes/transition:differences-between-python-and-c}}
Here are a few first things to notice between the two:
\begin{itemize}
\item {} 
C++ is a compiled statically typed language. This means that
variables need to be defined with a data type first, and the data
type cannot be changed.

\item {} 
Programs cannot be run until compiled. If you have a syntax error,
the compiler will not produce an executable until you resolve all
syntax errors.

\item {} 
In C++, many new errors will be checked at compile time, like trying
to add a string and an integer. As Python is dynamically typed, you
are used to resolving such errors at run time. This means, you will
spend more of your time in fixing compilation errors in C++ than in
Python. Hence, learn to write programs in small steps, test and
expand.

\item {} 
Syntax differences: each line in a program must end with a semicolon
and each block must be delimited by curly brackets.

\item {} 
Be aware of the scope of local/global variables. Generally using our
convention of passing variables to functions only as arguments and
returning the result will help you a lot.

\item {} 
Strings and a single character are the same type of object in
Python, but not in C++. Overall, make sure you understand each data
type well first. Start with simple data types before you go into
containers.

\item {} 
Many basic programming constructs are similar: variables, data
types, operations, operator precedence, functions, loops, files,
etc. You will find that for loops generally involve a single integer
counter, no range function. Learn the basic snytax for these first.

\item {} 
Containers will be different. Instead of lists in Python that can be
used for everything, you will need to learn about arrays, lists and
vectors in C++. All containers we used had flexible length, while in
C++, some will have predefined size.

\item {} 
You will see classes in C++ are very similar, but have a few new
limitations like private attributes that can only be used within the
class. This is actually a good thing, believe me.

\end{itemize}

For more in depth description of the differences see:
\begin{quote}

\sphinxurl{http://cs.slu.edu/~goldwasser/publications/python2cpp.pdf}

\sphinxurl{http://www4.wittenberg.edu/academics/mathcomp/shelburne/comp255/notes/Python2Cpp.pdf}
\end{quote}


\section{Setting up your C++ Working Environment}
\label{\detokenize{lecture_notes/transition:setting-up-your-c-working-environment}}
Your basic development environment in C++ consists of an editor for
writing programs, a Terminal window for compiling and running your
programs and a C++ compiler that you must install.

Here are the \sphinxhref{setting\_up\_for\_ds.html}{detailed install instructions}.
\begin{itemize}
\item {} 
You must have a C++ compiler installed.

\item {} 
You must have a terminal to run the compiler on. The terminal
replaces the “Python Shell” version of Wing for you.

\item {} 
You must use an editor to write your programs. This replaces the
editor portion of Wing. Many choices exist. The choice of editor is
not so important, but becoming proficient in using an editor is.

\end{itemize}

As most of the installation will generally involve getting familiar
with an editor, here are some common terminal operations below.


\section{Basic Terminal Operations}
\label{\detokenize{lecture_notes/transition:basic-terminal-operations}}
Basic terminal operations (Terminal in Macs and Cygwin in PCs) include:
\begin{itemize}
\item {} 
Displaying the current working directory the terminal is pointing
to:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pwd
\end{sphinxVerbatim}

\item {} 
Listing the files in the current working directory for the
terminal:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ls
\PYGZdl{} ls p*   \PYGZsh{}\PYGZsh{}lists files that start with p
\PYGZdl{} ls Dropbox   \PYGZsh{}\PYGZsh{} lists files in the directory Dropbox
             \PYGZsh{}\PYGZsh{} (assuming it is one level below it)
\end{sphinxVerbatim}

\item {} 
Changing the working directory to a directory on your file system
(cd means change directory):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd directory\PYGZus{}name
\PYGZdl{} cd directory1/directory2   \PYGZsh{}\PYGZsh{} if you want to change multiple
                           \PYGZsh{}\PYGZsh{} levels of directory in a single step
\PYGZdl{} cd ..  \PYGZsh{}\PYGZsh{} goes one level up in the dictionary hierarchy
\end{sphinxVerbatim}

\item {} 
Compile code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} g++ programname \PYGZhy{}o outputname
\end{sphinxVerbatim}

For example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} g++ program.cc \PYGZhy{}o program
\end{sphinxVerbatim}

This generates a new file called \sphinxtitleref{program} in Macs and \sphinxtitleref{program.exe}
in PCs.

\item {} 
To run a program called \sphinxtitleref{program}, use:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ./program
\end{sphinxVerbatim}

\item {} 
Create a symbolic link (a shortcut) between two folders is very good
way to simplify your life. Suppose you are at your own Desktop. I
will create a shortcut to a directory on my dropbox on my own
Desktop:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pwd
/Users/sibeladali/Desktop
\PYGZdl{} ln \PYGZhy{}s /Users/sibeladali/Dropbox/CSCI1100\PYGZus{}Fall2014/ cs1
\end{sphinxVerbatim}

\end{itemize}
\begin{quote}

This tells me to create a symbolic link (\sphinxtitleref{ln -s}) for
directory \sphinxtitleref{/Users/sibeladali/Dropbox/CSCI1100\_Fall2014/} and call
it \sphinxtitleref{cs1}. Now, I can simply write the following:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd cs1
\end{sphinxVerbatim}
\end{quote}

You are now ready to install your C++ setup.

Here are the \sphinxhref{setting\_up\_for\_ds.html}{detailed install instructions}.


\chapter{Setting up C++ for Data Structures}
\label{\detokenize{lecture_notes/setting_up_for_ds:setting-up-c-for-data-structures}}\label{\detokenize{lecture_notes/setting_up_for_ds::doc}}
This material is compiled with the help of many mentors over the
years. Special thanks to Micheal Gardner and Lee Cattarin for their
edits on prior versions of this document.

Remember to leave install fest with the following tools and skills:
\begin{itemize}
\item {} 
A compiler that works

\item {} 
Ability to compile and run a program on the terminal

\end{itemize}

It is also a good idea to have an editor or an IDE that works. If you
have additional time, install an editor and ask a mentor or TA to show
you how to use it. But this is less important. Below are instructions
on possible ways to accomplish this.


\section{Installing a terminal and a compiler}
\label{\detokenize{lecture_notes/setting_up_for_ds:installing-a-terminal-and-a-compiler}}
Data Structures requires that your C++ code compile and run on the
\sphinxcode{\sphinxupquote{gcc/g++ 4.8.x}} compiler. You may also use \sphinxcode{\sphinxupquote{clang++}}, which
provides more concise and clear error messages. How you install a
compiler will depend on your operating system, which requires the
compiler program and a Terminal to run it on.
\begin{itemize}
\item {} 
If you have \sphinxstyleemphasis{Windows 10}, you will likely want to install
Windows Subsystem for Linux (WSL). Detailed instructions to install
this can be found on the Data Structures course website:

\sphinxurl{http://www.cs.rpi.edu/academics/courses/fall17/csci1200/wsl.php}

\sphinxstylestrong{BUT} you only need to complete steps 1 through 7 for now.

\item {} 
If you have \sphinxstylestrong{Windows 7 or 8} WSL is not available and your best
option is installing \sphinxcode{\sphinxupquote{Cygwin}}. Detailed instructions to install this
can be found on the Data Structures course website:

\sphinxurl{http://www.cs.rpi.edu/academics/courses/fall17/csci1200/cygwin.php}

\end{itemize}
\begin{quote}

\sphinxstylestrong{BUT} it is not necessary to go through “Helpful edits to the
Cygwin \sphinxcode{\sphinxupquote{.bashrc}} file” right now.
\end{quote}
\begin{itemize}
\item {} 
If you have a \sphinxstylestrong{Mac}, you’ll need \sphinxstylestrong{XCode}, which provides both a
compiler and an IDE for you.

For Data Structures, \sphinxstylestrong{make sure to install XCode’s “Command
Line Tools”} so that you can compile and run your code in the
terminal as well as the IDE. Install instructions for XCode and
XCode Command Line Tools can be found:

\sphinxurl{http://railsapps.github.io/xcode-command-line-tools.html}

You can then run a Terminal window: Terminal under
Applications-\textgreater{}Utilities in Macs (black box)

\item {} 
If you have a Linux OS such as \sphinxstylestrong{Ubuntu}, installing is easy. Run
the following three commands in a terminal window:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{g}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{clang}\PYG{o}{+}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.8}
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{gcc}\PYG{o}{\PYGZhy{}}\PYG{n}{multilib} \PYG{n}{g}\PYG{o}{+}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{n}{multilib}
\end{sphinxVerbatim}

\end{itemize}


\section{Choosing an editor or IDE (Integrated Development Environment)}
\label{\detokenize{lecture_notes/setting_up_for_ds:choosing-an-editor-or-ide-integrated-development-environment}}
A text editor will allow you to view and edit your code (often with
syntax highlighting or other features), but not compile and run - you
have to do that in a terminal (cygwin, for Windows). An IDE will do
all of these things, but might take more time to learn how to navigate
as they are usually fuller-featured. Whichever you choose, \sphinxstylestrong{you will
still have to learn how to compile and run your code in a terminal},
as that is the primary method to get help or show completeness in lab.
\begin{itemize}
\item {} 
If you want a text editor, these options are popular:
\begin{itemize}
\item {} 
Sublime Text: \sphinxurl{http://www.sublimetext.com/}

\item {} 
Atom (very similar to Sublime Text): \sphinxurl{https://atom.io/}

\item {} 
Notepad++: \sphinxurl{https://notepad-plus-plus.org/}
Windows only, note that this is \sphinxstylestrong{not} Notepad

\item {} 
Gedit: \sphinxurl{https://wiki.gnome.org/Apps/Gedit}\#Download
(this is usually installed by default on some Linux systems)

\item {} 
There are also terminal editors like

Vim: \sphinxurl{http://www.vim.org/}

Nano: \sphinxurl{https://www.nano-editor.org/}

Emacs: \sphinxurl{https://www.gnu.org/software/emacs/}

but these may have a steeper learning curve!

\end{itemize}

\item {} 
If you want an IDE, these options work with the compiler you’ll be
using:
\begin{itemize}
\item {} 
Eclipse: \sphinxurl{http://www.eclipse.org/cdt/}
(this is used in a later Computer Science course as well)

\item {} 
Code::Blocks: http://www.codeblocks.org/

\item {} 
Xcode (Mac only): \sphinxurl{https://developer.apple.com/xcode/}

\item {} 
NetBeans: \sphinxurl{https://netbeans.org/features/cpp/}

and from the Data Structures site, notes on using NetBeans with C and C++:

\sphinxurl{http://chriseiffel.com/uncategorized/windows-c-compiler-how-to/}

\end{itemize}

\end{itemize}

If you are having trouble deciding, ask the TAs and mentors what they use!

Remember: IDEs are useful for debugging with a graphical user
interface. But, it is likely that no one will be an expert in the
specific IDE you use. Practice and learn its features before starting
to use it in class assignments.


\section{Final Note}
\label{\detokenize{lecture_notes/setting_up_for_ds:final-note}}
If you find additional resources that are useful, please feel free to
let us know. We will include them here.



\renewcommand{\indexname}{Index}
\printindex
\end{document}